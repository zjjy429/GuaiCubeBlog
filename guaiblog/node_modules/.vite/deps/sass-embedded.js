import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/sass-embedded/dist/package.json
var require_package = __commonJS({
  "node_modules/sass-embedded/dist/package.json"(exports, module) {
    module.exports = {
      name: "sass-embedded",
      version: "1.83.4",
      "protocol-version": "3.1.0",
      "compiler-version": "1.83.4",
      description: "Node.js library that communicates with Embedded Dart Sass using the Embedded Sass protocol",
      repository: "sass/embedded-host-node",
      author: "Google Inc.",
      license: "MIT",
      exports: {
        import: {
          types: "./dist/types/index.m.d.ts",
          default: "./dist/lib/index.mjs"
        },
        types: "./dist/types/index.d.ts",
        default: "./dist/lib/index.js"
      },
      main: "dist/lib/index.js",
      types: "dist/types/index.d.ts",
      files: [
        "dist/**/*"
      ],
      engines: {
        node: ">=16.0.0"
      },
      bin: {
        sass: "dist/bin/sass.js"
      },
      scripts: {
        init: "ts-node ./tool/init.ts",
        check: "npm-run-all check:gts check:tsc",
        "check:gts": "gts check",
        "check:tsc": "tsc --noEmit",
        clean: "gts clean",
        compile: "tsc -p tsconfig.build.json && cp lib/index.mjs dist/lib/index.mjs && cp -r lib/src/vendor/sass/ dist/lib/src/vendor/sass && cp dist/lib/src/vendor/sass/index.d.ts dist/lib/src/vendor/sass/index.m.d.ts",
        fix: "gts fix",
        prepublishOnly: "npm run clean && ts-node ./tool/prepare-release.ts",
        test: "jest"
      },
      optionalDependencies: {
        "sass-embedded-android-arm": "1.83.4",
        "sass-embedded-android-arm64": "1.83.4",
        "sass-embedded-android-ia32": "1.83.4",
        "sass-embedded-android-riscv64": "1.83.4",
        "sass-embedded-android-x64": "1.83.4",
        "sass-embedded-darwin-arm64": "1.83.4",
        "sass-embedded-darwin-x64": "1.83.4",
        "sass-embedded-linux-arm": "1.83.4",
        "sass-embedded-linux-arm64": "1.83.4",
        "sass-embedded-linux-ia32": "1.83.4",
        "sass-embedded-linux-riscv64": "1.83.4",
        "sass-embedded-linux-x64": "1.83.4",
        "sass-embedded-linux-musl-arm": "1.83.4",
        "sass-embedded-linux-musl-arm64": "1.83.4",
        "sass-embedded-linux-musl-ia32": "1.83.4",
        "sass-embedded-linux-musl-riscv64": "1.83.4",
        "sass-embedded-linux-musl-x64": "1.83.4",
        "sass-embedded-win32-arm64": "1.83.4",
        "sass-embedded-win32-ia32": "1.83.4",
        "sass-embedded-win32-x64": "1.83.4"
      },
      dependencies: {
        "@bufbuild/protobuf": "^2.0.0",
        "buffer-builder": "^0.2.0",
        "colorjs.io": "^0.5.0",
        immutable: "^5.0.2",
        rxjs: "^7.4.0",
        "supports-color": "^8.1.1",
        "sync-child-process": "^1.0.2",
        varint: "^6.0.0"
      },
      devDependencies: {
        "@bufbuild/buf": "^1.39.0",
        "@bufbuild/protoc-gen-es": "^2.0.0",
        "@types/buffer-builder": "^0.2.0",
        "@types/google-protobuf": "^3.7.2",
        "@types/jest": "^29.4.0",
        "@types/node": "^22.0.0",
        "@types/shelljs": "^0.8.8",
        "@types/supports-color": "^8.1.1",
        "@types/tar": "^6.1.0",
        "@types/varint": "^6.0.1",
        "@types/yargs": "^17.0.4",
        "extract-zip": "^2.0.1",
        gts: "^6.0.2",
        jest: "^29.4.1",
        "npm-run-all": "^4.1.5",
        shelljs: "^0.8.4",
        "simple-git": "^3.15.1",
        "source-map-js": "^1.0.2",
        tar: "^6.0.5",
        "ts-jest": "^29.0.5",
        "ts-node": "^10.2.1",
        typescript: "^5.0.2",
        yaml: "^2.2.1",
        yargs: "^17.2.1"
      }
    };
  }
});

// node_modules/immutable/dist/immutable.es.js
var immutable_es_exports = {};
__export(immutable_es_exports, {
  Collection: () => Collection,
  Iterable: () => Iterable,
  List: () => List,
  Map: () => Map2,
  OrderedMap: () => OrderedMap,
  OrderedSet: () => OrderedSet,
  PairSorting: () => PairSorting,
  Range: () => Range,
  Record: () => Record,
  Repeat: () => Repeat,
  Seq: () => Seq,
  Set: () => Set2,
  Stack: () => Stack,
  fromJS: () => fromJS,
  get: () => get,
  getIn: () => getIn$1,
  has: () => has,
  hasIn: () => hasIn$1,
  hash: () => hash,
  is: () => is,
  isAssociative: () => isAssociative,
  isCollection: () => isCollection,
  isImmutable: () => isImmutable,
  isIndexed: () => isIndexed,
  isKeyed: () => isKeyed,
  isList: () => isList,
  isMap: () => isMap,
  isOrdered: () => isOrdered,
  isOrderedMap: () => isOrderedMap,
  isOrderedSet: () => isOrderedSet,
  isPlainObject: () => isPlainObject,
  isRecord: () => isRecord,
  isSeq: () => isSeq,
  isSet: () => isSet,
  isStack: () => isStack,
  isValueObject: () => isValueObject,
  merge: () => merge,
  mergeDeep: () => mergeDeep$1,
  mergeDeepWith: () => mergeDeepWith$1,
  mergeWith: () => mergeWith,
  remove: () => remove,
  removeIn: () => removeIn,
  set: () => set,
  setIn: () => setIn$1,
  update: () => update$1,
  updateIn: () => updateIn$1,
  version: () => version
});
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function OwnerID() {
}
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}
function wrapIndex(iter, index) {
  if (typeof index !== "number") {
    var uint32Index = index >>> 0;
    if ("" + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}
function returnTrue() {
  return true;
}
function wholeSlice(begin, end, size) {
  return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
}
function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
  return index === void 0 ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === void 0 || size === index ? index : Math.min(size, index) | 0;
}
function isNeg(value) {
  return value < 0 || value === 0 && 1 / value === -Infinity;
}
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === "function";
}
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === "string") {
    return true;
  }
  return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? (
    // Only {length: 0} is considered Array-like.
    Object.keys(value).length === 1
  ) : (
    // An object is only Array-like if it has a property where the last value
    // in the array-like may be found (which could be undefined).
    value.hasOwnProperty(value.length - 1)
  ));
}
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + value
  );
}
function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    "Expected Array or collection object of values: " + value
  );
}
function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + value
  );
}
function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
function isMap(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function isValueObject(maybeValue) {
  return Boolean(
    maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function"
  );
}
function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  var v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  var hash2 = n | 0;
  if (hash2 !== n) {
    hash2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    n /= 4294967295;
    hash2 ^= n;
  }
  return smi(hash2);
}
function cachedHashString(string) {
  var hashed = stringHashCache[string];
  if (hashed === void 0) {
    hashed = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}
function hashString(string) {
  var hashed = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hashed = 31 * hashed + string.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key) {
    return collection.includes(key);
  };
  flipSequence.includes = function(key) {
    return collection.has(key);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v, k) {
      return fn(k, v, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type, reverse3) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse3);
      return new Iterator(function() {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse3
    );
  };
  return flipSequence;
}
function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key) {
    return collection.has(key);
  };
  mappedSequence.get = function(key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(
      function(v, k, c) {
        return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
      },
      reverse3
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };
  reversedSequence.has = function(key) {
    return collection.has(useKeys ? key : -1 - key);
  };
  reversedSequence.includes = function(value) {
    return collection.includes(value);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse3) {
    var this$1$12 = this;
    var i = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(
      function(v, k) {
        return fn(v, useKeys ? k : reverse3 ? this$1$12.size - ++i : i++, this$1$12);
      },
      !reverse3
    );
  };
  reversedSequence.__iterator = function(type, reverse3) {
    var i = 0;
    reverse3 && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i : i++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}
function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };
    filterSequence.get = function(key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}
function countByFactory(collection, grouper, context) {
  var groups = Map2().asMutable();
  collection.__iterate(function(v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function(a) {
      return a + 1;
    });
  });
  return groups.asImmutable();
}
function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map2()).asMutable();
  collection.__iterate(function(v, k) {
    groups.update(
      grouper.call(context, v, k, collection),
      function(a) {
        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
      }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}
function partitionFactory(collection, predicate, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = [[], []];
  collection.__iterate(function(v, k) {
    groups[predicate.call(context, v, k, collection) ? 1 : 0].push(
      isKeyedIter ? [k, v] : v
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  });
}
function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }
  if (typeof originalSize === "undefined" && (begin < 0 || end < 0)) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function() {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, void 0, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    collection.__iterate(
      function(v, k, c) {
        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
      }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return takeSequence;
}
function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function() {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, void 0, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return skipSequence;
}
function concatFactory(collection, values2) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values2).map(function(v) {
    if (!isCollection(v)) {
      v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
    } else if (isKeyedCollection) {
      v = KeyedCollection(v);
    }
    return v;
  }).filter(function(v) {
    return v.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function(sum, seq) {
    if (sum !== void 0) {
      var size = seq.size;
      if (size !== void 0) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(type, reverse3);
    var stack = [];
    var iterations = 0;
    return new Iterator(function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v, k) {
    return coerce(mapper.call(context, v, k, collection));
  }).flatten(true);
}
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(
      function(v) {
        return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
      },
      reverse3
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator(function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries3 = collection.toSeq().map(function(v, k) {
    return [k, v, index++, mapper ? mapper(v, k, collection) : v];
  }).valueSeq().toArray();
  entries3.sort(function(a, b) {
    return comparator(a[3], b[3]) || a[2] - b[2];
  }).forEach(
    isKeyedCollection ? function(v, i) {
      entries3[i].length = 2;
    } : function(v, i) {
      entries3[i] = v[1];
    }
  );
  return isKeyedCollection ? KeyedSeq(entries3) : isIndexed(collection) ? IndexedSeq(entries3) : SetSeq(entries3);
}
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v, k) {
      return [v, mapper(v, k, collection)];
    }).reduce(function(a, b) {
      return maxCompare(comparator, a[1], b[1]) ? b : a;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a, b) {
    return maxCompare(comparator, a, b) ? b : a;
  });
}
function maxCompare(comparator, a, b) {
  var comp = comparator(b, a);
  return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll2) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function(i) {
    return i.size;
  });
  zipSequence.size = zipAll2 ? sizes.max() : sizes.min();
  zipSequence.__iterate = function(fn, reverse3) {
    var iterator = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse3) {
    var iterators = iters.map(
      function(i) {
        return i = Collection(i), getIterator(reverse3 ? i.reverse() : i);
      }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function() {
      var steps;
      if (!isDone) {
        steps = iterators.map(function(i) {
          return i.next();
        });
        isDone = zipAll2 ? steps.every(function(s) {
          return s.done;
        }) : steps.some(function(s) {
          return s.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(
          null,
          steps.map(function(s) {
            return s.value;
          })
        )
      );
    });
  };
  return zipSequence;
}
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a, b) {
  if (a === void 0 && b === void 0) {
    return 0;
  }
  if (a === void 0) {
    return 1;
  }
  if (b === void 0) {
    return -1;
  }
  return a > b ? 1 : a < b ? -1 : 0;
}
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}
function invariant(condition, error) {
  if (!condition) {
    throw new Error(error);
  }
}
function assertNotInfinite(size) {
  invariant(
    size !== Infinity,
    "Cannot perform this action with an infinite size."
  );
}
function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    "Invalid keyPath: expected Ordered Collection or Array: " + keyPath
  );
}
function isPlainObject(value) {
  if (!value || typeof value !== "object" || toString2.call(value) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var parentProto = proto;
  var nextProto = Object.getPrototypeOf(proto);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto;
}
function isDataStructure(value) {
  return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));
}
function quoteString(value) {
  try {
    return typeof value === "string" ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}
function has(collection, key) {
  return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}
function get(collection, key, notSetValue) {
  return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to = {};
  for (var key in from) {
    if (hasOwnProperty.call(from, key)) {
      to[key] = from[key];
    }
  }
  return to;
}
function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        "Cannot update immutable value without .remove() method: " + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}
function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError(
        "Cannot update immutable value without .set() method: " + collection
      );
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}
function updateIn$1(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      "Cannot update within non-data-structure value in path [" + keyPath.slice(0, i).map(quoteString) + "]: " + existing
    );
  }
  var key = keyPath[i];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    nextExisting,
    keyPath,
    i + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(
    wasNotSet ? inImmutable ? emptyMap() : {} : existing,
    key,
    nextUpdated
  );
}
function setIn$1(collection, keyPath, value) {
  return updateIn$1(collection, keyPath, NOT_SET, function() {
    return value;
  });
}
function setIn(keyPath, v) {
  return setIn$1(this, keyPath, v);
}
function removeIn(collection, keyPath) {
  return updateIn$1(collection, keyPath, function() {
    return NOT_SET;
  });
}
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
function update$1(collection, key, notSetValue, updater) {
  return updateIn$1(collection, [key], notSetValue, updater);
}
function update(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
function updateIn(keyPath, notSetValue, updater) {
  return updateIn$1(this, keyPath, notSetValue, updater);
}
function merge$1() {
  var iters = [], len = arguments.length;
  while (len--) iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value, key) {
      update$1(
        collection2,
        key,
        NOT_SET,
        function(oldVal) {
          return oldVal === NOT_SET ? value : merger(oldVal, value, key);
        }
      );
    } : function(value, key) {
      collection2.set(key, value);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
function merge(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0) sources[len] = arguments[len + 1];
  return mergeWithSources(collection, sources);
}
function mergeWith(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0) sources[len] = arguments[len + 2];
  return mergeWithSources(collection, sources, merger);
}
function mergeDeep$1(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0) sources[len] = arguments[len + 1];
  return mergeDeepWithSources(collection, sources);
}
function mergeDeepWith$1(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0) sources[len] = arguments[len + 2];
  return mergeDeepWithSources(collection, sources, merger);
}
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray ? function(value) {
    if (merged === collection) {
      merged = shallowCopy(merged);
    }
    merged.push(value);
  } : function(value, key) {
    var hasVal = hasOwnProperty.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
    if (!hasVal || nextVal !== merged[key]) {
      if (merged === collection) {
        merged = shallowCopy(merged);
      }
      merged[key] = nextVal;
    }
  };
  for (var i = 0; i < sources.length; i++) {
    Collection3(sources[i]).forEach(mergeItem);
  }
  return merged;
}
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }
  return deepMerger;
}
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--) iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m) {
    return mergeWithSources(m, iters);
  });
}
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return updateIn$1(
    this,
    keyPath,
    emptyMap(),
    function(m) {
      return mergeDeepWithSources(m, iters);
    }
  );
}
function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function asImmutable() {
  return this.__ensureOwner();
}
function wasAltered() {
  return this.__altered;
}
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
function makeMap(size, root, ownerID, hash2) {
  var map2 = Object.create(MapPrototype);
  map2.size = size;
  map2._root = root;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map2, k, v) {
  var newRoot;
  var newSize;
  if (!map2._root) {
    if (v === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map2._root,
      map2.__ownerID,
      0,
      void 0,
      k,
      v,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries3, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries3.length; ii++) {
    var entry = entries3[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count2, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count2);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count2 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
function iterateList(list, reverse3) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;
  return iterateNodeOrLeaf(list._root, list._level, 0);
  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
  }
  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to = right - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      if (from === to) {
        return DONE;
      }
      var idx = reverse3 ? --to : from++;
      return array && array[idx];
    };
  }
  function iterateNode(node, level, offset) {
    var values2;
    var array = node && node.array;
    var from = offset > left ? 0 : left - offset >> level;
    var to = (right - offset >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      while (true) {
        if (values2) {
          var value = values2();
          if (value !== DONE) {
            return value;
          }
          values2 = null;
        }
        if (from === to) {
          return DONE;
        }
        var idx = reverse3 ? --to : from++;
        values2 = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}
function makeList(origin, capacity, level, root, tail, ownerID, hash2) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash2;
  list.__altered = false;
  return list;
}
function emptyList() {
  return makeList(0, 0, SHIFT);
}
function updateList(list, index, value) {
  index = wrapIndex(list, index);
  if (index !== index) {
    return list;
  }
  if (index >= list.size || index < 0) {
    return list.withMutations(function(list2) {
      index < 0 ? setListBounds(list2, index).set(0, value) : setListBounds(list2, 0, index + 1).set(index, value);
    });
  }
  index += list._origin;
  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value,
      didAlter
    );
  }
  if (!didAlter.value) {
    return list;
  }
  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setListBounds(list, begin, end) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end !== void 0) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }
  if (newOrigin >= newCapacity) {
    return list.clear();
  }
  var newLevel = list._level;
  var newRoot = list._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [void 0, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }
  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
function makeOrderedMap(map2, list, ownerID, hash2) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map2 ? map2.size : 0;
  omap._map = map2;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash2;
  omap.__altered = false;
  return omap;
}
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v) {
  var map2 = omap._map;
  var list = omap._list;
  var i = map2.get(k);
  var has5 = i !== void 0;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    if (!has5) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map2.size * 2) {
      newList = list.filter(function(entry, idx) {
        return entry !== void 0 && i !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map2.remove(k);
      newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
    }
  } else if (has5) {
    if (v === list.get(i)[1]) {
      return omap;
    }
    newMap = map2;
    newList = list.set(i, [k, v]);
  } else {
    newMap = map2.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
function makeStack(size, head, ownerID, hash2) {
  var map2 = Object.create(StackPrototype);
  map2.size = size;
  map2._head = head;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
function isSet(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (!isCollection(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
    return false;
  }
  if (a.size === 0 && b.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a);
  if (isOrdered(a)) {
    var entries3 = a.entries();
    return b.every(function(v, k) {
      var entry = entries3.next().value;
      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
    }) && entries3.next().done;
  }
  var flipped = false;
  if (a.size === void 0) {
    if (b.size === void 0) {
      if (typeof a.cacheResult === "function") {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }
  var allEqual = true;
  var bSize = b.__iterate(function(v, k) {
    if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
      allEqual = false;
      return false;
    }
  });
  return allEqual && a.size === bSize;
}
function mixin(ctor, methods) {
  var keyCopier = function(key) {
    ctor.prototype[key] = methods[key];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}
function toJS(value) {
  if (!value || typeof value !== "object") {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function(v, k) {
      result$1[k] = toJS(v);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function(v) {
    result.push(toJS(v));
  });
  return result;
}
function updateSet(set3, newMap) {
  if (set3.__ownerID) {
    set3.size = newMap.size;
    set3._map = newMap;
    return set3;
  }
  return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
}
function makeSet(map2, ownerID) {
  var set3 = Object.create(SetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i = 0;
  while (i !== keyPath.length) {
    collection = get(collection, keyPath[i++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}
function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k) {
    object[k] = v;
  });
  return object;
}
function reduce(collection, reducer, reduction, context, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v, k, c) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context, reduction, v, k, c);
    }
  }, reverse3);
  return reduction;
}
function keyMapper(v, k) {
  return k;
}
function entryMapper(v, k) {
  return [k, v];
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}
function defaultZipper() {
  return arrCopy(arguments);
}
function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  collection.__iterate(
    keyed ? ordered ? function(v, k) {
      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
    } : function(v, k) {
      h = h + hashMerge(hash(v), hash(k)) | 0;
    } : ordered ? function(v) {
      h = 31 * h + hash(v) | 0;
    } : function(v) {
      h = h + hash(v) | 0;
    }
  );
  return murmurHashOfSize(collection.size, h);
}
function murmurHashOfSize(size, h) {
  h = imul(h, 3432918353);
  h = imul(h << 15 | h >>> -15, 461845907);
  h = imul(h << 13 | h >>> -13, 5);
  h = (h + 3864292196 | 0) ^ size;
  h = imul(h ^ h >>> 16, 2246822507);
  h = imul(h ^ h >>> 13, 3266489909);
  h = smi(h ^ h >>> 16);
  return h;
}
function hashMerge(a, b) {
  return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
}
function makeOrderedSet(map2, ownerID) {
  var set3 = Object.create(OrderedSetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
function throwOnInvalidDefaultValues(defaultValues) {
  if (isRecord(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  }
  if (isImmutable(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  }
  if (defaultValues === null || typeof defaultValues !== "object") {
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
  }
}
function makeRecord(likeRecord, values2, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values2;
  record.__ownerID = ownerID;
  return record;
}
function recordName(record) {
  return record.constructor.displayName || record.constructor.name || "Record";
}
function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function(k) {
    return [k, record.get(k)];
  }));
}
function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, "Cannot set on an immutable record.");
        this.set(name, value);
      }
    });
  } catch (error) {
  }
}
function fromJS(value, converter) {
  return fromJSWith(
    [],
    converter || defaultConverter,
    value,
    "",
    converter && converter.length > 2 ? [] : void 0,
    { "": value }
  );
}
function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
  if (typeof value !== "string" && !isImmutable(value) && (isArrayLike(value) || hasIterator(value) || isPlainObject(value))) {
    if (~stack.indexOf(value)) {
      throw new TypeError("Cannot convert circular structure to Immutable");
    }
    stack.push(value);
    keyPath && key !== "" && keyPath.push(key);
    var converted = converter.call(
      parentValue,
      key,
      Seq(value).map(
        function(v, k) {
          return fromJSWith(stack, converter, v, k, keyPath, value);
        }
      ),
      keyPath && keyPath.slice()
    );
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }
  return value;
}
function defaultConverter(k, v) {
  return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
}
var DELETE, SHIFT, SIZE, MASK, NOT_SET, IS_COLLECTION_SYMBOL, IS_KEYED_SYMBOL, IS_INDEXED_SYMBOL, Collection, KeyedCollection, IndexedCollection, SetCollection, IS_SEQ_SYMBOL, IS_RECORD_SYMBOL, IS_ORDERED_SYMBOL, ITERATE_KEYS, ITERATE_VALUES, ITERATE_ENTRIES, REAL_ITERATOR_SYMBOL, FAUX_ITERATOR_SYMBOL, ITERATOR_SYMBOL, Iterator, hasOwnProperty, Seq, KeyedSeq, IndexedSeq, SetSeq, ArraySeq, ObjectSeq, CollectionSeq, EMPTY_SEQ, IS_MAP_SYMBOL, imul, defaultValueOf, isExtensible, canDefineProperty, usingWeakMap, weakMap, symbolMap, _objHashUID, UID_HASH_KEY, STRING_HASH_CACHE_MIN_STRLEN, STRING_HASH_CACHE_MAX_SIZE, STRING_HASH_CACHE_SIZE, stringHashCache, ToKeyedSequence, ToIndexedSequence, ToSetSequence, FromEntriesSequence, toString2, Map2, MapPrototype, ArrayMapNode, BitmapIndexedNode, HashArrayMapNode, HashCollisionNode, ValueNode, MapIterator, EMPTY_MAP, MAX_ARRAY_MAP_SIZE, MAX_BITMAP_INDEXED_SIZE, MIN_HASH_ARRAY_MAP_SIZE, IS_LIST_SYMBOL, List, ListPrototype, VNode, DONE, OrderedMap, EMPTY_ORDERED_MAP, IS_STACK_SYMBOL, Stack, StackPrototype, EMPTY_STACK, IS_SET_SYMBOL, Set2, SetPrototype, EMPTY_SET, Range, EMPTY_RANGE, CollectionPrototype, KeyedCollectionPrototype, IndexedCollectionPrototype, SetCollectionPrototype, OrderedSet, OrderedSetPrototype, EMPTY_ORDERED_SET, PairSorting, Record, RecordPrototype, Repeat, EMPTY_REPEAT, version, Iterable;
var init_immutable_es = __esm({
  "node_modules/immutable/dist/immutable.es.js"() {
    DELETE = "delete";
    SHIFT = 5;
    SIZE = 1 << SHIFT;
    MASK = SIZE - 1;
    NOT_SET = {};
    IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
    IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
    IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
    Collection = function Collection2(value) {
      return isCollection(value) ? value : Seq(value);
    };
    KeyedCollection = function(Collection3) {
      function KeyedCollection2(value) {
        return isKeyed(value) ? value : KeyedSeq(value);
      }
      if (Collection3) KeyedCollection2.__proto__ = Collection3;
      KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      KeyedCollection2.prototype.constructor = KeyedCollection2;
      return KeyedCollection2;
    }(Collection);
    IndexedCollection = function(Collection3) {
      function IndexedCollection2(value) {
        return isIndexed(value) ? value : IndexedSeq(value);
      }
      if (Collection3) IndexedCollection2.__proto__ = Collection3;
      IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      IndexedCollection2.prototype.constructor = IndexedCollection2;
      return IndexedCollection2;
    }(Collection);
    SetCollection = function(Collection3) {
      function SetCollection2(value) {
        return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
      }
      if (Collection3) SetCollection2.__proto__ = Collection3;
      SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      SetCollection2.prototype.constructor = SetCollection2;
      return SetCollection2;
    }(Collection);
    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;
    IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
    IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
    IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
    ITERATE_KEYS = 0;
    ITERATE_VALUES = 1;
    ITERATE_ENTRIES = 2;
    REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    FAUX_ITERATOR_SYMBOL = "@@iterator";
    ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
    Iterator = function Iterator2(next) {
      this.next = next;
    };
    Iterator.prototype.toString = function toString() {
      return "[Iterator]";
    };
    Iterator.KEYS = ITERATE_KEYS;
    Iterator.VALUES = ITERATE_VALUES;
    Iterator.ENTRIES = ITERATE_ENTRIES;
    Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
      return this.toString();
    };
    Iterator.prototype[ITERATOR_SYMBOL] = function() {
      return this;
    };
    hasOwnProperty = Object.prototype.hasOwnProperty;
    Seq = function(Collection3) {
      function Seq2(value) {
        return value === void 0 || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
      }
      if (Collection3) Seq2.__proto__ = Collection3;
      Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
      Seq2.prototype.constructor = Seq2;
      Seq2.prototype.toSeq = function toSeq3() {
        return this;
      };
      Seq2.prototype.toString = function toString5() {
        return this.__toString("Seq {", "}");
      };
      Seq2.prototype.cacheResult = function cacheResult() {
        if (!this._cache && this.__iterateUncached) {
          this._cache = this.entrySeq().toArray();
          this.size = this._cache.length;
        }
        return this;
      };
      Seq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var cache = this._cache;
        if (cache) {
          var size = cache.length;
          var i = 0;
          while (i !== size) {
            var entry = cache[reverse3 ? size - ++i : i++];
            if (fn(entry[1], entry[0], this) === false) {
              break;
            }
          }
          return i;
        }
        return this.__iterateUncached(fn, reverse3);
      };
      Seq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var cache = this._cache;
        if (cache) {
          var size = cache.length;
          var i = 0;
          return new Iterator(function() {
            if (i === size) {
              return iteratorDone();
            }
            var entry = cache[reverse3 ? size - ++i : i++];
            return iteratorValue(type, entry[0], entry[1]);
          });
        }
        return this.__iteratorUncached(type, reverse3);
      };
      return Seq2;
    }(Collection);
    KeyedSeq = function(Seq2) {
      function KeyedSeq2(value) {
        return value === void 0 || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
      }
      if (Seq2) KeyedSeq2.__proto__ = Seq2;
      KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      KeyedSeq2.prototype.constructor = KeyedSeq2;
      KeyedSeq2.prototype.toKeyedSeq = function toKeyedSeq3() {
        return this;
      };
      return KeyedSeq2;
    }(Seq);
    IndexedSeq = function(Seq2) {
      function IndexedSeq2(value) {
        return value === void 0 || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
      }
      if (Seq2) IndexedSeq2.__proto__ = Seq2;
      IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      IndexedSeq2.prototype.constructor = IndexedSeq2;
      IndexedSeq2.of = function of() {
        return IndexedSeq2(arguments);
      };
      IndexedSeq2.prototype.toIndexedSeq = function toIndexedSeq2() {
        return this;
      };
      IndexedSeq2.prototype.toString = function toString5() {
        return this.__toString("Seq [", "]");
      };
      return IndexedSeq2;
    }(Seq);
    SetSeq = function(Seq2) {
      function SetSeq2(value) {
        return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
      }
      if (Seq2) SetSeq2.__proto__ = Seq2;
      SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      SetSeq2.prototype.constructor = SetSeq2;
      SetSeq2.of = function of() {
        return SetSeq2(arguments);
      };
      SetSeq2.prototype.toSetSeq = function toSetSeq2() {
        return this;
      };
      return SetSeq2;
    }(Seq);
    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;
    Seq.prototype[IS_SEQ_SYMBOL] = true;
    ArraySeq = function(IndexedSeq2) {
      function ArraySeq2(array) {
        this._array = array;
        this.size = array.length;
      }
      if (IndexedSeq2) ArraySeq2.__proto__ = IndexedSeq2;
      ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      ArraySeq2.prototype.constructor = ArraySeq2;
      ArraySeq2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
      };
      ArraySeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var array = this._array;
        var size = array.length;
        var i = 0;
        while (i !== size) {
          var ii = reverse3 ? size - ++i : i++;
          if (fn(array[ii], ii, this) === false) {
            break;
          }
        }
        return i;
      };
      ArraySeq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var array = this._array;
        var size = array.length;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var ii = reverse3 ? size - ++i : i++;
          return iteratorValue(type, ii, array[ii]);
        });
      };
      return ArraySeq2;
    }(IndexedSeq);
    ObjectSeq = function(KeyedSeq2) {
      function ObjectSeq2(object) {
        var keys2 = Object.keys(object).concat(
          Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []
        );
        this._object = object;
        this._keys = keys2;
        this.size = keys2.length;
      }
      if (KeyedSeq2) ObjectSeq2.__proto__ = KeyedSeq2;
      ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      ObjectSeq2.prototype.constructor = ObjectSeq2;
      ObjectSeq2.prototype.get = function get11(key, notSetValue) {
        if (notSetValue !== void 0 && !this.has(key)) {
          return notSetValue;
        }
        return this._object[key];
      };
      ObjectSeq2.prototype.has = function has5(key) {
        return hasOwnProperty.call(this._object, key);
      };
      ObjectSeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var object = this._object;
        var keys2 = this._keys;
        var size = keys2.length;
        var i = 0;
        while (i !== size) {
          var key = keys2[reverse3 ? size - ++i : i++];
          if (fn(object[key], key, this) === false) {
            break;
          }
        }
        return i;
      };
      ObjectSeq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var object = this._object;
        var keys2 = this._keys;
        var size = keys2.length;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var key = keys2[reverse3 ? size - ++i : i++];
          return iteratorValue(type, key, object[key]);
        });
      };
      return ObjectSeq2;
    }(KeyedSeq);
    ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
    CollectionSeq = function(IndexedSeq2) {
      function CollectionSeq2(collection) {
        this._collection = collection;
        this.size = collection.length || collection.size;
      }
      if (IndexedSeq2) CollectionSeq2.__proto__ = IndexedSeq2;
      CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      CollectionSeq2.prototype.constructor = CollectionSeq2;
      CollectionSeq2.prototype.__iterateUncached = function __iterateUncached(fn, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var collection = this._collection;
        var iterator = getIterator(collection);
        var iterations = 0;
        if (isIterator(iterator)) {
          var step;
          while (!(step = iterator.next()).done) {
            if (fn(step.value, iterations++, this) === false) {
              break;
            }
          }
        }
        return iterations;
      };
      CollectionSeq2.prototype.__iteratorUncached = function __iteratorUncached(type, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var collection = this._collection;
        var iterator = getIterator(collection);
        if (!isIterator(iterator)) {
          return new Iterator(iteratorDone);
        }
        var iterations = 0;
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type, iterations++, step.value);
        });
      };
      return CollectionSeq2;
    }(IndexedSeq);
    IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
    imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a, b) {
      a |= 0;
      b |= 0;
      var c = a & 65535;
      var d = b & 65535;
      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
    };
    defaultValueOf = Object.prototype.valueOf;
    isExtensible = Object.isExtensible;
    canDefineProperty = function() {
      try {
        Object.defineProperty({}, "@", {});
        return true;
      } catch (e) {
        return false;
      }
    }();
    usingWeakMap = typeof WeakMap === "function";
    if (usingWeakMap) {
      weakMap = /* @__PURE__ */ new WeakMap();
    }
    symbolMap = /* @__PURE__ */ Object.create(null);
    _objHashUID = 0;
    UID_HASH_KEY = "__immutablehash__";
    if (typeof Symbol === "function") {
      UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }
    STRING_HASH_CACHE_MIN_STRLEN = 16;
    STRING_HASH_CACHE_MAX_SIZE = 255;
    STRING_HASH_CACHE_SIZE = 0;
    stringHashCache = {};
    ToKeyedSequence = function(KeyedSeq2) {
      function ToKeyedSequence2(indexed, useKeys) {
        this._iter = indexed;
        this._useKeys = useKeys;
        this.size = indexed.size;
      }
      if (KeyedSeq2) ToKeyedSequence2.__proto__ = KeyedSeq2;
      ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
      ToKeyedSequence2.prototype.get = function get11(key, notSetValue) {
        return this._iter.get(key, notSetValue);
      };
      ToKeyedSequence2.prototype.has = function has5(key) {
        return this._iter.has(key);
      };
      ToKeyedSequence2.prototype.valueSeq = function valueSeq2() {
        return this._iter.valueSeq();
      };
      ToKeyedSequence2.prototype.reverse = function reverse3() {
        var this$1$1 = this;
        var reversedSequence = reverseFactory(this, true);
        if (!this._useKeys) {
          reversedSequence.valueSeq = function() {
            return this$1$1._iter.toSeq().reverse();
          };
        }
        return reversedSequence;
      };
      ToKeyedSequence2.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        var mappedSequence = mapFactory(this, mapper, context);
        if (!this._useKeys) {
          mappedSequence.valueSeq = function() {
            return this$1$1._iter.toSeq().map(mapper, context);
          };
        }
        return mappedSequence;
      };
      ToKeyedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(v, k) {
          return fn(v, k, this$1$1);
        }, reverse3);
      };
      ToKeyedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._iter.__iterator(type, reverse3);
      };
      return ToKeyedSequence2;
    }(KeyedSeq);
    ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
    ToIndexedSequence = function(IndexedSeq2) {
      function ToIndexedSequence2(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      if (IndexedSeq2) ToIndexedSequence2.__proto__ = IndexedSeq2;
      ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
      ToIndexedSequence2.prototype.includes = function includes3(value) {
        return this._iter.includes(value);
      };
      ToIndexedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        var i = 0;
        reverse3 && ensureSize(this);
        return this._iter.__iterate(
          function(v) {
            return fn(v, reverse3 ? this$1$1.size - ++i : i++, this$1$1);
          },
          reverse3
        );
      };
      ToIndexedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var this$1$1 = this;
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        var i = 0;
        reverse3 && ensureSize(this);
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(
            type,
            reverse3 ? this$1$1.size - ++i : i++,
            step.value,
            step
          );
        });
      };
      return ToIndexedSequence2;
    }(IndexedSeq);
    ToSetSequence = function(SetSeq2) {
      function ToSetSequence2(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      if (SetSeq2) ToSetSequence2.__proto__ = SetSeq2;
      ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
      ToSetSequence2.prototype.constructor = ToSetSequence2;
      ToSetSequence2.prototype.has = function has5(key) {
        return this._iter.includes(key);
      };
      ToSetSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(v) {
          return fn(v, v, this$1$1);
        }, reverse3);
      };
      ToSetSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type, step.value, step.value, step);
        });
      };
      return ToSetSequence2;
    }(SetSeq);
    FromEntriesSequence = function(KeyedSeq2) {
      function FromEntriesSequence2(entries3) {
        this._iter = entries3;
        this.size = entries3.size;
      }
      if (KeyedSeq2) FromEntriesSequence2.__proto__ = KeyedSeq2;
      FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
      FromEntriesSequence2.prototype.entrySeq = function entrySeq2() {
        return this._iter.toSeq();
      };
      FromEntriesSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(entry) {
          if (entry) {
            validateEntry(entry);
            var indexedCollection = isCollection(entry);
            return fn(
              indexedCollection ? entry.get(1) : entry[1],
              indexedCollection ? entry.get(0) : entry[0],
              this$1$1
            );
          }
        }, reverse3);
      };
      FromEntriesSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        return new Iterator(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            if (entry) {
              validateEntry(entry);
              var indexedCollection = isCollection(entry);
              return iteratorValue(
                type,
                indexedCollection ? entry.get(0) : entry[0],
                indexedCollection ? entry.get(1) : entry[1],
                step
              );
            }
          }
        });
      };
      return FromEntriesSequence2;
    }(KeyedSeq);
    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
    toString2 = Object.prototype.toString;
    Map2 = function(KeyedCollection2) {
      function Map3(value) {
        return value === void 0 || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map2) {
          var iter = KeyedCollection2(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k) {
            return map2.set(k, v);
          });
        });
      }
      if (KeyedCollection2) Map3.__proto__ = KeyedCollection2;
      Map3.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
      Map3.prototype.constructor = Map3;
      Map3.prototype.toString = function toString5() {
        return this.__toString("Map {", "}");
      };
      Map3.prototype.get = function get11(k, notSetValue) {
        return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
      };
      Map3.prototype.set = function set3(k, v) {
        return updateMap(this, k, v);
      };
      Map3.prototype.remove = function remove3(k) {
        return updateMap(this, k, NOT_SET);
      };
      Map3.prototype.deleteAll = function deleteAll(keys2) {
        var collection = Collection(keys2);
        if (collection.size === 0) {
          return this;
        }
        return this.withMutations(function(map2) {
          collection.forEach(function(key) {
            return map2.remove(key);
          });
        });
      };
      Map3.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._root = null;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyMap();
      };
      Map3.prototype.sort = function sort2(comparator) {
        return OrderedMap(sortFactory(this, comparator));
      };
      Map3.prototype.sortBy = function sortBy2(mapper, comparator) {
        return OrderedMap(sortFactory(this, comparator, mapper));
      };
      Map3.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        return this.withMutations(function(map3) {
          map3.forEach(function(value, key) {
            map3.set(key, mapper.call(context, value, key, this$1$1));
          });
        });
      };
      Map3.prototype.__iterator = function __iterator2(type, reverse3) {
        return new MapIterator(this, type, reverse3);
      };
      Map3.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        var iterations = 0;
        this._root && this._root.iterate(function(entry) {
          iterations++;
          return fn(entry[1], entry[0], this$1$1);
        }, reverse3);
        return iterations;
      };
      Map3.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyMap();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeMap(this.size, this._root, ownerID, this.__hash);
      };
      return Map3;
    }(KeyedCollection);
    Map2.isMap = isMap;
    MapPrototype = Map2.prototype;
    MapPrototype[IS_MAP_SYMBOL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeAll = MapPrototype.deleteAll;
    MapPrototype.setIn = setIn;
    MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
    MapPrototype.update = update;
    MapPrototype.updateIn = updateIn;
    MapPrototype.merge = MapPrototype.concat = merge$1;
    MapPrototype.mergeWith = mergeWith$1;
    MapPrototype.mergeDeep = mergeDeep;
    MapPrototype.mergeDeepWith = mergeDeepWith;
    MapPrototype.mergeIn = mergeIn;
    MapPrototype.mergeDeepIn = mergeDeepIn;
    MapPrototype.withMutations = withMutations;
    MapPrototype.wasAltered = wasAltered;
    MapPrototype.asImmutable = asImmutable;
    MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
    MapPrototype["@@transducer/step"] = function(result, arr) {
      return result.set(arr[0], arr[1]);
    };
    MapPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    ArrayMapNode = function ArrayMapNode2(ownerID, entries3) {
      this.ownerID = ownerID;
      this.entries = entries3;
    };
    ArrayMapNode.prototype.get = function get2(shift, keyHash, key, notSetValue) {
      var entries3 = this.entries;
      for (var ii = 0, len = entries3.length; ii < len; ii++) {
        if (is(key, entries3[ii][0])) {
          return entries3[ii][1];
        }
      }
      return notSetValue;
    };
    ArrayMapNode.prototype.update = function update2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var entries3 = this.entries;
      var idx = 0;
      var len = entries3.length;
      for (; idx < len; idx++) {
        if (is(key, entries3[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries3[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && entries3.length === 1) {
        return;
      }
      if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries3, key, value);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries3 : arrCopy(entries3);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new ArrayMapNode(ownerID, newEntries);
    };
    BitmapIndexedNode = function BitmapIndexedNode2(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    };
    BitmapIndexedNode.prototype.get = function get3(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(
        shift + SHIFT,
        keyHash,
        key,
        notSetValue
      );
    };
    BitmapIndexedNode.prototype.update = function update3(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;
      if (!exists && value === NOT_SET) {
        return this;
      }
      var idx = popCount(bitmap & bit - 1);
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : void 0;
      var newNode = updateNode(
        node,
        ownerID,
        shift + SHIFT,
        keyHash,
        key,
        value,
        didChangeSize,
        didAlter
      );
      if (newNode === node) {
        return this;
      }
      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }
      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }
      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }
      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };
    HashArrayMapNode = function HashArrayMapNode2(ownerID, count2, nodes) {
      this.ownerID = ownerID;
      this.count = count2;
      this.nodes = nodes;
    };
    HashArrayMapNode.prototype.get = function get4(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode.prototype.update = function update4(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];
      if (removed && !node) {
        return this;
      }
      var newNode = updateNode(
        node,
        ownerID,
        shift + SHIFT,
        keyHash,
        key,
        value,
        didChangeSize,
        didAlter
      );
      if (newNode === node) {
        return this;
      }
      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setAt(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }
      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };
    HashCollisionNode = function HashCollisionNode2(ownerID, keyHash, entries3) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries3;
    };
    HashCollisionNode.prototype.get = function get5(shift, keyHash, key, notSetValue) {
      var entries3 = this.entries;
      for (var ii = 0, len = entries3.length; ii < len; ii++) {
        if (is(key, entries3[ii][0])) {
          return entries3[ii][1];
        }
      }
      return notSetValue;
    };
    HashCollisionNode.prototype.update = function update5(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var removed = value === NOT_SET;
      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }
      var entries3 = this.entries;
      var idx = 0;
      var len = entries3.length;
      for (; idx < len; idx++) {
        if (is(key, entries3[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries3[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries3[idx ^ 1]);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries3 : arrCopy(entries3);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };
    ValueNode = function ValueNode2(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    };
    ValueNode.prototype.get = function get6(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode.prototype.update = function update6(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }
      SetRef(didAlter);
      if (removed) {
        SetRef(didChangeSize);
        return;
      }
      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };
    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse3) {
      var entries3 = this.entries;
      for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };
    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse3) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse3 ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse3) === false) {
          return false;
        }
      }
    };
    ValueNode.prototype.iterate = function(fn, reverse3) {
      return fn(this.entry);
    };
    MapIterator = function(Iterator3) {
      function MapIterator2(map2, type, reverse3) {
        this._type = type;
        this._reverse = reverse3;
        this._stack = map2._root && mapIteratorFrame(map2._root);
      }
      if (Iterator3) MapIterator2.__proto__ = Iterator3;
      MapIterator2.prototype = Object.create(Iterator3 && Iterator3.prototype);
      MapIterator2.prototype.constructor = MapIterator2;
      MapIterator2.prototype.next = function next() {
        var type = this._type;
        var stack = this._stack;
        while (stack) {
          var node = stack.node;
          var index = stack.index++;
          var maxIndex = void 0;
          if (node.entry) {
            if (index === 0) {
              return mapIteratorValue(type, node.entry);
            }
          } else if (node.entries) {
            maxIndex = node.entries.length - 1;
            if (index <= maxIndex) {
              return mapIteratorValue(
                type,
                node.entries[this._reverse ? maxIndex - index : index]
              );
            }
          } else {
            maxIndex = node.nodes.length - 1;
            if (index <= maxIndex) {
              var subNode = node.nodes[this._reverse ? maxIndex - index : index];
              if (subNode) {
                if (subNode.entry) {
                  return mapIteratorValue(type, subNode.entry);
                }
                stack = this._stack = mapIteratorFrame(subNode, stack);
              }
              continue;
            }
          }
          stack = this._stack = this._stack.__prev;
        }
        return iteratorDone();
      };
      return MapIterator2;
    }(Iterator);
    MAX_ARRAY_MAP_SIZE = SIZE / 4;
    MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
    IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
    List = function(IndexedCollection2) {
      function List2(value) {
        var empty = emptyList();
        if (value === void 0 || value === null) {
          return empty;
        }
        if (isList(value)) {
          return value;
        }
        var iter = IndexedCollection2(value);
        var size = iter.size;
        if (size === 0) {
          return empty;
        }
        assertNotInfinite(size);
        if (size > 0 && size < SIZE) {
          return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
        }
        return empty.withMutations(function(list) {
          list.setSize(size);
          iter.forEach(function(v, i) {
            return list.set(i, v);
          });
        });
      }
      if (IndexedCollection2) List2.__proto__ = IndexedCollection2;
      List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
      List2.prototype.constructor = List2;
      List2.of = function of() {
        return this(arguments);
      };
      List2.prototype.toString = function toString5() {
        return this.__toString("List [", "]");
      };
      List2.prototype.get = function get11(index, notSetValue) {
        index = wrapIndex(this, index);
        if (index >= 0 && index < this.size) {
          index += this._origin;
          var node = listNodeFor(this, index);
          return node && node.array[index & MASK];
        }
        return notSetValue;
      };
      List2.prototype.set = function set3(index, value) {
        return updateList(this, index, value);
      };
      List2.prototype.remove = function remove3(index) {
        return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
      };
      List2.prototype.insert = function insert(index, value) {
        return this.splice(index, 0, value);
      };
      List2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = this._origin = this._capacity = 0;
          this._level = SHIFT;
          this._root = this._tail = this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyList();
      };
      List2.prototype.push = function push() {
        var values2 = arguments;
        var oldSize = this.size;
        return this.withMutations(function(list) {
          setListBounds(list, 0, oldSize + values2.length);
          for (var ii = 0; ii < values2.length; ii++) {
            list.set(oldSize + ii, values2[ii]);
          }
        });
      };
      List2.prototype.pop = function pop() {
        return setListBounds(this, 0, -1);
      };
      List2.prototype.unshift = function unshift() {
        var values2 = arguments;
        return this.withMutations(function(list) {
          setListBounds(list, -values2.length);
          for (var ii = 0; ii < values2.length; ii++) {
            list.set(ii, values2[ii]);
          }
        });
      };
      List2.prototype.shift = function shift() {
        return setListBounds(this, 1);
      };
      List2.prototype.concat = function concat2() {
        var arguments$1 = arguments;
        var seqs = [];
        for (var i = 0; i < arguments.length; i++) {
          var argument = arguments$1[i];
          var seq = IndexedCollection2(
            typeof argument !== "string" && hasIterator(argument) ? argument : [argument]
          );
          if (seq.size !== 0) {
            seqs.push(seq);
          }
        }
        if (seqs.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
          return this.constructor(seqs[0]);
        }
        return this.withMutations(function(list) {
          seqs.forEach(function(seq2) {
            return seq2.forEach(function(value) {
              return list.push(value);
            });
          });
        });
      };
      List2.prototype.setSize = function setSize(size) {
        return setListBounds(this, 0, size);
      };
      List2.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        return this.withMutations(function(list) {
          for (var i = 0; i < this$1$1.size; i++) {
            list.set(i, mapper.call(context, list.get(i), i, this$1$1));
          }
        });
      };
      List2.prototype.slice = function slice3(begin, end) {
        var size = this.size;
        if (wholeSlice(begin, end, size)) {
          return this;
        }
        return setListBounds(
          this,
          resolveBegin(begin, size),
          resolveEnd(end, size)
        );
      };
      List2.prototype.__iterator = function __iterator2(type, reverse3) {
        var index = reverse3 ? this.size : 0;
        var values2 = iterateList(this, reverse3);
        return new Iterator(function() {
          var value = values2();
          return value === DONE ? iteratorDone() : iteratorValue(type, reverse3 ? --index : index++, value);
        });
      };
      List2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var index = reverse3 ? this.size : 0;
        var values2 = iterateList(this, reverse3);
        var value;
        while ((value = values2()) !== DONE) {
          if (fn(value, reverse3 ? --index : index++, this) === false) {
            break;
          }
        }
        return index;
      };
      List2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyList();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeList(
          this._origin,
          this._capacity,
          this._level,
          this._root,
          this._tail,
          ownerID,
          this.__hash
        );
      };
      return List2;
    }(IndexedCollection);
    List.isList = isList;
    ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SYMBOL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.merge = ListPrototype.concat;
    ListPrototype.setIn = setIn;
    ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
    ListPrototype.update = update;
    ListPrototype.updateIn = updateIn;
    ListPrototype.mergeIn = mergeIn;
    ListPrototype.mergeDeepIn = mergeDeepIn;
    ListPrototype.withMutations = withMutations;
    ListPrototype.wasAltered = wasAltered;
    ListPrototype.asImmutable = asImmutable;
    ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
    ListPrototype["@@transducer/step"] = function(result, arr) {
      return result.push(arr);
    };
    ListPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    VNode = function VNode2(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    };
    VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
      if ((index & (1 << level + SHIFT) - 1) === 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = index >>> level & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = void 0;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };
    VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
      if (index === (level ? 1 << level + SHIFT : SIZE) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = index - 1 >>> level & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }
      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }
      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };
    DONE = {};
    OrderedMap = function(Map3) {
      function OrderedMap2(value) {
        return value === void 0 || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map2) {
          var iter = KeyedCollection(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k) {
            return map2.set(k, v);
          });
        });
      }
      if (Map3) OrderedMap2.__proto__ = Map3;
      OrderedMap2.prototype = Object.create(Map3 && Map3.prototype);
      OrderedMap2.prototype.constructor = OrderedMap2;
      OrderedMap2.of = function of() {
        return this(arguments);
      };
      OrderedMap2.prototype.toString = function toString5() {
        return this.__toString("OrderedMap {", "}");
      };
      OrderedMap2.prototype.get = function get11(k, notSetValue) {
        var index = this._map.get(k);
        return index !== void 0 ? this._list.get(index)[1] : notSetValue;
      };
      OrderedMap2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._map.clear();
          this._list.clear();
          this.__altered = true;
          return this;
        }
        return emptyOrderedMap();
      };
      OrderedMap2.prototype.set = function set3(k, v) {
        return updateOrderedMap(this, k, v);
      };
      OrderedMap2.prototype.remove = function remove3(k) {
        return updateOrderedMap(this, k, NOT_SET);
      };
      OrderedMap2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._list.__iterate(
          function(entry) {
            return entry && fn(entry[1], entry[0], this$1$1);
          },
          reverse3
        );
      };
      OrderedMap2.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._list.fromEntrySeq().__iterator(type, reverse3);
      };
      OrderedMap2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        var newList = this._list.__ensureOwner(ownerID);
        if (!ownerID) {
          if (this.size === 0) {
            return emptyOrderedMap();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          this._map = newMap;
          this._list = newList;
          return this;
        }
        return makeOrderedMap(newMap, newList, ownerID, this.__hash);
      };
      return OrderedMap2;
    }(Map2);
    OrderedMap.isOrderedMap = isOrderedMap;
    OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
    IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
    Stack = function(IndexedCollection2) {
      function Stack2(value) {
        return value === void 0 || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
      }
      if (IndexedCollection2) Stack2.__proto__ = IndexedCollection2;
      Stack2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
      Stack2.prototype.constructor = Stack2;
      Stack2.of = function of() {
        return this(arguments);
      };
      Stack2.prototype.toString = function toString5() {
        return this.__toString("Stack [", "]");
      };
      Stack2.prototype.get = function get11(index, notSetValue) {
        var head = this._head;
        index = wrapIndex(this, index);
        while (head && index--) {
          head = head.next;
        }
        return head ? head.value : notSetValue;
      };
      Stack2.prototype.peek = function peek() {
        return this._head && this._head.value;
      };
      Stack2.prototype.push = function push() {
        var arguments$1 = arguments;
        if (arguments.length === 0) {
          return this;
        }
        var newSize = this.size + arguments.length;
        var head = this._head;
        for (var ii = arguments.length - 1; ii >= 0; ii--) {
          head = {
            value: arguments$1[ii],
            next: head
          };
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.pushAll = function pushAll(iter) {
        iter = IndexedCollection2(iter);
        if (iter.size === 0) {
          return this;
        }
        if (this.size === 0 && isStack(iter)) {
          return iter;
        }
        assertNotInfinite(iter.size);
        var newSize = this.size;
        var head = this._head;
        iter.__iterate(
          function(value) {
            newSize++;
            head = {
              value,
              next: head
            };
          },
          /* reverse */
          true
        );
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.pop = function pop() {
        return this.slice(1);
      };
      Stack2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._head = void 0;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyStack();
      };
      Stack2.prototype.slice = function slice3(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        var resolvedBegin = resolveBegin(begin, this.size);
        var resolvedEnd = resolveEnd(end, this.size);
        if (resolvedEnd !== this.size) {
          return IndexedCollection2.prototype.slice.call(this, begin, end);
        }
        var newSize = this.size - resolvedBegin;
        var head = this._head;
        while (resolvedBegin--) {
          head = head.next;
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyStack();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeStack(this.size, this._head, ownerID, this.__hash);
      };
      Stack2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        if (reverse3) {
          return new ArraySeq(this.toArray()).__iterate(
            function(v, k) {
              return fn(v, k, this$1$1);
            },
            reverse3
          );
        }
        var iterations = 0;
        var node = this._head;
        while (node) {
          if (fn(node.value, iterations++, this) === false) {
            break;
          }
          node = node.next;
        }
        return iterations;
      };
      Stack2.prototype.__iterator = function __iterator2(type, reverse3) {
        if (reverse3) {
          return new ArraySeq(this.toArray()).__iterator(type, reverse3);
        }
        var iterations = 0;
        var node = this._head;
        return new Iterator(function() {
          if (node) {
            var value = node.value;
            node = node.next;
            return iteratorValue(type, iterations++, value);
          }
          return iteratorDone();
        });
      };
      return Stack2;
    }(IndexedCollection);
    Stack.isStack = isStack;
    StackPrototype = Stack.prototype;
    StackPrototype[IS_STACK_SYMBOL] = true;
    StackPrototype.shift = StackPrototype.pop;
    StackPrototype.unshift = StackPrototype.push;
    StackPrototype.unshiftAll = StackPrototype.pushAll;
    StackPrototype.withMutations = withMutations;
    StackPrototype.wasAltered = wasAltered;
    StackPrototype.asImmutable = asImmutable;
    StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
    StackPrototype["@@transducer/step"] = function(result, arr) {
      return result.unshift(arr);
    };
    StackPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
    Set2 = function(SetCollection2) {
      function Set3(value) {
        return value === void 0 || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set3) {
          var iter = SetCollection2(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v) {
            return set3.add(v);
          });
        });
      }
      if (SetCollection2) Set3.__proto__ = SetCollection2;
      Set3.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
      Set3.prototype.constructor = Set3;
      Set3.of = function of() {
        return this(arguments);
      };
      Set3.fromKeys = function fromKeys(value) {
        return this(KeyedCollection(value).keySeq());
      };
      Set3.intersect = function intersect(sets) {
        sets = Collection(sets).toArray();
        return sets.length ? SetPrototype.intersect.apply(Set3(sets.pop()), sets) : emptySet();
      };
      Set3.union = function union(sets) {
        sets = Collection(sets).toArray();
        return sets.length ? SetPrototype.union.apply(Set3(sets.pop()), sets) : emptySet();
      };
      Set3.prototype.toString = function toString5() {
        return this.__toString("Set {", "}");
      };
      Set3.prototype.has = function has5(value) {
        return this._map.has(value);
      };
      Set3.prototype.add = function add(value) {
        return updateSet(this, this._map.set(value, value));
      };
      Set3.prototype.remove = function remove3(value) {
        return updateSet(this, this._map.remove(value));
      };
      Set3.prototype.clear = function clear2() {
        return updateSet(this, this._map.clear());
      };
      Set3.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        var didChanges = false;
        var newMap = updateSet(
          this,
          this._map.mapEntries(function(ref) {
            var v = ref[1];
            var mapped = mapper.call(context, v, v, this$1$1);
            if (mapped !== v) {
              didChanges = true;
            }
            return [mapped, mapped];
          }, context)
        );
        return didChanges ? newMap : this;
      };
      Set3.prototype.union = function union() {
        var iters = [], len = arguments.length;
        while (len--) iters[len] = arguments[len];
        iters = iters.filter(function(x) {
          return x.size !== 0;
        });
        if (iters.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && iters.length === 1) {
          return this.constructor(iters[0]);
        }
        return this.withMutations(function(set3) {
          for (var ii = 0; ii < iters.length; ii++) {
            if (typeof iters[ii] === "string") {
              set3.add(iters[ii]);
            } else {
              SetCollection2(iters[ii]).forEach(function(value) {
                return set3.add(value);
              });
            }
          }
        });
      };
      Set3.prototype.intersect = function intersect() {
        var iters = [], len = arguments.length;
        while (len--) iters[len] = arguments[len];
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetCollection2(iter);
        });
        var toRemove = [];
        this.forEach(function(value) {
          if (!iters.every(function(iter) {
            return iter.includes(value);
          })) {
            toRemove.push(value);
          }
        });
        return this.withMutations(function(set3) {
          toRemove.forEach(function(value) {
            set3.remove(value);
          });
        });
      };
      Set3.prototype.subtract = function subtract() {
        var iters = [], len = arguments.length;
        while (len--) iters[len] = arguments[len];
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetCollection2(iter);
        });
        var toRemove = [];
        this.forEach(function(value) {
          if (iters.some(function(iter) {
            return iter.includes(value);
          })) {
            toRemove.push(value);
          }
        });
        return this.withMutations(function(set3) {
          toRemove.forEach(function(value) {
            set3.remove(value);
          });
        });
      };
      Set3.prototype.sort = function sort2(comparator) {
        return OrderedSet(sortFactory(this, comparator));
      };
      Set3.prototype.sortBy = function sortBy2(mapper, comparator) {
        return OrderedSet(sortFactory(this, comparator, mapper));
      };
      Set3.prototype.wasAltered = function wasAltered3() {
        return this._map.wasAltered();
      };
      Set3.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._map.__iterate(function(k) {
          return fn(k, k, this$1$1);
        }, reverse3);
      };
      Set3.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._map.__iterator(type, reverse3);
      };
      Set3.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          if (this.size === 0) {
            return this.__empty();
          }
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return this.__make(newMap, ownerID);
      };
      return Set3;
    }(SetCollection);
    Set2.isSet = isSet;
    SetPrototype = Set2.prototype;
    SetPrototype[IS_SET_SYMBOL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
    SetPrototype.withMutations = withMutations;
    SetPrototype.asImmutable = asImmutable;
    SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
    SetPrototype["@@transducer/step"] = function(result, arr) {
      return result.add(arr);
    };
    SetPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;
    Range = function(IndexedSeq2) {
      function Range2(start, end, step) {
        if (step === void 0) step = 1;
        if (!(this instanceof Range2)) {
          return new Range2(start, end, step);
        }
        invariant(step !== 0, "Cannot step a Range by 0");
        invariant(
          start !== void 0,
          "You must define a start value when using Range"
        );
        invariant(
          end !== void 0,
          "You must define an end value when using Range"
        );
        step = Math.abs(step);
        if (end < start) {
          step = -step;
        }
        this._start = start;
        this._end = end;
        this._step = step;
        this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
        if (this.size === 0) {
          if (EMPTY_RANGE) {
            return EMPTY_RANGE;
          }
          EMPTY_RANGE = this;
        }
      }
      if (IndexedSeq2) Range2.__proto__ = IndexedSeq2;
      Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      Range2.prototype.constructor = Range2;
      Range2.prototype.toString = function toString5() {
        if (this.size === 0) {
          return "Range []";
        }
        return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
      };
      Range2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
      };
      Range2.prototype.includes = function includes3(searchValue) {
        var possibleIndex = (searchValue - this._start) / this._step;
        return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
      };
      Range2.prototype.slice = function slice3(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        begin = resolveBegin(begin, this.size);
        end = resolveEnd(end, this.size);
        if (end <= begin) {
          return new Range2(0, 0);
        }
        return new Range2(
          this.get(begin, this._end),
          this.get(end, this._end),
          this._step
        );
      };
      Range2.prototype.indexOf = function indexOf2(searchValue) {
        var offsetValue = searchValue - this._start;
        if (offsetValue % this._step === 0) {
          var index = offsetValue / this._step;
          if (index >= 0 && index < this.size) {
            return index;
          }
        }
        return -1;
      };
      Range2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
        return this.indexOf(searchValue);
      };
      Range2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var size = this.size;
        var step = this._step;
        var value = reverse3 ? this._start + (size - 1) * step : this._start;
        var i = 0;
        while (i !== size) {
          if (fn(value, reverse3 ? size - ++i : i++, this) === false) {
            break;
          }
          value += reverse3 ? -step : step;
        }
        return i;
      };
      Range2.prototype.__iterator = function __iterator2(type, reverse3) {
        var size = this.size;
        var step = this._step;
        var value = reverse3 ? this._start + (size - 1) * step : this._start;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var v = value;
          value += reverse3 ? -step : step;
          return iteratorValue(type, reverse3 ? size - ++i : i++, v);
        });
      };
      Range2.prototype.equals = function equals3(other) {
        return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
      };
      return Range2;
    }(IndexedSeq);
    Collection.Iterator = Iterator;
    mixin(Collection, {
      // ### Conversion to other types
      toArray: function toArray() {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        var useTuples = isKeyed(this);
        var i = 0;
        this.__iterate(function(v, k) {
          array[i++] = useTuples ? [k, v] : v;
        });
        return array;
      },
      toIndexedSeq: function toIndexedSeq() {
        return new ToIndexedSequence(this);
      },
      toJS: function toJS$1() {
        return toJS(this);
      },
      toKeyedSeq: function toKeyedSeq() {
        return new ToKeyedSequence(this, true);
      },
      toMap: function toMap() {
        return Map2(this.toKeyedSeq());
      },
      toObject,
      toOrderedMap: function toOrderedMap() {
        return OrderedMap(this.toKeyedSeq());
      },
      toOrderedSet: function toOrderedSet() {
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
      },
      toSet: function toSet() {
        return Set2(isKeyed(this) ? this.valueSeq() : this);
      },
      toSetSeq: function toSetSeq() {
        return new ToSetSequence(this);
      },
      toSeq: function toSeq() {
        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
      },
      toStack: function toStack() {
        return Stack(isKeyed(this) ? this.valueSeq() : this);
      },
      toList: function toList() {
        return List(isKeyed(this) ? this.valueSeq() : this);
      },
      // ### Common JavaScript methods and properties
      toString: function toString3() {
        return "[Collection]";
      },
      __toString: function __toString(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
      },
      // ### ES6 Collection methods (ES6 Array and Map)
      concat: function concat() {
        var values2 = [], len = arguments.length;
        while (len--) values2[len] = arguments[len];
        return reify(this, concatFactory(this, values2));
      },
      includes: function includes(searchValue) {
        return this.some(function(value) {
          return is(value, searchValue);
        });
      },
      entries: function entries() {
        return this.__iterator(ITERATE_ENTRIES);
      },
      every: function every(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function(v, k, c) {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },
      filter: function filter(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, true));
      },
      partition: function partition(predicate, context) {
        return partitionFactory(this, predicate, context);
      },
      find: function find(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },
      forEach: function forEach(sideEffect, context) {
        assertNotInfinite(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },
      join: function join(separator) {
        assertNotInfinite(this.size);
        separator = separator !== void 0 ? "" + separator : ",";
        var joined = "";
        var isFirst = true;
        this.__iterate(function(v) {
          isFirst ? isFirst = false : joined += separator;
          joined += v !== null && v !== void 0 ? v.toString() : "";
        });
        return joined;
      },
      keys: function keys() {
        return this.__iterator(ITERATE_KEYS);
      },
      map: function map(mapper, context) {
        return reify(this, mapFactory(this, mapper, context));
      },
      reduce: function reduce$1(reducer, initialReduction, context) {
        return reduce(
          this,
          reducer,
          initialReduction,
          context,
          arguments.length < 2,
          false
        );
      },
      reduceRight: function reduceRight(reducer, initialReduction, context) {
        return reduce(
          this,
          reducer,
          initialReduction,
          context,
          arguments.length < 2,
          true
        );
      },
      reverse: function reverse() {
        return reify(this, reverseFactory(this, true));
      },
      slice: function slice(begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
      },
      some: function some(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = false;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            returnValue = true;
            return false;
          }
        });
        return returnValue;
      },
      sort: function sort(comparator) {
        return reify(this, sortFactory(this, comparator));
      },
      values: function values() {
        return this.__iterator(ITERATE_VALUES);
      },
      // ### More sequential methods
      butLast: function butLast() {
        return this.slice(0, -1);
      },
      isEmpty: function isEmpty() {
        return this.size !== void 0 ? this.size === 0 : !this.some(function() {
          return true;
        });
      },
      count: function count(predicate, context) {
        return ensureSize(
          predicate ? this.toSeq().filter(predicate, context) : this
        );
      },
      countBy: function countBy(grouper, context) {
        return countByFactory(this, grouper, context);
      },
      equals: function equals(other) {
        return deepEqual(this, other);
      },
      entrySeq: function entrySeq() {
        var collection = this;
        if (collection._cache) {
          return new ArraySeq(collection._cache);
        }
        var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
        entriesSequence.fromEntrySeq = function() {
          return collection.toSeq();
        };
        return entriesSequence;
      },
      filterNot: function filterNot(predicate, context) {
        return this.filter(not(predicate), context);
      },
      findEntry: function findEntry(predicate, context, notSetValue) {
        var found = notSetValue;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },
      findKey: function findKey(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },
      findLast: function findLast(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },
      findLastEntry: function findLastEntry(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
      },
      findLastKey: function findLastKey(predicate, context) {
        return this.toKeyedSeq().reverse().findKey(predicate, context);
      },
      first: function first(notSetValue) {
        return this.find(returnTrue, null, notSetValue);
      },
      flatMap: function flatMap(mapper, context) {
        return reify(this, flatMapFactory(this, mapper, context));
      },
      flatten: function flatten(depth) {
        return reify(this, flattenFactory(this, depth, true));
      },
      fromEntrySeq: function fromEntrySeq() {
        return new FromEntriesSequence(this);
      },
      get: function get7(searchKey, notSetValue) {
        return this.find(function(_, key) {
          return is(key, searchKey);
        }, void 0, notSetValue);
      },
      getIn,
      groupBy: function groupBy(grouper, context) {
        return groupByFactory(this, grouper, context);
      },
      has: function has2(searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
      },
      hasIn,
      isSubset: function isSubset(iter) {
        iter = typeof iter.includes === "function" ? iter : Collection(iter);
        return this.every(function(value) {
          return iter.includes(value);
        });
      },
      isSuperset: function isSuperset(iter) {
        iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
        return iter.isSubset(this);
      },
      keyOf: function keyOf(searchValue) {
        return this.findKey(function(value) {
          return is(value, searchValue);
        });
      },
      keySeq: function keySeq() {
        return this.toSeq().map(keyMapper).toIndexedSeq();
      },
      last: function last(notSetValue) {
        return this.toSeq().reverse().first(notSetValue);
      },
      lastKeyOf: function lastKeyOf(searchValue) {
        return this.toKeyedSeq().reverse().keyOf(searchValue);
      },
      max: function max(comparator) {
        return maxFactory(this, comparator);
      },
      maxBy: function maxBy(mapper, comparator) {
        return maxFactory(this, comparator, mapper);
      },
      min: function min(comparator) {
        return maxFactory(
          this,
          comparator ? neg(comparator) : defaultNegComparator
        );
      },
      minBy: function minBy(mapper, comparator) {
        return maxFactory(
          this,
          comparator ? neg(comparator) : defaultNegComparator,
          mapper
        );
      },
      rest: function rest() {
        return this.slice(1);
      },
      skip: function skip(amount) {
        return amount === 0 ? this : this.slice(Math.max(0, amount));
      },
      skipLast: function skipLast(amount) {
        return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
      },
      skipWhile: function skipWhile(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, true));
      },
      skipUntil: function skipUntil(predicate, context) {
        return this.skipWhile(not(predicate), context);
      },
      sortBy: function sortBy(mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
      },
      take: function take(amount) {
        return this.slice(0, Math.max(0, amount));
      },
      takeLast: function takeLast(amount) {
        return this.slice(-Math.max(0, amount));
      },
      takeWhile: function takeWhile(predicate, context) {
        return reify(this, takeWhileFactory(this, predicate, context));
      },
      takeUntil: function takeUntil(predicate, context) {
        return this.takeWhile(not(predicate), context);
      },
      update: function update7(fn) {
        return fn(this);
      },
      valueSeq: function valueSeq() {
        return this.toIndexedSeq();
      },
      // ### Hashable Object
      hashCode: function hashCode() {
        return this.__hash || (this.__hash = hashCollection(this));
      }
      // ### Internal
      // abstract __iterate(fn, reverse)
      // abstract __iterator(type, reverse)
    });
    CollectionPrototype = Collection.prototype;
    CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
    CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
    CollectionPrototype.toJSON = CollectionPrototype.toArray;
    CollectionPrototype.__toStringMapper = quoteString;
    CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
      return this.toString();
    };
    CollectionPrototype.chain = CollectionPrototype.flatMap;
    CollectionPrototype.contains = CollectionPrototype.includes;
    mixin(KeyedCollection, {
      // ### More sequential methods
      flip: function flip() {
        return reify(this, flipFactory(this));
      },
      mapEntries: function mapEntries(mapper, context) {
        var this$1$1 = this;
        var iterations = 0;
        return reify(
          this,
          this.toSeq().map(function(v, k) {
            return mapper.call(context, [k, v], iterations++, this$1$1);
          }).fromEntrySeq()
        );
      },
      mapKeys: function mapKeys(mapper, context) {
        var this$1$1 = this;
        return reify(
          this,
          this.toSeq().flip().map(function(k, v) {
            return mapper.call(context, k, v, this$1$1);
          }).flip()
        );
      }
    });
    KeyedCollectionPrototype = KeyedCollection.prototype;
    KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
    KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
    KeyedCollectionPrototype.toJSON = toObject;
    KeyedCollectionPrototype.__toStringMapper = function(v, k) {
      return quoteString(k) + ": " + quoteString(v);
    };
    mixin(IndexedCollection, {
      // ### Conversion to other types
      toKeyedSeq: function toKeyedSeq2() {
        return new ToKeyedSequence(this, false);
      },
      // ### ES6 Collection methods (ES6 Array and Map)
      filter: function filter2(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, false));
      },
      findIndex: function findIndex(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      indexOf: function indexOf(searchValue) {
        var key = this.keyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      lastIndexOf: function lastIndexOf(searchValue) {
        var key = this.lastKeyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      reverse: function reverse2() {
        return reify(this, reverseFactory(this, false));
      },
      slice: function slice2(begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
      },
      splice: function splice(index, removeNum) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum || 0, 0);
        if (numArgs === 0 || numArgs === 2 && !removeNum) {
          return this;
        }
        index = resolveBegin(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify(
          this,
          numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
        );
      },
      // ### More collection methods
      findLastIndex: function findLastIndex(predicate, context) {
        var entry = this.findLastEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      first: function first2(notSetValue) {
        return this.get(0, notSetValue);
      },
      flatten: function flatten2(depth) {
        return reify(this, flattenFactory(this, depth, false));
      },
      get: function get8(index, notSetValue) {
        index = wrapIndex(this, index);
        return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_, key) {
          return key === index;
        }, void 0, notSetValue);
      },
      has: function has3(index) {
        index = wrapIndex(this, index);
        return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
      },
      interpose: function interpose(separator) {
        return reify(this, interposeFactory(this, separator));
      },
      interleave: function interleave() {
        var collections = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * collections.length;
        }
        return reify(this, interleaved);
      },
      keySeq: function keySeq2() {
        return Range(0, this.size);
      },
      last: function last2(notSetValue) {
        return this.get(-1, notSetValue);
      },
      skipWhile: function skipWhile2(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, false));
      },
      zip: function zip() {
        var collections = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, collections));
      },
      zipAll: function zipAll() {
        var collections = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, collections, true));
      },
      zipWith: function zipWith(zipper) {
        var collections = arrCopy(arguments);
        collections[0] = this;
        return reify(this, zipWithFactory(this, zipper, collections));
      }
    });
    IndexedCollectionPrototype = IndexedCollection.prototype;
    IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
    IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
    mixin(SetCollection, {
      // ### ES6 Collection methods (ES6 Array and Map)
      get: function get9(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },
      includes: function includes2(value) {
        return this.has(value);
      },
      // ### More sequential methods
      keySeq: function keySeq3() {
        return this.valueSeq();
      }
    });
    SetCollectionPrototype = SetCollection.prototype;
    SetCollectionPrototype.has = CollectionPrototype.includes;
    SetCollectionPrototype.contains = SetCollectionPrototype.includes;
    SetCollectionPrototype.keys = SetCollectionPrototype.values;
    mixin(KeyedSeq, KeyedCollectionPrototype);
    mixin(IndexedSeq, IndexedCollectionPrototype);
    mixin(SetSeq, SetCollectionPrototype);
    OrderedSet = function(Set3) {
      function OrderedSet2(value) {
        return value === void 0 || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set3) {
          var iter = SetCollection(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v) {
            return set3.add(v);
          });
        });
      }
      if (Set3) OrderedSet2.__proto__ = Set3;
      OrderedSet2.prototype = Object.create(Set3 && Set3.prototype);
      OrderedSet2.prototype.constructor = OrderedSet2;
      OrderedSet2.of = function of() {
        return this(arguments);
      };
      OrderedSet2.fromKeys = function fromKeys(value) {
        return this(KeyedCollection(value).keySeq());
      };
      OrderedSet2.prototype.toString = function toString5() {
        return this.__toString("OrderedSet {", "}");
      };
      return OrderedSet2;
    }(Set2);
    OrderedSet.isOrderedSet = isOrderedSet;
    OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
    OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
    OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
    OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;
    PairSorting = {
      LeftThenRight: -1,
      RightThenLeft: 1
    };
    Record = function Record2(defaultValues, name) {
      var hasInitialized;
      throwOnInvalidDefaultValues(defaultValues);
      var RecordType = function Record3(values2) {
        var this$1$1 = this;
        if (values2 instanceof RecordType) {
          return values2;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values2);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys2 = Object.keys(defaultValues);
          var indices = RecordTypePrototype._indices = {};
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys2;
          RecordTypePrototype._defaultValues = defaultValues;
          for (var i = 0; i < keys2.length; i++) {
            var propName = keys2[i];
            indices[propName] = i;
            if (RecordTypePrototype[propName]) {
              typeof console === "object" && console.warn && console.warn(
                "Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.'
              );
            } else {
              setProp(RecordTypePrototype, propName);
            }
          }
        }
        this.__ownerID = void 0;
        this._values = List().withMutations(function(l) {
          l.setSize(this$1$1._keys.length);
          KeyedCollection(values2).forEach(function(v, k) {
            l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? void 0 : v);
          });
        });
        return this;
      };
      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;
      if (name) {
        RecordType.displayName = name;
      }
      return RecordType;
    };
    Record.prototype.toString = function toString4() {
      var str = recordName(this) + " { ";
      var keys2 = this._keys;
      var k;
      for (var i = 0, l = keys2.length; i !== l; i++) {
        k = keys2[i];
        str += (i ? ", " : "") + k + ": " + quoteString(this.get(k));
      }
      return str + " }";
    };
    Record.prototype.equals = function equals2(other) {
      return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
    };
    Record.prototype.hashCode = function hashCode2() {
      return recordSeq(this).hashCode();
    };
    Record.prototype.has = function has4(k) {
      return this._indices.hasOwnProperty(k);
    };
    Record.prototype.get = function get10(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var index = this._indices[k];
      var value = this._values.get(index);
      return value === void 0 ? this._defaultValues[k] : value;
    };
    Record.prototype.set = function set2(k, v) {
      if (this.has(k)) {
        var newValues = this._values.set(
          this._indices[k],
          v === this._defaultValues[k] ? void 0 : v
        );
        if (newValues !== this._values && !this.__ownerID) {
          return makeRecord(this, newValues);
        }
      }
      return this;
    };
    Record.prototype.remove = function remove2(k) {
      return this.set(k);
    };
    Record.prototype.clear = function clear() {
      var newValues = this._values.clear().setSize(this._keys.length);
      return this.__ownerID ? this : makeRecord(this, newValues);
    };
    Record.prototype.wasAltered = function wasAltered2() {
      return this._values.wasAltered();
    };
    Record.prototype.toSeq = function toSeq2() {
      return recordSeq(this);
    };
    Record.prototype.toJS = function toJS$12() {
      return toJS(this);
    };
    Record.prototype.entries = function entries2() {
      return this.__iterator(ITERATE_ENTRIES);
    };
    Record.prototype.__iterator = function __iterator(type, reverse3) {
      return recordSeq(this).__iterator(type, reverse3);
    };
    Record.prototype.__iterate = function __iterate(fn, reverse3) {
      return recordSeq(this).__iterate(fn, reverse3);
    };
    Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newValues = this._values.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._values = newValues;
        return this;
      }
      return makeRecord(this, newValues, ownerID);
    };
    Record.isRecord = isRecord;
    Record.getDescriptiveName = recordName;
    RecordPrototype = Record.prototype;
    RecordPrototype[IS_RECORD_SYMBOL] = true;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
    RecordPrototype.getIn = getIn;
    RecordPrototype.hasIn = CollectionPrototype.hasIn;
    RecordPrototype.merge = merge$1;
    RecordPrototype.mergeWith = mergeWith$1;
    RecordPrototype.mergeIn = mergeIn;
    RecordPrototype.mergeDeep = mergeDeep;
    RecordPrototype.mergeDeepWith = mergeDeepWith;
    RecordPrototype.mergeDeepIn = mergeDeepIn;
    RecordPrototype.setIn = setIn;
    RecordPrototype.update = update;
    RecordPrototype.updateIn = updateIn;
    RecordPrototype.withMutations = withMutations;
    RecordPrototype.asMutable = asMutable;
    RecordPrototype.asImmutable = asImmutable;
    RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
    RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
    RecordPrototype.inspect = RecordPrototype.toSource = function() {
      return this.toString();
    };
    Repeat = function(IndexedSeq2) {
      function Repeat2(value, times) {
        if (!(this instanceof Repeat2)) {
          return new Repeat2(value, times);
        }
        this._value = value;
        this.size = times === void 0 ? Infinity : Math.max(0, times);
        if (this.size === 0) {
          if (EMPTY_REPEAT) {
            return EMPTY_REPEAT;
          }
          EMPTY_REPEAT = this;
        }
      }
      if (IndexedSeq2) Repeat2.__proto__ = IndexedSeq2;
      Repeat2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      Repeat2.prototype.constructor = Repeat2;
      Repeat2.prototype.toString = function toString5() {
        if (this.size === 0) {
          return "Repeat []";
        }
        return "Repeat [ " + this._value + " " + this.size + " times ]";
      };
      Repeat2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._value : notSetValue;
      };
      Repeat2.prototype.includes = function includes3(searchValue) {
        return is(this._value, searchValue);
      };
      Repeat2.prototype.slice = function slice3(begin, end) {
        var size = this.size;
        return wholeSlice(begin, end, size) ? this : new Repeat2(
          this._value,
          resolveEnd(end, size) - resolveBegin(begin, size)
        );
      };
      Repeat2.prototype.reverse = function reverse3() {
        return this;
      };
      Repeat2.prototype.indexOf = function indexOf2(searchValue) {
        if (is(this._value, searchValue)) {
          return 0;
        }
        return -1;
      };
      Repeat2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
        if (is(this._value, searchValue)) {
          return this.size;
        }
        return -1;
      };
      Repeat2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var size = this.size;
        var i = 0;
        while (i !== size) {
          if (fn(this._value, reverse3 ? size - ++i : i++, this) === false) {
            break;
          }
        }
        return i;
      };
      Repeat2.prototype.__iterator = function __iterator2(type, reverse3) {
        var this$1$1 = this;
        var size = this.size;
        var i = 0;
        return new Iterator(
          function() {
            return i === size ? iteratorDone() : iteratorValue(type, reverse3 ? size - ++i : i++, this$1$1._value);
          }
        );
      };
      Repeat2.prototype.equals = function equals3(other) {
        return other instanceof Repeat2 ? is(this._value, other._value) : deepEqual(this, other);
      };
      return Repeat2;
    }(IndexedSeq);
    version = "5.0.3";
    Iterable = Collection;
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/names.js
var require_names = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.protoCamelCase = protoCamelCase;
    exports.safeObjectProperty = safeObjectProperty;
    function protoCamelCase(snakeCase) {
      let capNext = false;
      const b = [];
      for (let i = 0; i < snakeCase.length; i++) {
        let c = snakeCase.charAt(i);
        switch (c) {
          case "_":
            capNext = true;
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            b.push(c);
            capNext = false;
            break;
          default:
            if (capNext) {
              capNext = false;
              c = c.toUpperCase();
            }
            b.push(c);
            break;
        }
      }
      return b.join("");
    }
    var reservedObjectProperties = /* @__PURE__ */ new Set([
      // names reserved by JavaScript
      "constructor",
      "toString",
      "toJSON",
      "valueOf"
    ]);
    function safeObjectProperty(name) {
      return reservedObjectProperties.has(name) ? name + "$" : name;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/varint.js
var require_varint = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/varint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.varint64read = varint64read;
    exports.varint64write = varint64write;
    exports.int64FromString = int64FromString;
    exports.int64ToString = int64ToString;
    exports.uInt64ToString = uInt64ToString;
    exports.varint32write = varint32write;
    exports.varint32read = varint32read;
    function varint64read() {
      let lowBits = 0;
      let highBits = 0;
      for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      let middleByte = this.buf[this.pos++];
      lowBits |= (middleByte & 15) << 28;
      highBits = (middleByte & 112) >> 4;
      if ((middleByte & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
      for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      throw new Error("invalid varint");
    }
    function varint64write(lo, hi, bytes) {
      for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
      const hasMoreBits = !(hi >> 3 == 0);
      bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
      if (!hasMoreBits) {
        return;
      }
      for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      bytes.push(hi >>> 31 & 1);
    }
    var TWO_PWR_32_DBL = 4294967296;
    function int64FromString(dec) {
      const minus = dec[0] === "-";
      if (minus) {
        dec = dec.slice(1);
      }
      const base = 1e6;
      let lowBits = 0;
      let highBits = 0;
      function add1e6digit(begin, end) {
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        if (lowBits >= TWO_PWR_32_DBL) {
          highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
          lowBits = lowBits % TWO_PWR_32_DBL;
        }
      }
      add1e6digit(-24, -18);
      add1e6digit(-18, -12);
      add1e6digit(-12, -6);
      add1e6digit(-6);
      return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
    }
    function int64ToString(lo, hi) {
      let bits = newBits(lo, hi);
      const negative = bits.hi & 2147483648;
      if (negative) {
        bits = negate(bits.lo, bits.hi);
      }
      const result = uInt64ToString(bits.lo, bits.hi);
      return negative ? "-" + result : result;
    }
    function uInt64ToString(lo, hi) {
      ({ lo, hi } = toUnsigned(lo, hi));
      if (hi <= 2097151) {
        return String(TWO_PWR_32_DBL * hi + lo);
      }
      const low = lo & 16777215;
      const mid = (lo >>> 24 | hi << 8) & 16777215;
      const high = hi >> 16 & 65535;
      let digitA = low + mid * 6777216 + high * 6710656;
      let digitB = mid + high * 8147497;
      let digitC = high * 2;
      const base = 1e7;
      if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
      }
      if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
      }
      return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
    }
    function toUnsigned(lo, hi) {
      return { lo: lo >>> 0, hi: hi >>> 0 };
    }
    function newBits(lo, hi) {
      return { lo: lo | 0, hi: hi | 0 };
    }
    function negate(lowBits, highBits) {
      highBits = ~highBits;
      if (lowBits) {
        lowBits = ~lowBits + 1;
      } else {
        highBits += 1;
      }
      return newBits(lowBits, highBits);
    }
    var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
      const partial = String(digit1e7);
      return "0000000".slice(partial.length) + partial;
    };
    function varint32write(value, bytes) {
      if (value >= 0) {
        while (value > 127) {
          bytes.push(value & 127 | 128);
          value = value >>> 7;
        }
        bytes.push(value);
      } else {
        for (let i = 0; i < 9; i++) {
          bytes.push(value & 127 | 128);
          value = value >> 7;
        }
        bytes.push(1);
      }
    }
    function varint32read() {
      let b = this.buf[this.pos++];
      let result = b & 127;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 7;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 14;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 21;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 15) << 28;
      for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
      if ((b & 128) != 0)
        throw new Error("invalid varint");
      this.assertBounds();
      return result >>> 0;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/proto-int64.js
var require_proto_int64 = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/proto-int64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.protoInt64 = void 0;
    var varint_js_1 = require_varint();
    exports.protoInt64 = makeInt64Support();
    function makeInt64Support() {
      const dv = new DataView(new ArrayBuffer(8));
      const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
      if (ok) {
        const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
        return {
          zero: BigInt(0),
          supported: true,
          parse(value) {
            const bi = typeof value == "bigint" ? value : BigInt(value);
            if (bi > MAX || bi < MIN) {
              throw new Error(`invalid int64: ${value}`);
            }
            return bi;
          },
          uParse(value) {
            const bi = typeof value == "bigint" ? value : BigInt(value);
            if (bi > UMAX || bi < UMIN) {
              throw new Error(`invalid uint64: ${value}`);
            }
            return bi;
          },
          enc(value) {
            dv.setBigInt64(0, this.parse(value), true);
            return {
              lo: dv.getInt32(0, true),
              hi: dv.getInt32(4, true)
            };
          },
          uEnc(value) {
            dv.setBigInt64(0, this.uParse(value), true);
            return {
              lo: dv.getInt32(0, true),
              hi: dv.getInt32(4, true)
            };
          },
          dec(lo, hi) {
            dv.setInt32(0, lo, true);
            dv.setInt32(4, hi, true);
            return dv.getBigInt64(0, true);
          },
          uDec(lo, hi) {
            dv.setInt32(0, lo, true);
            dv.setInt32(4, hi, true);
            return dv.getBigUint64(0, true);
          }
        };
      }
      return {
        zero: "0",
        supported: false,
        parse(value) {
          if (typeof value != "string") {
            value = value.toString();
          }
          assertInt64String(value);
          return value;
        },
        uParse(value) {
          if (typeof value != "string") {
            value = value.toString();
          }
          assertUInt64String(value);
          return value;
        },
        enc(value) {
          if (typeof value != "string") {
            value = value.toString();
          }
          assertInt64String(value);
          return (0, varint_js_1.int64FromString)(value);
        },
        uEnc(value) {
          if (typeof value != "string") {
            value = value.toString();
          }
          assertUInt64String(value);
          return (0, varint_js_1.int64FromString)(value);
        },
        dec(lo, hi) {
          return (0, varint_js_1.int64ToString)(lo, hi);
        },
        uDec(lo, hi) {
          return (0, varint_js_1.uInt64ToString)(lo, hi);
        }
      };
    }
    function assertInt64String(value) {
      if (!/^-?[0-9]+$/.test(value)) {
        throw new Error("invalid int64: " + value);
      }
    }
    function assertUInt64String(value) {
      if (!/^[0-9]+$/.test(value)) {
        throw new Error("invalid uint64: " + value);
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/descriptors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScalarType = void 0;
    var ScalarType;
    (function(ScalarType2) {
      ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
      ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
      ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
      ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
      ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
      ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
      ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
      ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
      ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
      ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
      ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
      ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
      ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
      ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
      ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
    })(ScalarType || (exports.ScalarType = ScalarType = {}));
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/scalar.js
var require_scalar = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/scalar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scalarEquals = scalarEquals;
    exports.scalarZeroValue = scalarZeroValue;
    exports.isScalarZeroValue = isScalarZeroValue;
    var proto_int64_js_1 = require_proto_int64();
    var descriptors_js_1 = require_descriptors();
    function scalarEquals(type, a, b) {
      if (a === b) {
        return true;
      }
      if (type == descriptors_js_1.ScalarType.BYTES) {
        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      switch (type) {
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          return a == b;
      }
      return false;
    }
    function scalarZeroValue(type, longAsString) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          return "";
        case descriptors_js_1.ScalarType.BOOL:
          return false;
        default:
          return 0;
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FLOAT:
          return 0;
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          return longAsString ? "0" : proto_int64_js_1.protoInt64.zero;
        case descriptors_js_1.ScalarType.BYTES:
          return new Uint8Array(0);
      }
    }
    function isScalarZeroValue(type, value) {
      switch (type) {
        case descriptors_js_1.ScalarType.BOOL:
          return value === false;
        case descriptors_js_1.ScalarType.STRING:
          return value === "";
        case descriptors_js_1.ScalarType.BYTES:
          return value instanceof Uint8Array && !value.byteLength;
        default:
          return value == 0;
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/unsafe.js
var require_unsafe = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/unsafe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unsafeLocal = void 0;
    exports.unsafeOneofCase = unsafeOneofCase;
    exports.unsafeIsSet = unsafeIsSet;
    exports.unsafeIsSetExplicit = unsafeIsSetExplicit;
    exports.unsafeGet = unsafeGet;
    exports.unsafeSet = unsafeSet;
    exports.unsafeClear = unsafeClear;
    var scalar_js_1 = require_scalar();
    var IMPLICIT = 2;
    exports.unsafeLocal = Symbol.for("reflect unsafe local");
    function unsafeOneofCase(target, oneof) {
      const c = target[oneof.localName].case;
      if (c === void 0) {
        return c;
      }
      return oneof.fields.find((f) => f.localName === c);
    }
    function unsafeIsSet(target, field) {
      const name = field.localName;
      if (field.oneof) {
        return target[field.oneof.localName].case === name;
      }
      if (field.presence != IMPLICIT) {
        return target[name] !== void 0 && Object.prototype.hasOwnProperty.call(target, name);
      }
      switch (field.fieldKind) {
        case "list":
          return target[name].length > 0;
        case "map":
          return Object.keys(target[name]).length > 0;
        // eslint-disable-line @typescript-eslint/no-unsafe-argument
        case "scalar":
          return !(0, scalar_js_1.isScalarZeroValue)(field.scalar, target[name]);
        case "enum":
          return target[name] !== field.enum.values[0].number;
      }
      throw new Error("message field with implicit presence");
    }
    function unsafeIsSetExplicit(target, localName) {
      return Object.prototype.hasOwnProperty.call(target, localName) && target[localName] !== void 0;
    }
    function unsafeGet(target, field) {
      if (field.oneof) {
        const oneof = target[field.oneof.localName];
        if (oneof.case === field.localName) {
          return oneof.value;
        }
        return void 0;
      }
      return target[field.localName];
    }
    function unsafeSet(target, field, value) {
      if (field.oneof) {
        target[field.oneof.localName] = {
          case: field.localName,
          value
        };
      } else {
        target[field.localName] = value;
      }
    }
    function unsafeClear(target, field) {
      const name = field.localName;
      if (field.oneof) {
        const oneofLocalName = field.oneof.localName;
        if (target[oneofLocalName].case === name) {
          target[oneofLocalName] = { case: void 0 };
        }
      } else if (field.presence != IMPLICIT) {
        delete target[name];
      } else {
        switch (field.fieldKind) {
          case "map":
            target[name] = {};
            break;
          case "list":
            target[name] = [];
            break;
          case "enum":
            target[name] = field.enum.values[0].number;
            break;
          case "scalar":
            target[name] = (0, scalar_js_1.scalarZeroValue)(field.scalar, field.longAsString);
            break;
        }
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/restore-json-names.js
var require_restore_json_names = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/restore-json-names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.restoreJsonNames = restoreJsonNames;
    var names_js_1 = require_names();
    var unsafe_js_1 = require_unsafe();
    function restoreJsonNames(message) {
      for (const f of message.field) {
        if (!(0, unsafe_js_1.unsafeIsSetExplicit)(f, "jsonName")) {
          f.jsonName = (0, names_js_1.protoCamelCase)(f.name);
        }
      }
      message.nestedType.forEach(restoreJsonNames);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/text-format.js
var require_text_format = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/text-format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTextFormatEnumValue = parseTextFormatEnumValue;
    exports.parseTextFormatScalarValue = parseTextFormatScalarValue;
    var descriptors_js_1 = require_descriptors();
    var proto_int64_js_1 = require_proto_int64();
    function parseTextFormatEnumValue(descEnum, value) {
      const enumValue = descEnum.values.find((v) => v.name === value);
      if (!enumValue) {
        throw new Error(`cannot parse ${descEnum} default value: ${value}`);
      }
      return enumValue.number;
    }
    function parseTextFormatScalarValue(type, value) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          return value;
        case descriptors_js_1.ScalarType.BYTES: {
          const u = unescapeBytesDefaultValue(value);
          if (u === false) {
            throw new Error(`cannot parse ${descriptors_js_1.ScalarType[type]} default value: ${value}`);
          }
          return u;
        }
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          return proto_int64_js_1.protoInt64.parse(value);
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
          return proto_int64_js_1.protoInt64.uParse(value);
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FLOAT:
          switch (value) {
            case "inf":
              return Number.POSITIVE_INFINITY;
            case "-inf":
              return Number.NEGATIVE_INFINITY;
            case "nan":
              return Number.NaN;
            default:
              return parseFloat(value);
          }
        case descriptors_js_1.ScalarType.BOOL:
          return value === "true";
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.UINT32:
        case descriptors_js_1.ScalarType.SINT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.SFIXED32:
          return parseInt(value, 10);
      }
    }
    function unescapeBytesDefaultValue(str) {
      const b = [];
      const input = {
        tail: str,
        c: "",
        next() {
          if (this.tail.length == 0) {
            return false;
          }
          this.c = this.tail[0];
          this.tail = this.tail.substring(1);
          return true;
        },
        take(n) {
          if (this.tail.length >= n) {
            const r = this.tail.substring(0, n);
            this.tail = this.tail.substring(n);
            return r;
          }
          return false;
        }
      };
      while (input.next()) {
        switch (input.c) {
          case "\\":
            if (input.next()) {
              switch (input.c) {
                case "\\":
                  b.push(input.c.charCodeAt(0));
                  break;
                case "b":
                  b.push(8);
                  break;
                case "f":
                  b.push(12);
                  break;
                case "n":
                  b.push(10);
                  break;
                case "r":
                  b.push(13);
                  break;
                case "t":
                  b.push(9);
                  break;
                case "v":
                  b.push(11);
                  break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7": {
                  const s = input.c;
                  const t = input.take(2);
                  if (t === false) {
                    return false;
                  }
                  const n = parseInt(s + t, 8);
                  if (isNaN(n)) {
                    return false;
                  }
                  b.push(n);
                  break;
                }
                case "x": {
                  const s = input.c;
                  const t = input.take(2);
                  if (t === false) {
                    return false;
                  }
                  const n = parseInt(s + t, 16);
                  if (isNaN(n)) {
                    return false;
                  }
                  b.push(n);
                  break;
                }
                case "u": {
                  const s = input.c;
                  const t = input.take(4);
                  if (t === false) {
                    return false;
                  }
                  const n = parseInt(s + t, 16);
                  if (isNaN(n)) {
                    return false;
                  }
                  const chunk = new Uint8Array(4);
                  const view = new DataView(chunk.buffer);
                  view.setInt32(0, n, true);
                  b.push(chunk[0], chunk[1], chunk[2], chunk[3]);
                  break;
                }
                case "U": {
                  const s = input.c;
                  const t = input.take(8);
                  if (t === false) {
                    return false;
                  }
                  const tc = proto_int64_js_1.protoInt64.uEnc(s + t);
                  const chunk = new Uint8Array(8);
                  const view = new DataView(chunk.buffer);
                  view.setInt32(0, tc.lo, true);
                  view.setInt32(4, tc.hi, true);
                  b.push(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7]);
                  break;
                }
              }
            }
            break;
          default:
            b.push(input.c.charCodeAt(0));
        }
      }
      return new Uint8Array(b);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/nested-types.js
var require_nested_types = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/nested-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nestedTypes = nestedTypes;
    exports.parentTypes = parentTypes;
    function* nestedTypes(desc) {
      switch (desc.kind) {
        case "file":
          for (const message of desc.messages) {
            yield message;
            yield* nestedTypes(message);
          }
          yield* desc.enums;
          yield* desc.services;
          yield* desc.extensions;
          break;
        case "message":
          for (const message of desc.nestedMessages) {
            yield message;
            yield* nestedTypes(message);
          }
          yield* desc.nestedEnums;
          yield* desc.nestedExtensions;
          break;
      }
    }
    function parentTypes(desc) {
      const parents = [];
      while (desc.kind !== "file") {
        const p = parent(desc);
        desc = p;
        parents.push(p);
      }
      return parents;
    }
    function parent(desc) {
      var _a;
      switch (desc.kind) {
        case "enum_value":
        case "field":
        case "oneof":
        case "rpc":
          return desc.parent;
        case "service":
          return desc.file;
        case "extension":
        case "enum":
        case "message":
          return (_a = desc.parent) !== null && _a !== void 0 ? _a : desc.file;
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/registry.js
var require_registry = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maximumEdition = exports.minimumEdition = void 0;
    exports.createRegistry = createRegistry;
    exports.createMutableRegistry = createMutableRegistry;
    exports.createFileRegistry = createFileRegistry;
    var descriptors_js_1 = require_descriptors();
    var text_format_js_1 = require_text_format();
    var nested_types_js_1 = require_nested_types();
    var unsafe_js_1 = require_unsafe();
    var names_js_1 = require_names();
    function createRegistry(...input) {
      return initBaseRegistry(input);
    }
    function createMutableRegistry(...input) {
      const reg = initBaseRegistry(input);
      return Object.assign(Object.assign({}, reg), { remove(desc) {
        var _a;
        if (desc.kind == "extension") {
          (_a = reg.extendees.get(desc.extendee.typeName)) === null || _a === void 0 ? void 0 : _a.delete(desc.number);
        }
        reg.types.delete(desc.typeName);
      } });
    }
    function createFileRegistry(...args) {
      const registry = createBaseRegistry();
      if (!args.length) {
        return registry;
      }
      if ("$typeName" in args[0] && args[0].$typeName == "google.protobuf.FileDescriptorSet") {
        for (const file of args[0].file) {
          addFile(file, registry);
        }
        return registry;
      }
      if ("$typeName" in args[0]) {
        let recurseDeps = function(file) {
          const deps = [];
          for (const protoFileName of file.dependency) {
            if (registry.getFile(protoFileName) != void 0) {
              continue;
            }
            if (seen.has(protoFileName)) {
              continue;
            }
            const dep = resolve(protoFileName);
            if (!dep) {
              throw new Error(`Unable to resolve ${protoFileName}, imported by ${file.name}`);
            }
            if ("kind" in dep) {
              registry.addFile(dep, false, true);
            } else {
              seen.add(dep.name);
              deps.push(dep);
            }
          }
          return deps.concat(...deps.map(recurseDeps));
        };
        const input = args[0];
        const resolve = args[1];
        const seen = /* @__PURE__ */ new Set();
        for (const file of [input, ...recurseDeps(input)].reverse()) {
          addFile(file, registry);
        }
      } else {
        for (const fileReg of args) {
          for (const file of fileReg.files) {
            registry.addFile(file);
          }
        }
      }
      return registry;
    }
    function createBaseRegistry() {
      const types3 = /* @__PURE__ */ new Map();
      const extendees = /* @__PURE__ */ new Map();
      const files = /* @__PURE__ */ new Map();
      return {
        kind: "registry",
        types: types3,
        extendees,
        [Symbol.iterator]() {
          return types3.values();
        },
        get files() {
          return files.values();
        },
        addFile(file, skipTypes, withDeps) {
          files.set(file.proto.name, file);
          if (!skipTypes) {
            for (const type of (0, nested_types_js_1.nestedTypes)(file)) {
              this.add(type);
            }
          }
          if (withDeps) {
            for (const f of file.dependencies) {
              this.addFile(f, skipTypes, withDeps);
            }
          }
        },
        add(desc) {
          if (desc.kind == "extension") {
            let numberToExt = extendees.get(desc.extendee.typeName);
            if (!numberToExt) {
              extendees.set(desc.extendee.typeName, numberToExt = /* @__PURE__ */ new Map());
            }
            numberToExt.set(desc.number, desc);
          }
          types3.set(desc.typeName, desc);
        },
        get(typeName) {
          return types3.get(typeName);
        },
        getFile(fileName) {
          return files.get(fileName);
        },
        getMessage(typeName) {
          const t = types3.get(typeName);
          return (t === null || t === void 0 ? void 0 : t.kind) == "message" ? t : void 0;
        },
        getEnum(typeName) {
          const t = types3.get(typeName);
          return (t === null || t === void 0 ? void 0 : t.kind) == "enum" ? t : void 0;
        },
        getExtension(typeName) {
          const t = types3.get(typeName);
          return (t === null || t === void 0 ? void 0 : t.kind) == "extension" ? t : void 0;
        },
        getExtensionFor(extendee, no) {
          var _a;
          return (_a = extendees.get(extendee.typeName)) === null || _a === void 0 ? void 0 : _a.get(no);
        },
        getService(typeName) {
          const t = types3.get(typeName);
          return (t === null || t === void 0 ? void 0 : t.kind) == "service" ? t : void 0;
        }
      };
    }
    function initBaseRegistry(inputs) {
      const registry = createBaseRegistry();
      for (const input of inputs) {
        switch (input.kind) {
          case "registry":
            for (const n of input) {
              registry.add(n);
            }
            break;
          case "file":
            registry.addFile(input);
            break;
          default:
            registry.add(input);
            break;
        }
      }
      return registry;
    }
    var EDITION_PROTO2 = 998;
    var EDITION_PROTO3 = 999;
    var TYPE_STRING = 9;
    var TYPE_GROUP = 10;
    var TYPE_MESSAGE = 11;
    var TYPE_BYTES = 12;
    var TYPE_ENUM = 14;
    var LABEL_REPEATED = 3;
    var LABEL_REQUIRED = 2;
    var JS_STRING = 1;
    var IDEMPOTENCY_UNKNOWN = 0;
    var EXPLICIT = 1;
    var IMPLICIT = 2;
    var LEGACY_REQUIRED = 3;
    var PACKED = 1;
    var DELIMITED = 2;
    var OPEN = 1;
    exports.minimumEdition = 998, exports.maximumEdition = 1e3;
    var featureDefaults = {
      // EDITION_PROTO2
      998: {
        fieldPresence: 1,
        // EXPLICIT,
        enumType: 2,
        // CLOSED,
        repeatedFieldEncoding: 2,
        // EXPANDED,
        utf8Validation: 3,
        // NONE,
        messageEncoding: 1,
        // LENGTH_PREFIXED,
        jsonFormat: 2
        // LEGACY_BEST_EFFORT,
      },
      // EDITION_PROTO3
      999: {
        fieldPresence: 2,
        // IMPLICIT,
        enumType: 1,
        // OPEN,
        repeatedFieldEncoding: 1,
        // PACKED,
        utf8Validation: 2,
        // VERIFY,
        messageEncoding: 1,
        // LENGTH_PREFIXED,
        jsonFormat: 1
        // ALLOW,
      },
      // EDITION_2023
      1e3: {
        fieldPresence: 1,
        // EXPLICIT,
        enumType: 1,
        // OPEN,
        repeatedFieldEncoding: 1,
        // PACKED,
        utf8Validation: 2,
        // VERIFY,
        messageEncoding: 1,
        // LENGTH_PREFIXED,
        jsonFormat: 1
        // ALLOW,
      }
    };
    function addFile(proto, reg) {
      var _a, _b;
      const file = {
        kind: "file",
        proto,
        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
        edition: getFileEdition(proto),
        name: proto.name.replace(/\.proto$/, ""),
        dependencies: findFileDependencies(proto, reg),
        enums: [],
        messages: [],
        extensions: [],
        services: [],
        toString() {
          return `file ${proto.name}`;
        }
      };
      const mapEntriesStore = /* @__PURE__ */ new Map();
      const mapEntries2 = {
        get(typeName) {
          return mapEntriesStore.get(typeName);
        },
        add(desc) {
          var _a2;
          assert(((_a2 = desc.proto.options) === null || _a2 === void 0 ? void 0 : _a2.mapEntry) === true);
          mapEntriesStore.set(desc.typeName, desc);
        }
      };
      for (const enumProto of proto.enumType) {
        addEnum(enumProto, file, void 0, reg);
      }
      for (const messageProto of proto.messageType) {
        addMessage(messageProto, file, void 0, reg, mapEntries2);
      }
      for (const serviceProto of proto.service) {
        addService(serviceProto, file, reg);
      }
      addExtensions(file, reg);
      for (const mapEntry of mapEntriesStore.values()) {
        addFields(mapEntry, reg, mapEntries2);
      }
      for (const message of file.messages) {
        addFields(message, reg, mapEntries2);
        addExtensions(message, reg);
      }
      reg.addFile(file, true);
    }
    function addExtensions(desc, reg) {
      switch (desc.kind) {
        case "file":
          for (const proto of desc.proto.extension) {
            const ext = newField(proto, desc, reg);
            desc.extensions.push(ext);
            reg.add(ext);
          }
          break;
        case "message":
          for (const proto of desc.proto.extension) {
            const ext = newField(proto, desc, reg);
            desc.nestedExtensions.push(ext);
            reg.add(ext);
          }
          for (const message of desc.nestedMessages) {
            addExtensions(message, reg);
          }
          break;
      }
    }
    function addFields(message, reg, mapEntries2) {
      const allOneofs = message.proto.oneofDecl.map((proto) => newOneof(proto, message));
      const oneofsSeen = /* @__PURE__ */ new Set();
      for (const proto of message.proto.field) {
        const oneof = findOneof(proto, allOneofs);
        const field = newField(proto, message, reg, oneof, mapEntries2);
        message.fields.push(field);
        message.field[field.localName] = field;
        if (oneof === void 0) {
          message.members.push(field);
        } else {
          oneof.fields.push(field);
          if (!oneofsSeen.has(oneof)) {
            oneofsSeen.add(oneof);
            message.members.push(oneof);
          }
        }
      }
      for (const oneof of allOneofs.filter((o) => oneofsSeen.has(o))) {
        message.oneofs.push(oneof);
      }
      for (const child of message.nestedMessages) {
        addFields(child, reg, mapEntries2);
      }
    }
    function addEnum(proto, file, parent, reg) {
      var _a, _b, _c;
      const sharedPrefix = findEnumSharedPrefix(proto.name, proto.value);
      const desc = {
        kind: "enum",
        proto,
        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
        file,
        parent,
        open: true,
        name: proto.name,
        typeName: makeTypeName(proto, parent, file),
        value: {},
        values: [],
        sharedPrefix,
        toString() {
          return `enum ${this.typeName}`;
        }
      };
      desc.open = isEnumOpen(desc);
      reg.add(desc);
      proto.value.forEach((proto2) => {
        var _a2, _b2;
        const name = proto2.name;
        desc.values.push(desc.value[proto2.number] = {
          kind: "enum_value",
          proto: proto2,
          deprecated: (_b2 = (_a2 = proto2.options) === null || _a2 === void 0 ? void 0 : _a2.deprecated) !== null && _b2 !== void 0 ? _b2 : false,
          parent: desc,
          name,
          localName: (0, names_js_1.safeObjectProperty)(sharedPrefix == void 0 ? name : name.substring(sharedPrefix.length)),
          number: proto2.number,
          toString() {
            return `enum value ${desc.typeName}.${name}`;
          }
        });
      });
      ((_c = parent === null || parent === void 0 ? void 0 : parent.nestedEnums) !== null && _c !== void 0 ? _c : file.enums).push(desc);
    }
    function addMessage(proto, file, parent, reg, mapEntries2) {
      var _a, _b, _c, _d;
      const desc = {
        kind: "message",
        proto,
        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
        file,
        parent,
        name: proto.name,
        typeName: makeTypeName(proto, parent, file),
        fields: [],
        field: {},
        oneofs: [],
        members: [],
        nestedEnums: [],
        nestedMessages: [],
        nestedExtensions: [],
        toString() {
          return `message ${this.typeName}`;
        }
      };
      if (((_c = proto.options) === null || _c === void 0 ? void 0 : _c.mapEntry) === true) {
        mapEntries2.add(desc);
      } else {
        ((_d = parent === null || parent === void 0 ? void 0 : parent.nestedMessages) !== null && _d !== void 0 ? _d : file.messages).push(desc);
        reg.add(desc);
      }
      for (const enumProto of proto.enumType) {
        addEnum(enumProto, file, desc, reg);
      }
      for (const messageProto of proto.nestedType) {
        addMessage(messageProto, file, desc, reg, mapEntries2);
      }
    }
    function addService(proto, file, reg) {
      var _a, _b;
      const desc = {
        kind: "service",
        proto,
        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
        file,
        name: proto.name,
        typeName: makeTypeName(proto, void 0, file),
        methods: [],
        method: {},
        toString() {
          return `service ${this.typeName}`;
        }
      };
      file.services.push(desc);
      reg.add(desc);
      for (const methodProto of proto.method) {
        const method = newMethod(methodProto, desc, reg);
        desc.methods.push(method);
        desc.method[method.localName] = method;
      }
    }
    function newMethod(proto, parent, reg) {
      var _a, _b, _c, _d;
      let methodKind;
      if (proto.clientStreaming && proto.serverStreaming) {
        methodKind = "bidi_streaming";
      } else if (proto.clientStreaming) {
        methodKind = "client_streaming";
      } else if (proto.serverStreaming) {
        methodKind = "server_streaming";
      } else {
        methodKind = "unary";
      }
      const input = reg.getMessage(trimLeadingDot(proto.inputType));
      const output = reg.getMessage(trimLeadingDot(proto.outputType));
      assert(input, `invalid MethodDescriptorProto: input_type ${proto.inputType} not found`);
      assert(output, `invalid MethodDescriptorProto: output_type ${proto.inputType} not found`);
      const name = proto.name;
      return {
        kind: "rpc",
        proto,
        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
        parent,
        name,
        localName: (0, names_js_1.safeObjectProperty)(name.length ? (0, names_js_1.safeObjectProperty)(name[0].toLowerCase() + name.substring(1)) : name),
        methodKind,
        input,
        output,
        idempotency: (_d = (_c = proto.options) === null || _c === void 0 ? void 0 : _c.idempotencyLevel) !== null && _d !== void 0 ? _d : IDEMPOTENCY_UNKNOWN,
        toString() {
          return `rpc ${parent.typeName}.${name}`;
        }
      };
    }
    function newOneof(proto, parent) {
      return {
        kind: "oneof",
        proto,
        deprecated: false,
        parent,
        fields: [],
        name: proto.name,
        localName: (0, names_js_1.safeObjectProperty)((0, names_js_1.protoCamelCase)(proto.name)),
        toString() {
          return `oneof ${parent.typeName}.${this.name}`;
        }
      };
    }
    function newField(proto, parentOrFile, reg, oneof, mapEntries2) {
      var _a, _b, _c;
      const isExtension = mapEntries2 === void 0;
      const field = {
        kind: "field",
        proto,
        deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
        name: proto.name,
        number: proto.number,
        scalar: void 0,
        message: void 0,
        enum: void 0,
        presence: getFieldPresence(proto, oneof, isExtension, parentOrFile),
        listKind: void 0,
        mapKind: void 0,
        mapKey: void 0,
        delimitedEncoding: void 0,
        packed: void 0,
        longAsString: false,
        getDefaultValue: void 0
      };
      if (isExtension) {
        const file = parentOrFile.kind == "file" ? parentOrFile : parentOrFile.file;
        const parent = parentOrFile.kind == "file" ? void 0 : parentOrFile;
        const typeName = makeTypeName(proto, parent, file);
        field.kind = "extension";
        field.file = file;
        field.parent = parent;
        field.oneof = void 0;
        field.typeName = typeName;
        field.jsonName = `[${typeName}]`;
        field.toString = () => `extension ${typeName}`;
        const extendee = reg.getMessage(trimLeadingDot(proto.extendee));
        assert(extendee, `invalid FieldDescriptorProto: extendee ${proto.extendee} not found`);
        field.extendee = extendee;
      } else {
        const parent = parentOrFile;
        assert(parent.kind == "message");
        field.parent = parent;
        field.oneof = oneof;
        field.localName = oneof ? (0, names_js_1.protoCamelCase)(proto.name) : (0, names_js_1.safeObjectProperty)((0, names_js_1.protoCamelCase)(proto.name));
        field.jsonName = proto.jsonName;
        field.toString = () => `field ${parent.typeName}.${proto.name}`;
      }
      const label = proto.label;
      const type = proto.type;
      const jstype = (_c = proto.options) === null || _c === void 0 ? void 0 : _c.jstype;
      if (label === LABEL_REPEATED) {
        const mapEntry = type == TYPE_MESSAGE ? mapEntries2 === null || mapEntries2 === void 0 ? void 0 : mapEntries2.get(trimLeadingDot(proto.typeName)) : void 0;
        if (mapEntry) {
          field.fieldKind = "map";
          const { key, value } = findMapEntryFields(mapEntry);
          field.mapKey = key.scalar;
          field.mapKind = value.fieldKind;
          field.message = value.message;
          field.delimitedEncoding = false;
          field.enum = value.enum;
          field.scalar = value.scalar;
          return field;
        }
        field.fieldKind = "list";
        switch (type) {
          case TYPE_MESSAGE:
          case TYPE_GROUP:
            field.listKind = "message";
            field.message = reg.getMessage(trimLeadingDot(proto.typeName));
            assert(field.message);
            field.delimitedEncoding = isDelimitedEncoding(proto, parentOrFile);
            break;
          case TYPE_ENUM:
            field.listKind = "enum";
            field.enum = reg.getEnum(trimLeadingDot(proto.typeName));
            assert(field.enum);
            break;
          default:
            field.listKind = "scalar";
            field.scalar = type;
            field.longAsString = jstype == JS_STRING;
            break;
        }
        field.packed = isPackedField(proto, parentOrFile);
        return field;
      }
      switch (type) {
        case TYPE_MESSAGE:
        case TYPE_GROUP:
          field.fieldKind = "message";
          field.message = reg.getMessage(trimLeadingDot(proto.typeName));
          assert(
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            field.message,
            `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`
          );
          field.delimitedEncoding = isDelimitedEncoding(proto, parentOrFile);
          field.getDefaultValue = () => void 0;
          break;
        case TYPE_ENUM: {
          const enumeration = reg.getEnum(trimLeadingDot(proto.typeName));
          assert(enumeration !== void 0, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
          field.fieldKind = "enum";
          field.enum = reg.getEnum(trimLeadingDot(proto.typeName));
          field.getDefaultValue = () => {
            return (0, unsafe_js_1.unsafeIsSetExplicit)(proto, "defaultValue") ? (0, text_format_js_1.parseTextFormatEnumValue)(enumeration, proto.defaultValue) : void 0;
          };
          break;
        }
        default: {
          field.fieldKind = "scalar";
          field.scalar = type;
          field.longAsString = jstype == JS_STRING;
          field.getDefaultValue = () => {
            return (0, unsafe_js_1.unsafeIsSetExplicit)(proto, "defaultValue") ? (0, text_format_js_1.parseTextFormatScalarValue)(type, proto.defaultValue) : void 0;
          };
          break;
        }
      }
      return field;
    }
    function getFileEdition(proto) {
      switch (proto.syntax) {
        case "":
        case "proto2":
          return EDITION_PROTO2;
        case "proto3":
          return EDITION_PROTO3;
        case "editions":
          if (proto.edition in featureDefaults) {
            return proto.edition;
          }
          throw new Error(`${proto.name}: unsupported edition`);
        default:
          throw new Error(`${proto.name}: unsupported syntax "${proto.syntax}"`);
      }
    }
    function findFileDependencies(proto, reg) {
      return proto.dependency.map((wantName) => {
        const dep = reg.getFile(wantName);
        if (!dep) {
          throw new Error(`Cannot find ${wantName}, imported by ${proto.name}`);
        }
        return dep;
      });
    }
    function findEnumSharedPrefix(enumName, values2) {
      const prefix = camelToSnakeCase(enumName) + "_";
      for (const value of values2) {
        if (!value.name.toLowerCase().startsWith(prefix)) {
          return void 0;
        }
        const shortName = value.name.substring(prefix.length);
        if (shortName.length == 0) {
          return void 0;
        }
        if (/^\d/.test(shortName)) {
          return void 0;
        }
      }
      return prefix;
    }
    function camelToSnakeCase(camel) {
      return (camel.substring(0, 1) + camel.substring(1).replace(/[A-Z]/g, (c) => "_" + c)).toLowerCase();
    }
    function makeTypeName(proto, parent, file) {
      let typeName;
      if (parent) {
        typeName = `${parent.typeName}.${proto.name}`;
      } else if (file.proto.package.length > 0) {
        typeName = `${file.proto.package}.${proto.name}`;
      } else {
        typeName = `${proto.name}`;
      }
      return typeName;
    }
    function trimLeadingDot(typeName) {
      return typeName.startsWith(".") ? typeName.substring(1) : typeName;
    }
    function findOneof(proto, allOneofs) {
      if (!(0, unsafe_js_1.unsafeIsSetExplicit)(proto, "oneofIndex")) {
        return void 0;
      }
      if (proto.proto3Optional) {
        return void 0;
      }
      const oneof = allOneofs[proto.oneofIndex];
      assert(
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        oneof,
        `invalid FieldDescriptorProto: oneof #${proto.oneofIndex} for field #${proto.number} not found`
      );
      return oneof;
    }
    function getFieldPresence(proto, oneof, isExtension, parent) {
      if (proto.label == LABEL_REQUIRED) {
        return LEGACY_REQUIRED;
      }
      if (proto.label == LABEL_REPEATED) {
        return IMPLICIT;
      }
      if (!!oneof || proto.proto3Optional) {
        return EXPLICIT;
      }
      if (proto.type == TYPE_MESSAGE) {
        return EXPLICIT;
      }
      if (isExtension) {
        return EXPLICIT;
      }
      return resolveFeature("fieldPresence", { proto, parent });
    }
    function isPackedField(proto, parent) {
      if (proto.label != LABEL_REPEATED) {
        return false;
      }
      switch (proto.type) {
        case TYPE_STRING:
        case TYPE_BYTES:
        case TYPE_GROUP:
        case TYPE_MESSAGE:
          return false;
      }
      const o = proto.options;
      if (o && (0, unsafe_js_1.unsafeIsSetExplicit)(o, "packed")) {
        return o.packed;
      }
      return PACKED == resolveFeature("repeatedFieldEncoding", {
        proto,
        parent
      });
    }
    function findMapEntryFields(mapEntry) {
      const key = mapEntry.fields.find((f) => f.number === 1);
      const value = mapEntry.fields.find((f) => f.number === 2);
      assert(key && key.fieldKind == "scalar" && key.scalar != descriptors_js_1.ScalarType.BYTES && key.scalar != descriptors_js_1.ScalarType.FLOAT && key.scalar != descriptors_js_1.ScalarType.DOUBLE && value && value.fieldKind != "list" && value.fieldKind != "map");
      return { key, value };
    }
    function isEnumOpen(desc) {
      var _a;
      return OPEN == resolveFeature("enumType", {
        proto: desc.proto,
        parent: (_a = desc.parent) !== null && _a !== void 0 ? _a : desc.file
      });
    }
    function isDelimitedEncoding(proto, parent) {
      if (proto.type == TYPE_GROUP) {
        return true;
      }
      return DELIMITED == resolveFeature("messageEncoding", {
        proto,
        parent
      });
    }
    function resolveFeature(name, ref) {
      var _a, _b;
      const featureSet = (_a = ref.proto.options) === null || _a === void 0 ? void 0 : _a.features;
      if (featureSet) {
        const val = featureSet[name];
        if (val != 0) {
          return val;
        }
      }
      if ("kind" in ref) {
        if (ref.kind == "message") {
          return resolveFeature(name, (_b = ref.parent) !== null && _b !== void 0 ? _b : ref.file);
        }
        const editionDefaults = featureDefaults[ref.edition];
        if (!editionDefaults) {
          throw new Error(`feature default for edition ${ref.edition} not found`);
        }
        return editionDefaults[name];
      }
      return resolveFeature(name, ref.parent);
    }
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg);
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/boot.js
var require_boot = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/boot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boot = boot;
    exports.bootFileDescriptorProto = bootFileDescriptorProto;
    var restore_json_names_js_1 = require_restore_json_names();
    var registry_js_1 = require_registry();
    function boot(boot2) {
      const root = bootFileDescriptorProto(boot2);
      root.messageType.forEach(restore_json_names_js_1.restoreJsonNames);
      const reg = (0, registry_js_1.createFileRegistry)(root, () => void 0);
      return reg.getFile(root.name);
    }
    function bootFileDescriptorProto(init) {
      const proto = /* @__PURE__ */ Object.create({
        syntax: "",
        edition: 0
      });
      return Object.assign(proto, Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], service: [], extension: [] }, init), { messageType: init.messageType.map(bootDescriptorProto), enumType: init.enumType.map(bootEnumDescriptorProto) }));
    }
    function bootDescriptorProto(init) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return {
        $typeName: "google.protobuf.DescriptorProto",
        name: init.name,
        field: (_b = (_a = init.field) === null || _a === void 0 ? void 0 : _a.map(bootFieldDescriptorProto)) !== null && _b !== void 0 ? _b : [],
        extension: [],
        nestedType: (_d = (_c = init.nestedType) === null || _c === void 0 ? void 0 : _c.map(bootDescriptorProto)) !== null && _d !== void 0 ? _d : [],
        enumType: (_f = (_e = init.enumType) === null || _e === void 0 ? void 0 : _e.map(bootEnumDescriptorProto)) !== null && _f !== void 0 ? _f : [],
        extensionRange: (_h = (_g = init.extensionRange) === null || _g === void 0 ? void 0 : _g.map((e) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, e))) !== null && _h !== void 0 ? _h : [],
        oneofDecl: [],
        reservedRange: [],
        reservedName: []
      };
    }
    function bootFieldDescriptorProto(init) {
      const proto = /* @__PURE__ */ Object.create({
        label: 1,
        typeName: "",
        extendee: "",
        defaultValue: "",
        oneofIndex: 0,
        jsonName: "",
        proto3Optional: false
      });
      return Object.assign(proto, Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, init), { options: init.options ? bootFieldOptions(init.options) : void 0 }));
    }
    function bootFieldOptions(init) {
      var _a, _b, _c;
      const proto = /* @__PURE__ */ Object.create({
        ctype: 0,
        packed: false,
        jstype: 0,
        lazy: false,
        unverifiedLazy: false,
        deprecated: false,
        weak: false,
        debugRedact: false,
        retention: 0
      });
      return Object.assign(proto, Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, init), { targets: (_a = init.targets) !== null && _a !== void 0 ? _a : [], editionDefaults: (_c = (_b = init.editionDefaults) === null || _b === void 0 ? void 0 : _b.map((e) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, e))) !== null && _c !== void 0 ? _c : [], uninterpretedOption: [] }));
    }
    function bootEnumDescriptorProto(init) {
      return {
        $typeName: "google.protobuf.EnumDescriptorProto",
        name: init.name,
        reservedName: [],
        reservedRange: [],
        value: init.value.map((e) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, e))
      };
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/fields.js
var require_fields = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/fields.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFieldSet = isFieldSet;
    exports.clearField = clearField;
    var unsafe_js_1 = require_unsafe();
    function isFieldSet(message, field) {
      return field.parent.typeName == message.$typeName && (0, unsafe_js_1.unsafeIsSet)(message, field);
    }
    function clearField(message, field) {
      if (field.parent.typeName == message.$typeName) {
        (0, unsafe_js_1.unsafeClear)(message, field);
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/base64-encoding.js
var require_base64_encoding = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/base64-encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base64Decode = base64Decode;
    exports.base64Encode = base64Encode;
    function base64Decode(base64Str) {
      const table = getDecodeTable();
      let es = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
      for (let i = 0; i < base64Str.length; i++) {
        b = table[base64Str.charCodeAt(i)];
        if (b === void 0) {
          switch (base64Str[i]) {
            // @ts-expect-error TS7029: Fallthrough case in switch
            case "=":
              groupPos = 0;
            // reset state when padding found
            // eslint-disable-next-line no-fallthrough
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            // skip white-space, and padding
            default:
              throw Error("invalid base64 string");
          }
        }
        switch (groupPos) {
          case 0:
            p = b;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p << 2 | (b & 48) >> 4;
            p = b;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
            p = b;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p & 3) << 6 | b;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error("invalid base64 string");
      return bytes.subarray(0, bytePos);
    }
    function base64Encode(bytes, encoding = "std") {
      const table = getEncodeTable(encoding);
      const pad = encoding == "std";
      let base64 = "", groupPos = 0, b, p = 0;
      for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
          case 0:
            base64 += table[b >> 2];
            p = (b & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += table[p | b >> 4];
            p = (b & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += table[p | b >> 6];
            base64 += table[b & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += table[p];
        if (pad) {
          base64 += "=";
          if (groupPos == 1)
            base64 += "=";
        }
      }
      return base64;
    }
    var encodeTableStd;
    var encodeTableUrl;
    var decodeTable;
    function getEncodeTable(encoding) {
      if (!encodeTableStd) {
        encodeTableStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        encodeTableUrl = encodeTableStd.slice(0, -2).concat("-", "_");
      }
      return encoding == "url" ? encodeTableUrl : encodeTableStd;
    }
    function getDecodeTable() {
      if (!decodeTable) {
        decodeTable = [];
        const encodeTable = getEncodeTable("std");
        for (let i = 0; i < encodeTable.length; i++)
          decodeTable[encodeTable[i].charCodeAt(0)] = i;
        decodeTable["-".charCodeAt(0)] = encodeTable.indexOf("+");
        decodeTable["_".charCodeAt(0)] = encodeTable.indexOf("/");
      }
      return decodeTable;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/is-message.js
var require_is_message = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/is-message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMessage = isMessage;
    function isMessage(arg, schema) {
      const isMessage2 = arg !== null && typeof arg == "object" && "$typeName" in arg && typeof arg.$typeName == "string";
      if (!isMessage2) {
        return false;
      }
      if (schema === void 0) {
        return true;
      }
      return schema.typeName === arg.$typeName;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/error.js
var require_error = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FieldError = void 0;
    exports.isFieldError = isFieldError;
    var errorNames = [
      "FieldValueInvalidError",
      "FieldListRangeError",
      "ForeignFieldError"
    ];
    var FieldError = class extends Error {
      constructor(fieldOrOneof, message, name = "FieldValueInvalidError") {
        super(message);
        this.name = name;
        this.field = () => fieldOrOneof;
      }
    };
    exports.FieldError = FieldError;
    function isFieldError(arg) {
      return arg instanceof Error && errorNames.includes(arg.name) && "field" in arg && typeof arg.field == "function";
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/guard.js
var require_guard = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/guard.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObject = isObject;
    exports.isOneofADT = isOneofADT;
    exports.isReflectList = isReflectList;
    exports.isReflectMap = isReflectMap;
    exports.isReflectMessage = isReflectMessage;
    var unsafe_js_1 = require_unsafe();
    function isObject(arg) {
      return arg !== null && typeof arg == "object" && !Array.isArray(arg);
    }
    function isOneofADT(arg) {
      return arg !== null && typeof arg == "object" && "case" in arg && (typeof arg.case == "string" && "value" in arg && arg.value != null || arg.case === void 0 && (!("value" in arg) || arg.value === void 0));
    }
    function isReflectList(arg, field) {
      var _a, _b, _c, _d;
      if (isObject(arg) && unsafe_js_1.unsafeLocal in arg && "add" in arg && "field" in arg && typeof arg.field == "function") {
        if (field !== void 0) {
          const a = field, b = arg.field();
          return a.listKind == b.listKind && a.scalar === b.scalar && ((_a = a.message) === null || _a === void 0 ? void 0 : _a.typeName) === ((_b = b.message) === null || _b === void 0 ? void 0 : _b.typeName) && ((_c = a.enum) === null || _c === void 0 ? void 0 : _c.typeName) === ((_d = b.enum) === null || _d === void 0 ? void 0 : _d.typeName);
        }
        return true;
      }
      return false;
    }
    function isReflectMap(arg, field) {
      var _a, _b, _c, _d;
      if (isObject(arg) && unsafe_js_1.unsafeLocal in arg && "has" in arg && "field" in arg && typeof arg.field == "function") {
        if (field !== void 0) {
          const a = field, b = arg.field();
          return a.mapKey === b.mapKey && a.mapKind == b.mapKind && a.scalar === b.scalar && ((_a = a.message) === null || _a === void 0 ? void 0 : _a.typeName) === ((_b = b.message) === null || _b === void 0 ? void 0 : _b.typeName) && ((_c = a.enum) === null || _c === void 0 ? void 0 : _c.typeName) === ((_d = b.enum) === null || _d === void 0 ? void 0 : _d.typeName);
        }
        return true;
      }
      return false;
    }
    function isReflectMessage(arg, messageDesc) {
      return isObject(arg) && unsafe_js_1.unsafeLocal in arg && "desc" in arg && isObject(arg.desc) && arg.desc.kind === "message" && (messageDesc === void 0 || arg.desc.typeName == messageDesc.typeName);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/text-encoding.js
var require_text_encoding = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/text-encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.configureTextEncoding = configureTextEncoding;
    exports.getTextEncoding = getTextEncoding;
    var symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
    function configureTextEncoding(textEncoding) {
      globalThis[symbol] = textEncoding;
    }
    function getTextEncoding() {
      if (globalThis[symbol] == void 0) {
        const te = new globalThis.TextEncoder();
        const td = new globalThis.TextDecoder();
        globalThis[symbol] = {
          encodeUtf8(text) {
            return te.encode(text);
          },
          decodeUtf8(bytes) {
            return td.decode(bytes);
          },
          checkUtf8(text) {
            try {
              encodeURIComponent(text);
              return true;
            } catch (e) {
              return false;
            }
          }
        };
      }
      return globalThis[symbol];
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/binary-encoding.js
var require_binary_encoding = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/binary-encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinaryReader = exports.BinaryWriter = exports.INT32_MIN = exports.INT32_MAX = exports.UINT32_MAX = exports.FLOAT32_MIN = exports.FLOAT32_MAX = exports.WireType = void 0;
    var varint_js_1 = require_varint();
    var proto_int64_js_1 = require_proto_int64();
    var text_encoding_js_1 = require_text_encoding();
    var WireType;
    (function(WireType2) {
      WireType2[WireType2["Varint"] = 0] = "Varint";
      WireType2[WireType2["Bit64"] = 1] = "Bit64";
      WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
      WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
      WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
      WireType2[WireType2["Bit32"] = 5] = "Bit32";
    })(WireType || (exports.WireType = WireType = {}));
    exports.FLOAT32_MAX = 34028234663852886e22;
    exports.FLOAT32_MIN = -34028234663852886e22;
    exports.UINT32_MAX = 4294967295;
    exports.INT32_MAX = 2147483647;
    exports.INT32_MIN = -2147483648;
    var BinaryWriter = class {
      constructor(encodeUtf8 = (0, text_encoding_js_1.getTextEncoding)().encodeUtf8) {
        this.encodeUtf8 = encodeUtf8;
        this.stack = [];
        this.chunks = [];
        this.buf = [];
      }
      /**
       * Return all bytes written and reset this writer.
       */
      finish() {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
          len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
          bytes.set(this.chunks[i], offset);
          offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
      }
      /**
       * Start a new fork for length-delimited data like a message
       * or a packed repeated field.
       *
       * Must be joined later with `join()`.
       */
      fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
      }
      /**
       * Join the last fork. Write its length and bytes, then
       * return to the previous state.
       */
      join() {
        let chunk = this.finish();
        let prev = this.stack.pop();
        if (!prev)
          throw new Error("invalid state, fork stack empty");
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Writes a tag (field number and wire type).
       *
       * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
       *
       * Generated code should compute the tag ahead of time and call `uint32()`.
       */
      tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
      }
      /**
       * Write a chunk of raw bytes.
       */
      raw(chunk) {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
      }
      /**
       * Write a `uint32` value, an unsigned 32 bit varint.
       */
      uint32(value) {
        assertUInt32(value);
        while (value > 127) {
          this.buf.push(value & 127 | 128);
          value = value >>> 7;
        }
        this.buf.push(value);
        return this;
      }
      /**
       * Write a `int32` value, a signed 32 bit varint.
       */
      int32(value) {
        assertInt32(value);
        (0, varint_js_1.varint32write)(value, this.buf);
        return this;
      }
      /**
       * Write a `bool` value, a variant.
       */
      bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
      }
      /**
       * Write a `bytes` value, length-delimited arbitrary data.
       */
      bytes(value) {
        this.uint32(value.byteLength);
        return this.raw(value);
      }
      /**
       * Write a `string` value, length-delimited data converted to UTF-8 text.
       */
      string(value) {
        let chunk = this.encodeUtf8(value);
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Write a `float` value, 32-bit floating point number.
       */
      float(value) {
        assertFloat32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `double` value, a 64-bit floating point number.
       */
      double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
       */
      fixed32(value) {
        assertUInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
       */
      sfixed32(value) {
        assertInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
       */
      sint32(value) {
        assertInt32(value);
        value = (value << 1 ^ value >> 31) >>> 0;
        (0, varint_js_1.varint32write)(value, this.buf);
        return this;
      }
      /**
       * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
       */
      sfixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = proto_int64_js_1.protoInt64.enc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
       */
      fixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = proto_int64_js_1.protoInt64.uEnc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `int64` value, a signed 64-bit varint.
       */
      int64(value) {
        let tc = proto_int64_js_1.protoInt64.enc(value);
        (0, varint_js_1.varint64write)(tc.lo, tc.hi, this.buf);
        return this;
      }
      /**
       * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64(value) {
        let tc = proto_int64_js_1.protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
        (0, varint_js_1.varint64write)(lo, hi, this.buf);
        return this;
      }
      /**
       * Write a `uint64` value, an unsigned 64-bit varint.
       */
      uint64(value) {
        let tc = proto_int64_js_1.protoInt64.uEnc(value);
        (0, varint_js_1.varint64write)(tc.lo, tc.hi, this.buf);
        return this;
      }
    };
    exports.BinaryWriter = BinaryWriter;
    var BinaryReader = class {
      constructor(buf, decodeUtf8 = (0, text_encoding_js_1.getTextEncoding)().decodeUtf8) {
        this.decodeUtf8 = decodeUtf8;
        this.varint64 = varint_js_1.varint64read;
        this.uint32 = varint_js_1.varint32read;
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      /**
       * Reads a tag - field number and wire type.
       */
      tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
      }
      /**
       * Skip one element and return the skipped data.
       *
       * When skipping StartGroup, provide the tags field number to check for
       * matching field number in the EndGroup tag.
       */
      skip(wireType, fieldNo) {
        let start = this.pos;
        switch (wireType) {
          case WireType.Varint:
            while (this.buf[this.pos++] & 128) {
            }
            break;
          // eslint-disable-next-line
          // @ts-expect-error TS7029: Fallthrough case in switch
          case WireType.Bit64:
            this.pos += 4;
          // eslint-disable-next-line no-fallthrough
          case WireType.Bit32:
            this.pos += 4;
            break;
          case WireType.LengthDelimited:
            let len = this.uint32();
            this.pos += len;
            break;
          case WireType.StartGroup:
            for (; ; ) {
              const [fn, wt] = this.tag();
              if (wt === WireType.EndGroup) {
                if (fieldNo !== void 0 && fn !== fieldNo) {
                  throw new Error("invalid end group tag");
                }
                break;
              }
              this.skip(wt, fn);
            }
            break;
          default:
            throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
      }
      /**
       * Throws error if position in byte array is out of range.
       */
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      /**
       * Read a `int32` field, a signed 32 bit varint.
       */
      int32() {
        return this.uint32() | 0;
      }
      /**
       * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
       */
      sint32() {
        let zze = this.uint32();
        return zze >>> 1 ^ -(zze & 1);
      }
      /**
       * Read a `int64` field, a signed 64-bit varint.
       */
      int64() {
        return proto_int64_js_1.protoInt64.dec(...this.varint64());
      }
      /**
       * Read a `uint64` field, an unsigned 64-bit varint.
       */
      uint64() {
        return proto_int64_js_1.protoInt64.uDec(...this.varint64());
      }
      /**
       * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64() {
        let [lo, hi] = this.varint64();
        let s = -(lo & 1);
        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
        hi = hi >>> 1 ^ s;
        return proto_int64_js_1.protoInt64.dec(lo, hi);
      }
      /**
       * Read a `bool` field, a variant.
       */
      bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
      }
      /**
       * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
       */
      fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
       */
      sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
       */
      fixed64() {
        return proto_int64_js_1.protoInt64.uDec(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
       */
      sfixed64() {
        return proto_int64_js_1.protoInt64.dec(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `float` field, 32-bit floating point number.
       */
      float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `double` field, a 64-bit floating point number.
       */
      double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
      }
      /**
       * Read a `bytes` field, length-delimited arbitrary data.
       */
      bytes() {
        let len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      /**
       * Read a `string` field, length-delimited data converted to UTF-8 text.
       */
      string() {
        return this.decodeUtf8(this.bytes());
      }
    };
    exports.BinaryReader = BinaryReader;
    function assertInt32(arg) {
      if (typeof arg == "string") {
        arg = Number(arg);
      } else if (typeof arg != "number") {
        throw new Error("invalid int32: " + typeof arg);
      }
      if (!Number.isInteger(arg) || arg > exports.INT32_MAX || arg < exports.INT32_MIN)
        throw new Error("invalid int32: " + arg);
    }
    function assertUInt32(arg) {
      if (typeof arg == "string") {
        arg = Number(arg);
      } else if (typeof arg != "number") {
        throw new Error("invalid uint32: " + typeof arg);
      }
      if (!Number.isInteger(arg) || arg > exports.UINT32_MAX || arg < 0)
        throw new Error("invalid uint32: " + arg);
    }
    function assertFloat32(arg) {
      if (typeof arg == "string") {
        const o = arg;
        arg = Number(arg);
        if (isNaN(arg) && o !== "NaN") {
          throw new Error("invalid float32: " + o);
        }
      } else if (typeof arg != "number") {
        throw new Error("invalid float32: " + typeof arg);
      }
      if (Number.isFinite(arg) && (arg > exports.FLOAT32_MAX || arg < exports.FLOAT32_MIN))
        throw new Error("invalid float32: " + arg);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect-check.js
var require_reflect_check = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect-check.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkField = checkField;
    exports.checkListItem = checkListItem;
    exports.checkMapEntry = checkMapEntry;
    exports.formatVal = formatVal;
    var descriptors_js_1 = require_descriptors();
    var is_message_js_1 = require_is_message();
    var error_js_1 = require_error();
    var guard_js_1 = require_guard();
    var binary_encoding_js_1 = require_binary_encoding();
    var text_encoding_js_1 = require_text_encoding();
    var proto_int64_js_1 = require_proto_int64();
    function checkField(field, value) {
      const check = field.fieldKind == "list" ? (0, guard_js_1.isReflectList)(value, field) : field.fieldKind == "map" ? (0, guard_js_1.isReflectMap)(value, field) : checkSingular(field, value);
      if (check === true) {
        return void 0;
      }
      let reason;
      switch (field.fieldKind) {
        case "list":
          reason = `expected ${formatReflectList(field)}, got ${formatVal(value)}`;
          break;
        case "map":
          reason = `expected ${formatReflectMap(field)}, got ${formatVal(value)}`;
          break;
        default: {
          reason = reasonSingular(field, value, check);
        }
      }
      return new error_js_1.FieldError(field, reason);
    }
    function checkListItem(field, index, value) {
      const check = checkSingular(field, value);
      if (check !== true) {
        return new error_js_1.FieldError(field, `list item #${index + 1}: ${reasonSingular(field, value, check)}`);
      }
      return void 0;
    }
    function checkMapEntry(field, key, value) {
      const checkKey = checkScalarValue(key, field.mapKey);
      if (checkKey !== true) {
        return new error_js_1.FieldError(field, `invalid map key: ${reasonSingular({ scalar: field.mapKey }, key, checkKey)}`);
      }
      const checkVal = checkSingular(field, value);
      if (checkVal !== true) {
        return new error_js_1.FieldError(field, `map entry ${formatVal(key)}: ${reasonSingular(field, value, checkVal)}`);
      }
      return void 0;
    }
    function checkSingular(field, value) {
      if (field.scalar !== void 0) {
        return checkScalarValue(value, field.scalar);
      }
      if (field.enum !== void 0) {
        if (field.enum.open) {
          return Number.isInteger(value);
        }
        return field.enum.values.some((v) => v.number === value);
      }
      return (0, guard_js_1.isReflectMessage)(value, field.message);
    }
    function checkScalarValue(value, scalar) {
      switch (scalar) {
        case descriptors_js_1.ScalarType.DOUBLE:
          return typeof value == "number";
        case descriptors_js_1.ScalarType.FLOAT:
          if (typeof value != "number") {
            return false;
          }
          if (Number.isNaN(value) || !Number.isFinite(value)) {
            return true;
          }
          if (value > binary_encoding_js_1.FLOAT32_MAX || value < binary_encoding_js_1.FLOAT32_MIN) {
            return `${value.toFixed()} out of range`;
          }
          return true;
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
          if (typeof value !== "number" || !Number.isInteger(value)) {
            return false;
          }
          if (value > binary_encoding_js_1.INT32_MAX || value < binary_encoding_js_1.INT32_MIN) {
            return `${value.toFixed()} out of range`;
          }
          return true;
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
          if (typeof value !== "number" || !Number.isInteger(value)) {
            return false;
          }
          if (value > binary_encoding_js_1.UINT32_MAX || value < 0) {
            return `${value.toFixed()} out of range`;
          }
          return true;
        case descriptors_js_1.ScalarType.BOOL:
          return typeof value == "boolean";
        case descriptors_js_1.ScalarType.STRING:
          if (typeof value != "string") {
            return false;
          }
          return (0, text_encoding_js_1.getTextEncoding)().checkUtf8(value) || "invalid UTF8";
        case descriptors_js_1.ScalarType.BYTES:
          return value instanceof Uint8Array;
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          if (typeof value != "string" && typeof value !== "bigint" && typeof value !== "number") {
            return false;
          }
          try {
            proto_int64_js_1.protoInt64.parse(value);
          } catch (e) {
            return `${value} out of range`;
          }
          return true;
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.UINT64:
          if (typeof value != "string" && typeof value !== "bigint" && typeof value !== "number") {
            return false;
          }
          try {
            proto_int64_js_1.protoInt64.uParse(value);
          } catch (e) {
            return `${value} out of range`;
          }
          return true;
      }
    }
    function reasonSingular(field, val, details) {
      details = typeof details == "string" ? `: ${details}` : `, got ${formatVal(val)}`;
      if (field.scalar !== void 0) {
        return `expected ${scalarTypeDescription(field.scalar)}` + details;
      } else if (field.enum !== void 0) {
        return `expected ${field.enum.toString()}` + details;
      }
      return `expected ${formatReflectMessage(field.message)}` + details;
    }
    function formatVal(val) {
      switch (typeof val) {
        case "object":
          if (val === null) {
            return "null";
          }
          if (val instanceof Uint8Array) {
            return `Uint8Array(${val.length})`;
          }
          if (Array.isArray(val)) {
            return `Array(${val.length})`;
          }
          if ((0, guard_js_1.isReflectList)(val)) {
            return formatReflectList(val.field());
          }
          if ((0, guard_js_1.isReflectMap)(val)) {
            return formatReflectMap(val.field());
          }
          if ((0, guard_js_1.isReflectMessage)(val)) {
            return formatReflectMessage(val.desc);
          }
          if ((0, is_message_js_1.isMessage)(val)) {
            return `message ${val.$typeName}`;
          }
          return "object";
        case "string":
          return val.length > 30 ? "string" : `"${val.split('"').join('\\"')}"`;
        case "boolean":
          return String(val);
        case "number":
          return String(val);
        case "bigint":
          return String(val) + "n";
        default:
          return typeof val;
      }
    }
    function formatReflectMessage(desc) {
      return `ReflectMessage (${desc.typeName})`;
    }
    function formatReflectList(field) {
      switch (field.listKind) {
        case "message":
          return `ReflectList (${field.message.toString()})`;
        case "enum":
          return `ReflectList (${field.enum.toString()})`;
        case "scalar":
          return `ReflectList (${descriptors_js_1.ScalarType[field.scalar]})`;
      }
    }
    function formatReflectMap(field) {
      switch (field.mapKind) {
        case "message":
          return `ReflectMap (${descriptors_js_1.ScalarType[field.mapKey]}, ${field.message.toString()})`;
        case "enum":
          return `ReflectMap (${descriptors_js_1.ScalarType[field.mapKey]}, ${field.enum.toString()})`;
        case "scalar":
          return `ReflectMap (${descriptors_js_1.ScalarType[field.mapKey]}, ${descriptors_js_1.ScalarType[field.scalar]})`;
      }
    }
    function scalarTypeDescription(scalar) {
      switch (scalar) {
        case descriptors_js_1.ScalarType.STRING:
          return "string";
        case descriptors_js_1.ScalarType.BOOL:
          return "boolean";
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SINT64:
        case descriptors_js_1.ScalarType.SFIXED64:
          return "bigint (int64)";
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
          return "bigint (uint64)";
        case descriptors_js_1.ScalarType.BYTES:
          return "Uint8Array";
        case descriptors_js_1.ScalarType.DOUBLE:
          return "number (float64)";
        case descriptors_js_1.ScalarType.FLOAT:
          return "number (float32)";
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
          return "number (uint32)";
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
          return "number (int32)";
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/wrappers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWrapper = isWrapper;
    exports.isWrapperDesc = isWrapperDesc;
    function isWrapper(arg) {
      return isWrapperTypeName(arg.$typeName);
    }
    function isWrapperDesc(messageDesc) {
      const f = messageDesc.fields[0];
      return isWrapperTypeName(messageDesc.typeName) && f !== void 0 && f.fieldKind == "scalar" && f.name == "value" && f.number == 1;
    }
    function isWrapperTypeName(name) {
      return name.startsWith("google.protobuf.") && [
        "DoubleValue",
        "FloatValue",
        "Int64Value",
        "UInt64Value",
        "Int32Value",
        "UInt32Value",
        "BoolValue",
        "StringValue",
        "BytesValue"
      ].includes(name.substring(16));
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/create.js
var require_create = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/create.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = create;
    var is_message_js_1 = require_is_message();
    var descriptors_js_1 = require_descriptors();
    var scalar_js_1 = require_scalar();
    var guard_js_1 = require_guard();
    var unsafe_js_1 = require_unsafe();
    var wrappers_js_1 = require_wrappers();
    var EDITION_PROTO3 = 999;
    var EDITION_PROTO2 = 998;
    var IMPLICIT = 2;
    function create(schema, init) {
      if ((0, is_message_js_1.isMessage)(init, schema)) {
        return init;
      }
      const message = createZeroMessage(schema);
      if (init !== void 0) {
        initMessage(schema, message, init);
      }
      return message;
    }
    function initMessage(messageDesc, message, init) {
      for (const member of messageDesc.members) {
        let value = init[member.localName];
        if (value == null) {
          continue;
        }
        let field;
        if (member.kind == "oneof") {
          const oneofField = (0, unsafe_js_1.unsafeOneofCase)(init, member);
          if (!oneofField) {
            continue;
          }
          field = oneofField;
          value = (0, unsafe_js_1.unsafeGet)(init, oneofField);
        } else {
          field = member;
        }
        switch (field.fieldKind) {
          case "message":
            value = toMessage(field, value);
            break;
          case "scalar":
            value = initScalar(field, value);
            break;
          case "list":
            value = initList(field, value);
            break;
          case "map":
            value = initMap(field, value);
            break;
        }
        (0, unsafe_js_1.unsafeSet)(message, field, value);
      }
      return message;
    }
    function initScalar(field, value) {
      if (field.scalar == descriptors_js_1.ScalarType.BYTES) {
        return toU8Arr(value);
      }
      return value;
    }
    function initMap(field, value) {
      if ((0, guard_js_1.isObject)(value)) {
        if (field.scalar == descriptors_js_1.ScalarType.BYTES) {
          return convertObjectValues(value, toU8Arr);
        }
        if (field.mapKind == "message") {
          return convertObjectValues(value, (val) => toMessage(field, val));
        }
      }
      return value;
    }
    function initList(field, value) {
      if (Array.isArray(value)) {
        if (field.scalar == descriptors_js_1.ScalarType.BYTES) {
          return value.map(toU8Arr);
        }
        if (field.listKind == "message") {
          return value.map((item) => toMessage(field, item));
        }
      }
      return value;
    }
    function toMessage(field, value) {
      if (field.fieldKind == "message" && !field.oneof && (0, wrappers_js_1.isWrapperDesc)(field.message)) {
        return initScalar(field.message.fields[0], value);
      }
      if ((0, guard_js_1.isObject)(value)) {
        if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName !== "google.protobuf.Value") {
          return value;
        }
        if (!(0, is_message_js_1.isMessage)(value, field.message)) {
          return create(field.message, value);
        }
      }
      return value;
    }
    function toU8Arr(value) {
      return Array.isArray(value) ? new Uint8Array(value) : value;
    }
    function convertObjectValues(obj, fn) {
      const ret = {};
      for (const entry of Object.entries(obj)) {
        ret[entry[0]] = fn(entry[1]);
      }
      return ret;
    }
    var tokenZeroMessageField = Symbol();
    var messagePrototypes = /* @__PURE__ */ new WeakMap();
    function createZeroMessage(desc) {
      let msg;
      if (!needsPrototypeChain(desc)) {
        msg = {
          $typeName: desc.typeName
        };
        for (const member of desc.members) {
          if (member.kind == "oneof" || member.presence == IMPLICIT) {
            msg[member.localName] = createZeroField(member);
          }
        }
      } else {
        const cached = messagePrototypes.get(desc);
        let prototype;
        let members;
        if (cached) {
          ({ prototype, members } = cached);
        } else {
          prototype = {};
          members = /* @__PURE__ */ new Set();
          for (const member of desc.members) {
            if (member.kind == "oneof") {
              continue;
            }
            if (member.fieldKind != "scalar" && member.fieldKind != "enum") {
              continue;
            }
            if (member.presence == IMPLICIT) {
              continue;
            }
            members.add(member);
            prototype[member.localName] = createZeroField(member);
          }
          messagePrototypes.set(desc, { prototype, members });
        }
        msg = Object.create(prototype);
        msg.$typeName = desc.typeName;
        for (const member of desc.members) {
          if (members.has(member)) {
            continue;
          }
          if (member.kind == "field") {
            if (member.fieldKind == "message") {
              continue;
            }
            if (member.fieldKind == "scalar" || member.fieldKind == "enum") {
              if (member.presence != IMPLICIT) {
                continue;
              }
            }
          }
          msg[member.localName] = createZeroField(member);
        }
      }
      return msg;
    }
    function needsPrototypeChain(desc) {
      switch (desc.file.edition) {
        case EDITION_PROTO3:
          return false;
        case EDITION_PROTO2:
          return true;
        default:
          return desc.fields.some((f) => f.presence != IMPLICIT && f.fieldKind != "message" && !f.oneof);
      }
    }
    function createZeroField(field) {
      if (field.kind == "oneof") {
        return { case: void 0 };
      }
      if (field.fieldKind == "list") {
        return [];
      }
      if (field.fieldKind == "map") {
        return {};
      }
      if (field.fieldKind == "message") {
        return tokenZeroMessageField;
      }
      const defaultValue = field.getDefaultValue();
      if (defaultValue !== void 0) {
        return field.fieldKind == "scalar" && field.longAsString ? defaultValue.toString() : defaultValue;
      }
      return field.fieldKind == "scalar" ? (0, scalar_js_1.scalarZeroValue)(field.scalar, field.longAsString) : field.enum.values[0].number;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect.js
var require_reflect = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reflect = reflect;
    exports.reflectList = reflectList;
    exports.reflectMap = reflectMap;
    var descriptors_js_1 = require_descriptors();
    var reflect_check_js_1 = require_reflect_check();
    var error_js_1 = require_error();
    var unsafe_js_1 = require_unsafe();
    var create_js_1 = require_create();
    var wrappers_js_1 = require_wrappers();
    var scalar_js_1 = require_scalar();
    var proto_int64_js_1 = require_proto_int64();
    var guard_js_1 = require_guard();
    function reflect(messageDesc, message, check = true) {
      return new ReflectMessageImpl(messageDesc, message, check);
    }
    var ReflectMessageImpl = class {
      get sortedFields() {
        var _a;
        return (_a = this._sortedFields) !== null && _a !== void 0 ? _a : this._sortedFields = this.desc.fields.concat().sort((a, b) => a.number - b.number);
      }
      constructor(messageDesc, message, check = true) {
        this.lists = /* @__PURE__ */ new Map();
        this.maps = /* @__PURE__ */ new Map();
        this.check = check;
        this.desc = messageDesc;
        this.message = this[unsafe_js_1.unsafeLocal] = message !== null && message !== void 0 ? message : (0, create_js_1.create)(messageDesc);
        this.fields = messageDesc.fields;
        this.oneofs = messageDesc.oneofs;
        this.members = messageDesc.members;
      }
      findNumber(number) {
        if (!this._fieldsByNumber) {
          this._fieldsByNumber = new Map(this.desc.fields.map((f) => [f.number, f]));
        }
        return this._fieldsByNumber.get(number);
      }
      oneofCase(oneof) {
        assertOwn(this.message, oneof);
        return (0, unsafe_js_1.unsafeOneofCase)(this.message, oneof);
      }
      isSet(field) {
        assertOwn(this.message, field);
        return (0, unsafe_js_1.unsafeIsSet)(this.message, field);
      }
      clear(field) {
        assertOwn(this.message, field);
        (0, unsafe_js_1.unsafeClear)(this.message, field);
      }
      get(field) {
        assertOwn(this.message, field);
        const value = (0, unsafe_js_1.unsafeGet)(this.message, field);
        switch (field.fieldKind) {
          case "list":
            let list = this.lists.get(field);
            if (!list || list[unsafe_js_1.unsafeLocal] !== value) {
              this.lists.set(field, list = new ReflectListImpl(field, value, this.check));
            }
            return list;
          case "map":
            let map2 = this.maps.get(field);
            if (!map2 || map2[unsafe_js_1.unsafeLocal] !== value) {
              this.maps.set(field, map2 = new ReflectMapImpl(field, value, this.check));
            }
            return map2;
          case "message":
            return messageToReflect(field, value, this.check);
          case "scalar":
            return value === void 0 ? (0, scalar_js_1.scalarZeroValue)(field.scalar, false) : longToReflect(field, value);
          case "enum":
            return value !== null && value !== void 0 ? value : field.enum.values[0].number;
        }
      }
      set(field, value) {
        assertOwn(this.message, field);
        if (this.check) {
          const err = (0, reflect_check_js_1.checkField)(field, value);
          if (err) {
            throw err;
          }
        }
        let local;
        if (field.fieldKind == "message") {
          local = messageToLocal(field, value);
        } else if ((0, guard_js_1.isReflectMap)(value) || (0, guard_js_1.isReflectList)(value)) {
          local = value[unsafe_js_1.unsafeLocal];
        } else {
          local = longToLocal(field, value);
        }
        (0, unsafe_js_1.unsafeSet)(this.message, field, local);
      }
      getUnknown() {
        return this.message.$unknown;
      }
      setUnknown(value) {
        this.message.$unknown = value;
      }
    };
    function assertOwn(owner, member) {
      if (member.parent.typeName !== owner.$typeName) {
        throw new error_js_1.FieldError(member, `cannot use ${member.toString()} with message ${owner.$typeName}`, "ForeignFieldError");
      }
    }
    function reflectList(field, unsafeInput, check = true) {
      return new ReflectListImpl(field, unsafeInput !== null && unsafeInput !== void 0 ? unsafeInput : [], check);
    }
    var ReflectListImpl = class {
      field() {
        return this._field;
      }
      get size() {
        return this._arr.length;
      }
      constructor(field, unsafeInput, check) {
        this._field = field;
        this._arr = this[unsafe_js_1.unsafeLocal] = unsafeInput;
        this.check = check;
      }
      get(index) {
        const item = this._arr[index];
        return item === void 0 ? void 0 : listItemToReflect(this._field, item, this.check);
      }
      set(index, item) {
        if (index < 0 || index >= this._arr.length) {
          throw new error_js_1.FieldError(this._field, `list item #${index + 1}: out of range`);
        }
        if (this.check) {
          const err = (0, reflect_check_js_1.checkListItem)(this._field, index, item);
          if (err) {
            throw err;
          }
        }
        this._arr[index] = listItemToLocal(this._field, item);
      }
      add(item) {
        if (this.check) {
          const err = (0, reflect_check_js_1.checkListItem)(this._field, this._arr.length, item);
          if (err) {
            throw err;
          }
        }
        this._arr.push(listItemToLocal(this._field, item));
        return void 0;
      }
      clear() {
        this._arr.splice(0, this._arr.length);
      }
      [Symbol.iterator]() {
        return this.values();
      }
      keys() {
        return this._arr.keys();
      }
      *values() {
        for (const item of this._arr) {
          yield listItemToReflect(this._field, item, this.check);
        }
      }
      *entries() {
        for (let i = 0; i < this._arr.length; i++) {
          yield [i, listItemToReflect(this._field, this._arr[i], this.check)];
        }
      }
    };
    function reflectMap(field, unsafeInput, check = true) {
      return new ReflectMapImpl(field, unsafeInput, check);
    }
    var ReflectMapImpl = class {
      constructor(field, unsafeInput, check = true) {
        this.obj = this[unsafe_js_1.unsafeLocal] = unsafeInput !== null && unsafeInput !== void 0 ? unsafeInput : {};
        this.check = check;
        this._field = field;
      }
      field() {
        return this._field;
      }
      set(key, value) {
        if (this.check) {
          const err = (0, reflect_check_js_1.checkMapEntry)(this._field, key, value);
          if (err) {
            throw err;
          }
        }
        this.obj[mapKeyToLocal(key)] = mapValueToLocal(this._field, value);
        return this;
      }
      delete(key) {
        const k = mapKeyToLocal(key);
        const has5 = Object.prototype.hasOwnProperty.call(this.obj, k);
        if (has5) {
          delete this.obj[k];
        }
        return has5;
      }
      clear() {
        for (const key of Object.keys(this.obj)) {
          delete this.obj[key];
        }
      }
      get(key) {
        let val = this.obj[mapKeyToLocal(key)];
        if (val !== void 0) {
          val = mapValueToReflect(this._field, val, this.check);
        }
        return val;
      }
      has(key) {
        return Object.prototype.hasOwnProperty.call(this.obj, mapKeyToLocal(key));
      }
      *keys() {
        for (const objKey of Object.keys(this.obj)) {
          yield mapKeyToReflect(objKey, this._field.mapKey);
        }
      }
      *entries() {
        for (const objEntry of Object.entries(this.obj)) {
          yield [
            mapKeyToReflect(objEntry[0], this._field.mapKey),
            mapValueToReflect(this._field, objEntry[1], this.check)
          ];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      get size() {
        return Object.keys(this.obj).length;
      }
      *values() {
        for (const val of Object.values(this.obj)) {
          yield mapValueToReflect(this._field, val, this.check);
        }
      }
      forEach(callbackfn, thisArg) {
        for (const mapEntry of this.entries()) {
          callbackfn.call(thisArg, mapEntry[1], mapEntry[0], this);
        }
      }
    };
    function messageToLocal(field, value) {
      if (!(0, guard_js_1.isReflectMessage)(value)) {
        return value;
      }
      if ((0, wrappers_js_1.isWrapper)(value.message) && !field.oneof && field.fieldKind == "message") {
        return value.message.value;
      }
      if (value.desc.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value") {
        return wktStructToLocal(value.message);
      }
      return value.message;
    }
    function messageToReflect(field, value, check) {
      if (value !== void 0) {
        if ((0, wrappers_js_1.isWrapperDesc)(field.message) && !field.oneof && field.fieldKind == "message") {
          value = {
            $typeName: field.message.typeName,
            value: longToReflect(field.message.fields[0], value)
          };
        } else if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value" && (0, guard_js_1.isObject)(value)) {
          value = wktStructToReflect(value);
        }
      }
      return new ReflectMessageImpl(field.message, value, check);
    }
    function listItemToLocal(field, value) {
      if (field.listKind == "message") {
        return messageToLocal(field, value);
      }
      return longToLocal(field, value);
    }
    function listItemToReflect(field, value, check) {
      if (field.listKind == "message") {
        return messageToReflect(field, value, check);
      }
      return longToReflect(field, value);
    }
    function mapValueToLocal(field, value) {
      if (field.mapKind == "message") {
        return messageToLocal(field, value);
      }
      return longToLocal(field, value);
    }
    function mapValueToReflect(field, value, check) {
      if (field.mapKind == "message") {
        return messageToReflect(field, value, check);
      }
      return value;
    }
    function mapKeyToLocal(key) {
      return typeof key == "string" || typeof key == "number" ? key : String(key);
    }
    function mapKeyToReflect(key, type) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          return key;
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32: {
          const n = Number.parseInt(key);
          if (Number.isFinite(n)) {
            return n;
          }
          break;
        }
        case descriptors_js_1.ScalarType.BOOL:
          switch (key) {
            case "true":
              return true;
            case "false":
              return false;
          }
          break;
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
          try {
            return proto_int64_js_1.protoInt64.uParse(key);
          } catch (_a) {
          }
          break;
        default:
          try {
            return proto_int64_js_1.protoInt64.parse(key);
          } catch (_b) {
          }
          break;
      }
      return key;
    }
    function longToReflect(field, value) {
      switch (field.scalar) {
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          if ("longAsString" in field && field.longAsString && typeof value == "string") {
            value = proto_int64_js_1.protoInt64.parse(value);
          }
          break;
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.UINT64:
          if ("longAsString" in field && field.longAsString && typeof value == "string") {
            value = proto_int64_js_1.protoInt64.uParse(value);
          }
          break;
      }
      return value;
    }
    function longToLocal(field, value) {
      switch (field.scalar) {
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          if ("longAsString" in field && field.longAsString) {
            value = String(value);
          } else if (typeof value == "string" || typeof value == "number") {
            value = proto_int64_js_1.protoInt64.parse(value);
          }
          break;
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.UINT64:
          if ("longAsString" in field && field.longAsString) {
            value = String(value);
          } else if (typeof value == "string" || typeof value == "number") {
            value = proto_int64_js_1.protoInt64.uParse(value);
          }
          break;
      }
      return value;
    }
    function wktStructToReflect(json) {
      const struct = {
        $typeName: "google.protobuf.Struct",
        fields: {}
      };
      if ((0, guard_js_1.isObject)(json)) {
        for (const [k, v] of Object.entries(json)) {
          struct.fields[k] = wktValueToReflect(v);
        }
      }
      return struct;
    }
    function wktStructToLocal(val) {
      const json = {};
      for (const [k, v] of Object.entries(val.fields)) {
        json[k] = wktValueToLocal(v);
      }
      return json;
    }
    function wktValueToLocal(val) {
      switch (val.kind.case) {
        case "structValue":
          return wktStructToLocal(val.kind.value);
        case "listValue":
          return val.kind.value.values.map(wktValueToLocal);
        case "nullValue":
        case void 0:
          return null;
        default:
          return val.kind.value;
      }
    }
    function wktValueToReflect(json) {
      const value = {
        $typeName: "google.protobuf.Value",
        kind: { case: void 0 }
      };
      switch (typeof json) {
        case "number":
          value.kind = { case: "numberValue", value: json };
          break;
        case "string":
          value.kind = { case: "stringValue", value: json };
          break;
        case "boolean":
          value.kind = { case: "boolValue", value: json };
          break;
        case "object":
          if (json === null) {
            const nullValue = 0;
            value.kind = { case: "nullValue", value: nullValue };
          } else if (Array.isArray(json)) {
            const listValue = {
              $typeName: "google.protobuf.ListValue",
              values: []
            };
            if (Array.isArray(json)) {
              for (const e of json) {
                listValue.values.push(wktValueToReflect(e));
              }
            }
            value.kind = {
              case: "listValue",
              value: listValue
            };
          } else {
            value.kind = {
              case: "structValue",
              value: wktStructToReflect(json)
            };
          }
          break;
      }
      return value;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/to-binary.js
var require_to_binary = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/to-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBinary = toBinary;
    exports.writeField = writeField;
    var reflect_js_1 = require_reflect();
    var binary_encoding_js_1 = require_binary_encoding();
    var descriptors_js_1 = require_descriptors();
    var LEGACY_REQUIRED = 3;
    var writeDefaults = {
      writeUnknownFields: true
    };
    function makeWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
    }
    function toBinary(schema, message, options) {
      return writeFields(new binary_encoding_js_1.BinaryWriter(), makeWriteOptions(options), (0, reflect_js_1.reflect)(schema, message)).finish();
    }
    function writeFields(writer, opts, msg) {
      var _a;
      for (const f of msg.sortedFields) {
        if (!msg.isSet(f)) {
          if (f.presence == LEGACY_REQUIRED) {
            throw new Error(`cannot encode field ${msg.desc.typeName}.${f.name} to binary: required field not set`);
          }
          continue;
        }
        writeField(writer, opts, msg, f);
      }
      if (opts.writeUnknownFields) {
        for (const { no, wireType, data } of (_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : []) {
          writer.tag(no, wireType).raw(data);
        }
      }
      return writer;
    }
    function writeField(writer, opts, msg, field) {
      var _a;
      switch (field.fieldKind) {
        case "scalar":
        case "enum":
          writeScalar(writer, (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1.ScalarType.INT32, field.number, msg.get(field));
          break;
        case "list":
          writeListField(writer, opts, field, msg.get(field));
          break;
        case "message":
          writeMessageField(writer, opts, field, msg.get(field));
          break;
        case "map":
          for (const [key, val] of msg.get(field)) {
            writeMapEntry(writer, opts, field, key, val);
          }
          break;
      }
    }
    function writeScalar(writer, scalarType, fieldNo, value) {
      writeScalarValue(writer.tag(fieldNo, writeTypeOfScalar(scalarType)), scalarType, value);
    }
    function writeMessageField(writer, opts, field, message) {
      if (field.delimitedEncoding) {
        writeFields(writer.tag(field.number, binary_encoding_js_1.WireType.StartGroup), opts, message).tag(field.number, binary_encoding_js_1.WireType.EndGroup);
      } else {
        writeFields(writer.tag(field.number, binary_encoding_js_1.WireType.LengthDelimited).fork(), opts, message).join();
      }
    }
    function writeListField(writer, opts, field, list) {
      var _a;
      if (field.listKind == "message") {
        for (const item of list) {
          writeMessageField(writer, opts, field, item);
        }
        return;
      }
      const scalarType = (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1.ScalarType.INT32;
      if (field.packed) {
        if (!list.size) {
          return;
        }
        writer.tag(field.number, binary_encoding_js_1.WireType.LengthDelimited).fork();
        for (const item of list) {
          writeScalarValue(writer, scalarType, item);
        }
        writer.join();
        return;
      }
      for (const item of list) {
        writeScalar(writer, scalarType, field.number, item);
      }
    }
    function writeMapEntry(writer, opts, field, key, value) {
      var _a;
      writer.tag(field.number, binary_encoding_js_1.WireType.LengthDelimited).fork();
      writeScalar(writer, field.mapKey, 1, key);
      switch (field.mapKind) {
        case "scalar":
        case "enum":
          writeScalar(writer, (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1.ScalarType.INT32, 2, value);
          break;
        case "message":
          writeFields(writer.tag(2, binary_encoding_js_1.WireType.LengthDelimited).fork(), opts, value).join();
          break;
      }
      writer.join();
    }
    function writeScalarValue(writer, type, value) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          writer.string(value);
          break;
        case descriptors_js_1.ScalarType.BOOL:
          writer.bool(value);
          break;
        case descriptors_js_1.ScalarType.DOUBLE:
          writer.double(value);
          break;
        case descriptors_js_1.ScalarType.FLOAT:
          writer.float(value);
          break;
        case descriptors_js_1.ScalarType.INT32:
          writer.int32(value);
          break;
        case descriptors_js_1.ScalarType.INT64:
          writer.int64(value);
          break;
        case descriptors_js_1.ScalarType.UINT64:
          writer.uint64(value);
          break;
        case descriptors_js_1.ScalarType.FIXED64:
          writer.fixed64(value);
          break;
        case descriptors_js_1.ScalarType.BYTES:
          writer.bytes(value);
          break;
        case descriptors_js_1.ScalarType.FIXED32:
          writer.fixed32(value);
          break;
        case descriptors_js_1.ScalarType.SFIXED32:
          writer.sfixed32(value);
          break;
        case descriptors_js_1.ScalarType.SFIXED64:
          writer.sfixed64(value);
          break;
        case descriptors_js_1.ScalarType.SINT64:
          writer.sint64(value);
          break;
        case descriptors_js_1.ScalarType.UINT32:
          writer.uint32(value);
          break;
        case descriptors_js_1.ScalarType.SINT32:
          writer.sint32(value);
          break;
      }
    }
    function writeTypeOfScalar(type) {
      switch (type) {
        case descriptors_js_1.ScalarType.BYTES:
        case descriptors_js_1.ScalarType.STRING:
          return binary_encoding_js_1.WireType.LengthDelimited;
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.SFIXED64:
          return binary_encoding_js_1.WireType.Bit64;
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.FLOAT:
          return binary_encoding_js_1.WireType.Bit32;
        default:
          return binary_encoding_js_1.WireType.Varint;
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/clone.js
var require_clone = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/clone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = clone;
    var descriptors_js_1 = require_descriptors();
    var reflect_js_1 = require_reflect();
    var guard_js_1 = require_guard();
    function clone(schema, message) {
      return cloneReflect((0, reflect_js_1.reflect)(schema, message)).message;
    }
    function cloneReflect(i) {
      const o = (0, reflect_js_1.reflect)(i.desc);
      for (const f of i.fields) {
        if (!i.isSet(f)) {
          continue;
        }
        switch (f.fieldKind) {
          default: {
            o.set(f, cloneSingular(f, i.get(f)));
            break;
          }
          case "list":
            const list = o.get(f);
            for (const item of i.get(f)) {
              list.add(cloneSingular(f, item));
            }
            break;
          case "map":
            const map2 = o.get(f);
            for (const entry of i.get(f).entries()) {
              map2.set(entry[0], cloneSingular(f, entry[1]));
            }
            break;
        }
      }
      const unknown = i.getUnknown();
      if (unknown && unknown.length > 0) {
        o.setUnknown([...unknown]);
      }
      return o;
    }
    function cloneSingular(field, value) {
      if (field.message !== void 0 && (0, guard_js_1.isReflectMessage)(value)) {
        return cloneReflect(value);
      }
      if (field.scalar == descriptors_js_1.ScalarType.BYTES && value instanceof Uint8Array) {
        return value.slice();
      }
      return value;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/message.js
var require_message = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.messageDesc = messageDesc;
    function messageDesc(file, path, ...paths) {
      return paths.reduce((acc, cur) => acc.nestedMessages[cur], file.messages[path]);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/enum.js
var require_enum = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumDesc = enumDesc;
    exports.tsEnum = tsEnum;
    function enumDesc(file, path, ...paths) {
      if (paths.length == 0) {
        return file.enums[path];
      }
      const e = paths.pop();
      return paths.reduce((acc, cur) => acc.nestedMessages[cur], file.messages[path]).nestedEnums[e];
    }
    function tsEnum(desc) {
      const enumObject = {};
      for (const value of desc.values) {
        enumObject[value.localName] = value.number;
        enumObject[value.number] = value.localName;
      }
      return enumObject;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/descriptor_pb.js
var require_descriptor_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/descriptor_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FeatureSet_EnumTypeSchema = exports.FeatureSet_EnumType = exports.FeatureSet_FieldPresenceSchema = exports.FeatureSet_FieldPresence = exports.FeatureSetSchema = exports.UninterpretedOption_NamePartSchema = exports.UninterpretedOptionSchema = exports.MethodOptions_IdempotencyLevelSchema = exports.MethodOptions_IdempotencyLevel = exports.MethodOptionsSchema = exports.ServiceOptionsSchema = exports.EnumValueOptionsSchema = exports.EnumOptionsSchema = exports.OneofOptionsSchema = exports.FieldOptions_OptionTargetTypeSchema = exports.FieldOptions_OptionTargetType = exports.FieldOptions_OptionRetentionSchema = exports.FieldOptions_OptionRetention = exports.FieldOptions_JSTypeSchema = exports.FieldOptions_JSType = exports.FieldOptions_CTypeSchema = exports.FieldOptions_CType = exports.FieldOptions_FeatureSupportSchema = exports.FieldOptions_EditionDefaultSchema = exports.FieldOptionsSchema = exports.MessageOptionsSchema = exports.FileOptions_OptimizeModeSchema = exports.FileOptions_OptimizeMode = exports.FileOptionsSchema = exports.MethodDescriptorProtoSchema = exports.ServiceDescriptorProtoSchema = exports.EnumValueDescriptorProtoSchema = exports.EnumDescriptorProto_EnumReservedRangeSchema = exports.EnumDescriptorProtoSchema = exports.OneofDescriptorProtoSchema = exports.FieldDescriptorProto_LabelSchema = exports.FieldDescriptorProto_Label = exports.FieldDescriptorProto_TypeSchema = exports.FieldDescriptorProto_Type = exports.FieldDescriptorProtoSchema = exports.ExtensionRangeOptions_VerificationStateSchema = exports.ExtensionRangeOptions_VerificationState = exports.ExtensionRangeOptions_DeclarationSchema = exports.ExtensionRangeOptionsSchema = exports.DescriptorProto_ReservedRangeSchema = exports.DescriptorProto_ExtensionRangeSchema = exports.DescriptorProtoSchema = exports.FileDescriptorProtoSchema = exports.FileDescriptorSetSchema = exports.file_google_protobuf_descriptor = void 0;
    exports.EditionSchema = exports.Edition = exports.GeneratedCodeInfo_Annotation_SemanticSchema = exports.GeneratedCodeInfo_Annotation_Semantic = exports.GeneratedCodeInfo_AnnotationSchema = exports.GeneratedCodeInfoSchema = exports.SourceCodeInfo_LocationSchema = exports.SourceCodeInfoSchema = exports.FeatureSetDefaults_FeatureSetEditionDefaultSchema = exports.FeatureSetDefaultsSchema = exports.FeatureSet_JsonFormatSchema = exports.FeatureSet_JsonFormat = exports.FeatureSet_MessageEncodingSchema = exports.FeatureSet_MessageEncoding = exports.FeatureSet_Utf8ValidationSchema = exports.FeatureSet_Utf8Validation = exports.FeatureSet_RepeatedFieldEncodingSchema = exports.FeatureSet_RepeatedFieldEncoding = void 0;
    var boot_js_1 = require_boot();
    var message_js_1 = require_message();
    var enum_js_1 = require_enum();
    exports.file_google_protobuf_descriptor = (0, boot_js_1.boot)({ "name": "google/protobuf/descriptor.proto", "package": "google.protobuf", "messageType": [{ "name": "FileDescriptorSet", "field": [{ "name": "file", "number": 1, "type": 11, "label": 3, "typeName": ".google.protobuf.FileDescriptorProto" }] }, { "name": "FileDescriptorProto", "field": [{ "name": "name", "number": 1, "type": 9, "label": 1 }, { "name": "package", "number": 2, "type": 9, "label": 1 }, { "name": "dependency", "number": 3, "type": 9, "label": 3 }, { "name": "public_dependency", "number": 10, "type": 5, "label": 3 }, { "name": "weak_dependency", "number": 11, "type": 5, "label": 3 }, { "name": "message_type", "number": 4, "type": 11, "label": 3, "typeName": ".google.protobuf.DescriptorProto" }, { "name": "enum_type", "number": 5, "type": 11, "label": 3, "typeName": ".google.protobuf.EnumDescriptorProto" }, { "name": "service", "number": 6, "type": 11, "label": 3, "typeName": ".google.protobuf.ServiceDescriptorProto" }, { "name": "extension", "number": 7, "type": 11, "label": 3, "typeName": ".google.protobuf.FieldDescriptorProto" }, { "name": "options", "number": 8, "type": 11, "label": 1, "typeName": ".google.protobuf.FileOptions" }, { "name": "source_code_info", "number": 9, "type": 11, "label": 1, "typeName": ".google.protobuf.SourceCodeInfo" }, { "name": "syntax", "number": 12, "type": 9, "label": 1 }, { "name": "edition", "number": 14, "type": 14, "label": 1, "typeName": ".google.protobuf.Edition" }] }, { "name": "DescriptorProto", "field": [{ "name": "name", "number": 1, "type": 9, "label": 1 }, { "name": "field", "number": 2, "type": 11, "label": 3, "typeName": ".google.protobuf.FieldDescriptorProto" }, { "name": "extension", "number": 6, "type": 11, "label": 3, "typeName": ".google.protobuf.FieldDescriptorProto" }, { "name": "nested_type", "number": 3, "type": 11, "label": 3, "typeName": ".google.protobuf.DescriptorProto" }, { "name": "enum_type", "number": 4, "type": 11, "label": 3, "typeName": ".google.protobuf.EnumDescriptorProto" }, { "name": "extension_range", "number": 5, "type": 11, "label": 3, "typeName": ".google.protobuf.DescriptorProto.ExtensionRange" }, { "name": "oneof_decl", "number": 8, "type": 11, "label": 3, "typeName": ".google.protobuf.OneofDescriptorProto" }, { "name": "options", "number": 7, "type": 11, "label": 1, "typeName": ".google.protobuf.MessageOptions" }, { "name": "reserved_range", "number": 9, "type": 11, "label": 3, "typeName": ".google.protobuf.DescriptorProto.ReservedRange" }, { "name": "reserved_name", "number": 10, "type": 9, "label": 3 }], "nestedType": [{ "name": "ExtensionRange", "field": [{ "name": "start", "number": 1, "type": 5, "label": 1 }, { "name": "end", "number": 2, "type": 5, "label": 1 }, { "name": "options", "number": 3, "type": 11, "label": 1, "typeName": ".google.protobuf.ExtensionRangeOptions" }] }, { "name": "ReservedRange", "field": [{ "name": "start", "number": 1, "type": 5, "label": 1 }, { "name": "end", "number": 2, "type": 5, "label": 1 }] }] }, { "name": "ExtensionRangeOptions", "field": [{ "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }, { "name": "declaration", "number": 2, "type": 11, "label": 3, "typeName": ".google.protobuf.ExtensionRangeOptions.Declaration", "options": { "retention": 2 } }, { "name": "features", "number": 50, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "verification", "number": 3, "type": 14, "label": 1, "typeName": ".google.protobuf.ExtensionRangeOptions.VerificationState", "defaultValue": "UNVERIFIED", "options": { "retention": 2 } }], "nestedType": [{ "name": "Declaration", "field": [{ "name": "number", "number": 1, "type": 5, "label": 1 }, { "name": "full_name", "number": 2, "type": 9, "label": 1 }, { "name": "type", "number": 3, "type": 9, "label": 1 }, { "name": "reserved", "number": 5, "type": 8, "label": 1 }, { "name": "repeated", "number": 6, "type": 8, "label": 1 }] }], "enumType": [{ "name": "VerificationState", "value": [{ "name": "DECLARATION", "number": 0 }, { "name": "UNVERIFIED", "number": 1 }] }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "FieldDescriptorProto", "field": [{ "name": "name", "number": 1, "type": 9, "label": 1 }, { "name": "number", "number": 3, "type": 5, "label": 1 }, { "name": "label", "number": 4, "type": 14, "label": 1, "typeName": ".google.protobuf.FieldDescriptorProto.Label" }, { "name": "type", "number": 5, "type": 14, "label": 1, "typeName": ".google.protobuf.FieldDescriptorProto.Type" }, { "name": "type_name", "number": 6, "type": 9, "label": 1 }, { "name": "extendee", "number": 2, "type": 9, "label": 1 }, { "name": "default_value", "number": 7, "type": 9, "label": 1 }, { "name": "oneof_index", "number": 9, "type": 5, "label": 1 }, { "name": "json_name", "number": 10, "type": 9, "label": 1 }, { "name": "options", "number": 8, "type": 11, "label": 1, "typeName": ".google.protobuf.FieldOptions" }, { "name": "proto3_optional", "number": 17, "type": 8, "label": 1 }], "enumType": [{ "name": "Type", "value": [{ "name": "TYPE_DOUBLE", "number": 1 }, { "name": "TYPE_FLOAT", "number": 2 }, { "name": "TYPE_INT64", "number": 3 }, { "name": "TYPE_UINT64", "number": 4 }, { "name": "TYPE_INT32", "number": 5 }, { "name": "TYPE_FIXED64", "number": 6 }, { "name": "TYPE_FIXED32", "number": 7 }, { "name": "TYPE_BOOL", "number": 8 }, { "name": "TYPE_STRING", "number": 9 }, { "name": "TYPE_GROUP", "number": 10 }, { "name": "TYPE_MESSAGE", "number": 11 }, { "name": "TYPE_BYTES", "number": 12 }, { "name": "TYPE_UINT32", "number": 13 }, { "name": "TYPE_ENUM", "number": 14 }, { "name": "TYPE_SFIXED32", "number": 15 }, { "name": "TYPE_SFIXED64", "number": 16 }, { "name": "TYPE_SINT32", "number": 17 }, { "name": "TYPE_SINT64", "number": 18 }] }, { "name": "Label", "value": [{ "name": "LABEL_OPTIONAL", "number": 1 }, { "name": "LABEL_REPEATED", "number": 3 }, { "name": "LABEL_REQUIRED", "number": 2 }] }] }, { "name": "OneofDescriptorProto", "field": [{ "name": "name", "number": 1, "type": 9, "label": 1 }, { "name": "options", "number": 2, "type": 11, "label": 1, "typeName": ".google.protobuf.OneofOptions" }] }, { "name": "EnumDescriptorProto", "field": [{ "name": "name", "number": 1, "type": 9, "label": 1 }, { "name": "value", "number": 2, "type": 11, "label": 3, "typeName": ".google.protobuf.EnumValueDescriptorProto" }, { "name": "options", "number": 3, "type": 11, "label": 1, "typeName": ".google.protobuf.EnumOptions" }, { "name": "reserved_range", "number": 4, "type": 11, "label": 3, "typeName": ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { "name": "reserved_name", "number": 5, "type": 9, "label": 3 }], "nestedType": [{ "name": "EnumReservedRange", "field": [{ "name": "start", "number": 1, "type": 5, "label": 1 }, { "name": "end", "number": 2, "type": 5, "label": 1 }] }] }, { "name": "EnumValueDescriptorProto", "field": [{ "name": "name", "number": 1, "type": 9, "label": 1 }, { "name": "number", "number": 2, "type": 5, "label": 1 }, { "name": "options", "number": 3, "type": 11, "label": 1, "typeName": ".google.protobuf.EnumValueOptions" }] }, { "name": "ServiceDescriptorProto", "field": [{ "name": "name", "number": 1, "type": 9, "label": 1 }, { "name": "method", "number": 2, "type": 11, "label": 3, "typeName": ".google.protobuf.MethodDescriptorProto" }, { "name": "options", "number": 3, "type": 11, "label": 1, "typeName": ".google.protobuf.ServiceOptions" }] }, { "name": "MethodDescriptorProto", "field": [{ "name": "name", "number": 1, "type": 9, "label": 1 }, { "name": "input_type", "number": 2, "type": 9, "label": 1 }, { "name": "output_type", "number": 3, "type": 9, "label": 1 }, { "name": "options", "number": 4, "type": 11, "label": 1, "typeName": ".google.protobuf.MethodOptions" }, { "name": "client_streaming", "number": 5, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "server_streaming", "number": 6, "type": 8, "label": 1, "defaultValue": "false" }] }, { "name": "FileOptions", "field": [{ "name": "java_package", "number": 1, "type": 9, "label": 1 }, { "name": "java_outer_classname", "number": 8, "type": 9, "label": 1 }, { "name": "java_multiple_files", "number": 10, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "java_generate_equals_and_hash", "number": 20, "type": 8, "label": 1, "options": { "deprecated": true } }, { "name": "java_string_check_utf8", "number": 27, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "optimize_for", "number": 9, "type": 14, "label": 1, "typeName": ".google.protobuf.FileOptions.OptimizeMode", "defaultValue": "SPEED" }, { "name": "go_package", "number": 11, "type": 9, "label": 1 }, { "name": "cc_generic_services", "number": 16, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "java_generic_services", "number": 17, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "py_generic_services", "number": 18, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "deprecated", "number": 23, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "cc_enable_arenas", "number": 31, "type": 8, "label": 1, "defaultValue": "true" }, { "name": "objc_class_prefix", "number": 36, "type": 9, "label": 1 }, { "name": "csharp_namespace", "number": 37, "type": 9, "label": 1 }, { "name": "swift_prefix", "number": 39, "type": 9, "label": 1 }, { "name": "php_class_prefix", "number": 40, "type": 9, "label": 1 }, { "name": "php_namespace", "number": 41, "type": 9, "label": 1 }, { "name": "php_metadata_namespace", "number": 44, "type": 9, "label": 1 }, { "name": "ruby_package", "number": 45, "type": 9, "label": 1 }, { "name": "features", "number": 50, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }], "enumType": [{ "name": "OptimizeMode", "value": [{ "name": "SPEED", "number": 1 }, { "name": "CODE_SIZE", "number": 2 }, { "name": "LITE_RUNTIME", "number": 3 }] }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "MessageOptions", "field": [{ "name": "message_set_wire_format", "number": 1, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "no_standard_descriptor_accessor", "number": 2, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "deprecated", "number": 3, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "map_entry", "number": 7, "type": 8, "label": 1 }, { "name": "deprecated_legacy_json_field_conflicts", "number": 11, "type": 8, "label": 1, "options": { "deprecated": true } }, { "name": "features", "number": 12, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "FieldOptions", "field": [{ "name": "ctype", "number": 1, "type": 14, "label": 1, "typeName": ".google.protobuf.FieldOptions.CType", "defaultValue": "STRING" }, { "name": "packed", "number": 2, "type": 8, "label": 1 }, { "name": "jstype", "number": 6, "type": 14, "label": 1, "typeName": ".google.protobuf.FieldOptions.JSType", "defaultValue": "JS_NORMAL" }, { "name": "lazy", "number": 5, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "unverified_lazy", "number": 15, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "deprecated", "number": 3, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "weak", "number": 10, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "debug_redact", "number": 16, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "retention", "number": 17, "type": 14, "label": 1, "typeName": ".google.protobuf.FieldOptions.OptionRetention" }, { "name": "targets", "number": 19, "type": 14, "label": 3, "typeName": ".google.protobuf.FieldOptions.OptionTargetType" }, { "name": "edition_defaults", "number": 20, "type": 11, "label": 3, "typeName": ".google.protobuf.FieldOptions.EditionDefault" }, { "name": "features", "number": 21, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "feature_support", "number": 22, "type": 11, "label": 1, "typeName": ".google.protobuf.FieldOptions.FeatureSupport" }, { "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }], "nestedType": [{ "name": "EditionDefault", "field": [{ "name": "edition", "number": 3, "type": 14, "label": 1, "typeName": ".google.protobuf.Edition" }, { "name": "value", "number": 2, "type": 9, "label": 1 }] }, { "name": "FeatureSupport", "field": [{ "name": "edition_introduced", "number": 1, "type": 14, "label": 1, "typeName": ".google.protobuf.Edition" }, { "name": "edition_deprecated", "number": 2, "type": 14, "label": 1, "typeName": ".google.protobuf.Edition" }, { "name": "deprecation_warning", "number": 3, "type": 9, "label": 1 }, { "name": "edition_removed", "number": 4, "type": 14, "label": 1, "typeName": ".google.protobuf.Edition" }] }], "enumType": [{ "name": "CType", "value": [{ "name": "STRING", "number": 0 }, { "name": "CORD", "number": 1 }, { "name": "STRING_PIECE", "number": 2 }] }, { "name": "JSType", "value": [{ "name": "JS_NORMAL", "number": 0 }, { "name": "JS_STRING", "number": 1 }, { "name": "JS_NUMBER", "number": 2 }] }, { "name": "OptionRetention", "value": [{ "name": "RETENTION_UNKNOWN", "number": 0 }, { "name": "RETENTION_RUNTIME", "number": 1 }, { "name": "RETENTION_SOURCE", "number": 2 }] }, { "name": "OptionTargetType", "value": [{ "name": "TARGET_TYPE_UNKNOWN", "number": 0 }, { "name": "TARGET_TYPE_FILE", "number": 1 }, { "name": "TARGET_TYPE_EXTENSION_RANGE", "number": 2 }, { "name": "TARGET_TYPE_MESSAGE", "number": 3 }, { "name": "TARGET_TYPE_FIELD", "number": 4 }, { "name": "TARGET_TYPE_ONEOF", "number": 5 }, { "name": "TARGET_TYPE_ENUM", "number": 6 }, { "name": "TARGET_TYPE_ENUM_ENTRY", "number": 7 }, { "name": "TARGET_TYPE_SERVICE", "number": 8 }, { "name": "TARGET_TYPE_METHOD", "number": 9 }] }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "OneofOptions", "field": [{ "name": "features", "number": 1, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "EnumOptions", "field": [{ "name": "allow_alias", "number": 2, "type": 8, "label": 1 }, { "name": "deprecated", "number": 3, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "deprecated_legacy_json_field_conflicts", "number": 6, "type": 8, "label": 1, "options": { "deprecated": true } }, { "name": "features", "number": 7, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "EnumValueOptions", "field": [{ "name": "deprecated", "number": 1, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "features", "number": 2, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "debug_redact", "number": 3, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "feature_support", "number": 4, "type": 11, "label": 1, "typeName": ".google.protobuf.FieldOptions.FeatureSupport" }, { "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "ServiceOptions", "field": [{ "name": "features", "number": 34, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "deprecated", "number": 33, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "MethodOptions", "field": [{ "name": "deprecated", "number": 33, "type": 8, "label": 1, "defaultValue": "false" }, { "name": "idempotency_level", "number": 34, "type": 14, "label": 1, "typeName": ".google.protobuf.MethodOptions.IdempotencyLevel", "defaultValue": "IDEMPOTENCY_UNKNOWN" }, { "name": "features", "number": 35, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "uninterpreted_option", "number": 999, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption" }], "enumType": [{ "name": "IdempotencyLevel", "value": [{ "name": "IDEMPOTENCY_UNKNOWN", "number": 0 }, { "name": "NO_SIDE_EFFECTS", "number": 1 }, { "name": "IDEMPOTENT", "number": 2 }] }], "extensionRange": [{ "start": 1e3, "end": 536870912 }] }, { "name": "UninterpretedOption", "field": [{ "name": "name", "number": 2, "type": 11, "label": 3, "typeName": ".google.protobuf.UninterpretedOption.NamePart" }, { "name": "identifier_value", "number": 3, "type": 9, "label": 1 }, { "name": "positive_int_value", "number": 4, "type": 4, "label": 1 }, { "name": "negative_int_value", "number": 5, "type": 3, "label": 1 }, { "name": "double_value", "number": 6, "type": 1, "label": 1 }, { "name": "string_value", "number": 7, "type": 12, "label": 1 }, { "name": "aggregate_value", "number": 8, "type": 9, "label": 1 }], "nestedType": [{ "name": "NamePart", "field": [{ "name": "name_part", "number": 1, "type": 9, "label": 2 }, { "name": "is_extension", "number": 2, "type": 8, "label": 2 }] }] }, { "name": "FeatureSet", "field": [{ "name": "field_presence", "number": 1, "type": 14, "label": 1, "typeName": ".google.protobuf.FeatureSet.FieldPresence", "options": { "retention": 1, "targets": [4, 1], "editionDefaults": [{ "value": "EXPLICIT", "edition": 900 }, { "value": "IMPLICIT", "edition": 999 }, { "value": "EXPLICIT", "edition": 1e3 }] } }, { "name": "enum_type", "number": 2, "type": 14, "label": 1, "typeName": ".google.protobuf.FeatureSet.EnumType", "options": { "retention": 1, "targets": [6, 1], "editionDefaults": [{ "value": "CLOSED", "edition": 900 }, { "value": "OPEN", "edition": 999 }] } }, { "name": "repeated_field_encoding", "number": 3, "type": 14, "label": 1, "typeName": ".google.protobuf.FeatureSet.RepeatedFieldEncoding", "options": { "retention": 1, "targets": [4, 1], "editionDefaults": [{ "value": "EXPANDED", "edition": 900 }, { "value": "PACKED", "edition": 999 }] } }, { "name": "utf8_validation", "number": 4, "type": 14, "label": 1, "typeName": ".google.protobuf.FeatureSet.Utf8Validation", "options": { "retention": 1, "targets": [4, 1], "editionDefaults": [{ "value": "NONE", "edition": 900 }, { "value": "VERIFY", "edition": 999 }] } }, { "name": "message_encoding", "number": 5, "type": 14, "label": 1, "typeName": ".google.protobuf.FeatureSet.MessageEncoding", "options": { "retention": 1, "targets": [4, 1], "editionDefaults": [{ "value": "LENGTH_PREFIXED", "edition": 900 }] } }, { "name": "json_format", "number": 6, "type": 14, "label": 1, "typeName": ".google.protobuf.FeatureSet.JsonFormat", "options": { "retention": 1, "targets": [3, 6, 1], "editionDefaults": [{ "value": "LEGACY_BEST_EFFORT", "edition": 900 }, { "value": "ALLOW", "edition": 999 }] } }], "enumType": [{ "name": "FieldPresence", "value": [{ "name": "FIELD_PRESENCE_UNKNOWN", "number": 0 }, { "name": "EXPLICIT", "number": 1 }, { "name": "IMPLICIT", "number": 2 }, { "name": "LEGACY_REQUIRED", "number": 3 }] }, { "name": "EnumType", "value": [{ "name": "ENUM_TYPE_UNKNOWN", "number": 0 }, { "name": "OPEN", "number": 1 }, { "name": "CLOSED", "number": 2 }] }, { "name": "RepeatedFieldEncoding", "value": [{ "name": "REPEATED_FIELD_ENCODING_UNKNOWN", "number": 0 }, { "name": "PACKED", "number": 1 }, { "name": "EXPANDED", "number": 2 }] }, { "name": "Utf8Validation", "value": [{ "name": "UTF8_VALIDATION_UNKNOWN", "number": 0 }, { "name": "VERIFY", "number": 2 }, { "name": "NONE", "number": 3 }] }, { "name": "MessageEncoding", "value": [{ "name": "MESSAGE_ENCODING_UNKNOWN", "number": 0 }, { "name": "LENGTH_PREFIXED", "number": 1 }, { "name": "DELIMITED", "number": 2 }] }, { "name": "JsonFormat", "value": [{ "name": "JSON_FORMAT_UNKNOWN", "number": 0 }, { "name": "ALLOW", "number": 1 }, { "name": "LEGACY_BEST_EFFORT", "number": 2 }] }], "extensionRange": [{ "start": 1e3, "end": 9995 }, { "start": 9995, "end": 1e4 }, { "start": 1e4, "end": 10001 }] }, { "name": "FeatureSetDefaults", "field": [{ "name": "defaults", "number": 1, "type": 11, "label": 3, "typeName": ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { "name": "minimum_edition", "number": 4, "type": 14, "label": 1, "typeName": ".google.protobuf.Edition" }, { "name": "maximum_edition", "number": 5, "type": 14, "label": 1, "typeName": ".google.protobuf.Edition" }], "nestedType": [{ "name": "FeatureSetEditionDefault", "field": [{ "name": "edition", "number": 3, "type": 14, "label": 1, "typeName": ".google.protobuf.Edition" }, { "name": "overridable_features", "number": 4, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }, { "name": "fixed_features", "number": 5, "type": 11, "label": 1, "typeName": ".google.protobuf.FeatureSet" }] }] }, { "name": "SourceCodeInfo", "field": [{ "name": "location", "number": 1, "type": 11, "label": 3, "typeName": ".google.protobuf.SourceCodeInfo.Location" }], "nestedType": [{ "name": "Location", "field": [{ "name": "path", "number": 1, "type": 5, "label": 3, "options": { "packed": true } }, { "name": "span", "number": 2, "type": 5, "label": 3, "options": { "packed": true } }, { "name": "leading_comments", "number": 3, "type": 9, "label": 1 }, { "name": "trailing_comments", "number": 4, "type": 9, "label": 1 }, { "name": "leading_detached_comments", "number": 6, "type": 9, "label": 3 }] }] }, { "name": "GeneratedCodeInfo", "field": [{ "name": "annotation", "number": 1, "type": 11, "label": 3, "typeName": ".google.protobuf.GeneratedCodeInfo.Annotation" }], "nestedType": [{ "name": "Annotation", "field": [{ "name": "path", "number": 1, "type": 5, "label": 3, "options": { "packed": true } }, { "name": "source_file", "number": 2, "type": 9, "label": 1 }, { "name": "begin", "number": 3, "type": 5, "label": 1 }, { "name": "end", "number": 4, "type": 5, "label": 1 }, { "name": "semantic", "number": 5, "type": 14, "label": 1, "typeName": ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], "enumType": [{ "name": "Semantic", "value": [{ "name": "NONE", "number": 0 }, { "name": "SET", "number": 1 }, { "name": "ALIAS", "number": 2 }] }] }] }], "enumType": [{ "name": "Edition", "value": [{ "name": "EDITION_UNKNOWN", "number": 0 }, { "name": "EDITION_LEGACY", "number": 900 }, { "name": "EDITION_PROTO2", "number": 998 }, { "name": "EDITION_PROTO3", "number": 999 }, { "name": "EDITION_2023", "number": 1e3 }, { "name": "EDITION_2024", "number": 1001 }, { "name": "EDITION_1_TEST_ONLY", "number": 1 }, { "name": "EDITION_2_TEST_ONLY", "number": 2 }, { "name": "EDITION_99997_TEST_ONLY", "number": 99997 }, { "name": "EDITION_99998_TEST_ONLY", "number": 99998 }, { "name": "EDITION_99999_TEST_ONLY", "number": 99999 }, { "name": "EDITION_MAX", "number": 2147483647 }] }] });
    exports.FileDescriptorSetSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 0);
    exports.FileDescriptorProtoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 1);
    exports.DescriptorProtoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 2);
    exports.DescriptorProto_ExtensionRangeSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 2, 0);
    exports.DescriptorProto_ReservedRangeSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 2, 1);
    exports.ExtensionRangeOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 3);
    exports.ExtensionRangeOptions_DeclarationSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 3, 0);
    var ExtensionRangeOptions_VerificationState;
    (function(ExtensionRangeOptions_VerificationState2) {
      ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["DECLARATION"] = 0] = "DECLARATION";
      ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["UNVERIFIED"] = 1] = "UNVERIFIED";
    })(ExtensionRangeOptions_VerificationState || (exports.ExtensionRangeOptions_VerificationState = ExtensionRangeOptions_VerificationState = {}));
    exports.ExtensionRangeOptions_VerificationStateSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 3, 0);
    exports.FieldDescriptorProtoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 4);
    var FieldDescriptorProto_Type;
    (function(FieldDescriptorProto_Type2) {
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["DOUBLE"] = 1] = "DOUBLE";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FLOAT"] = 2] = "FLOAT";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT64"] = 3] = "INT64";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT64"] = 4] = "UINT64";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT32"] = 5] = "INT32";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED64"] = 6] = "FIXED64";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED32"] = 7] = "FIXED32";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BOOL"] = 8] = "BOOL";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["STRING"] = 9] = "STRING";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["GROUP"] = 10] = "GROUP";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["MESSAGE"] = 11] = "MESSAGE";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BYTES"] = 12] = "BYTES";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT32"] = 13] = "UINT32";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["ENUM"] = 14] = "ENUM";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED32"] = 15] = "SFIXED32";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED64"] = 16] = "SFIXED64";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT32"] = 17] = "SINT32";
      FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT64"] = 18] = "SINT64";
    })(FieldDescriptorProto_Type || (exports.FieldDescriptorProto_Type = FieldDescriptorProto_Type = {}));
    exports.FieldDescriptorProto_TypeSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 4, 0);
    var FieldDescriptorProto_Label;
    (function(FieldDescriptorProto_Label2) {
      FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["OPTIONAL"] = 1] = "OPTIONAL";
      FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REPEATED"] = 3] = "REPEATED";
      FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REQUIRED"] = 2] = "REQUIRED";
    })(FieldDescriptorProto_Label || (exports.FieldDescriptorProto_Label = FieldDescriptorProto_Label = {}));
    exports.FieldDescriptorProto_LabelSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 4, 1);
    exports.OneofDescriptorProtoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 5);
    exports.EnumDescriptorProtoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 6);
    exports.EnumDescriptorProto_EnumReservedRangeSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 6, 0);
    exports.EnumValueDescriptorProtoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 7);
    exports.ServiceDescriptorProtoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 8);
    exports.MethodDescriptorProtoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 9);
    exports.FileOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 10);
    var FileOptions_OptimizeMode;
    (function(FileOptions_OptimizeMode2) {
      FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
      FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
      FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
    })(FileOptions_OptimizeMode || (exports.FileOptions_OptimizeMode = FileOptions_OptimizeMode = {}));
    exports.FileOptions_OptimizeModeSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 10, 0);
    exports.MessageOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 11);
    exports.FieldOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 12);
    exports.FieldOptions_EditionDefaultSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 12, 0);
    exports.FieldOptions_FeatureSupportSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 12, 1);
    var FieldOptions_CType;
    (function(FieldOptions_CType2) {
      FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
      FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
      FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
    })(FieldOptions_CType || (exports.FieldOptions_CType = FieldOptions_CType = {}));
    exports.FieldOptions_CTypeSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 12, 0);
    var FieldOptions_JSType;
    (function(FieldOptions_JSType2) {
      FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
      FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
      FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
    })(FieldOptions_JSType || (exports.FieldOptions_JSType = FieldOptions_JSType = {}));
    exports.FieldOptions_JSTypeSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 12, 1);
    var FieldOptions_OptionRetention;
    (function(FieldOptions_OptionRetention2) {
      FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
      FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
      FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
    })(FieldOptions_OptionRetention || (exports.FieldOptions_OptionRetention = FieldOptions_OptionRetention = {}));
    exports.FieldOptions_OptionRetentionSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 12, 2);
    var FieldOptions_OptionTargetType;
    (function(FieldOptions_OptionTargetType2) {
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
      FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
    })(FieldOptions_OptionTargetType || (exports.FieldOptions_OptionTargetType = FieldOptions_OptionTargetType = {}));
    exports.FieldOptions_OptionTargetTypeSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 12, 3);
    exports.OneofOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 13);
    exports.EnumOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 14);
    exports.EnumValueOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 15);
    exports.ServiceOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 16);
    exports.MethodOptionsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 17);
    var MethodOptions_IdempotencyLevel;
    (function(MethodOptions_IdempotencyLevel2) {
      MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
      MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
      MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
    })(MethodOptions_IdempotencyLevel || (exports.MethodOptions_IdempotencyLevel = MethodOptions_IdempotencyLevel = {}));
    exports.MethodOptions_IdempotencyLevelSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 17, 0);
    exports.UninterpretedOptionSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 18);
    exports.UninterpretedOption_NamePartSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 18, 0);
    exports.FeatureSetSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 19);
    var FeatureSet_FieldPresence;
    (function(FeatureSet_FieldPresence2) {
      FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["FIELD_PRESENCE_UNKNOWN"] = 0] = "FIELD_PRESENCE_UNKNOWN";
      FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["EXPLICIT"] = 1] = "EXPLICIT";
      FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["IMPLICIT"] = 2] = "IMPLICIT";
      FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["LEGACY_REQUIRED"] = 3] = "LEGACY_REQUIRED";
    })(FeatureSet_FieldPresence || (exports.FeatureSet_FieldPresence = FeatureSet_FieldPresence = {}));
    exports.FeatureSet_FieldPresenceSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 19, 0);
    var FeatureSet_EnumType;
    (function(FeatureSet_EnumType2) {
      FeatureSet_EnumType2[FeatureSet_EnumType2["ENUM_TYPE_UNKNOWN"] = 0] = "ENUM_TYPE_UNKNOWN";
      FeatureSet_EnumType2[FeatureSet_EnumType2["OPEN"] = 1] = "OPEN";
      FeatureSet_EnumType2[FeatureSet_EnumType2["CLOSED"] = 2] = "CLOSED";
    })(FeatureSet_EnumType || (exports.FeatureSet_EnumType = FeatureSet_EnumType = {}));
    exports.FeatureSet_EnumTypeSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 19, 1);
    var FeatureSet_RepeatedFieldEncoding;
    (function(FeatureSet_RepeatedFieldEncoding2) {
      FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["REPEATED_FIELD_ENCODING_UNKNOWN"] = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN";
      FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["PACKED"] = 1] = "PACKED";
      FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["EXPANDED"] = 2] = "EXPANDED";
    })(FeatureSet_RepeatedFieldEncoding || (exports.FeatureSet_RepeatedFieldEncoding = FeatureSet_RepeatedFieldEncoding = {}));
    exports.FeatureSet_RepeatedFieldEncodingSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 19, 2);
    var FeatureSet_Utf8Validation;
    (function(FeatureSet_Utf8Validation2) {
      FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["UTF8_VALIDATION_UNKNOWN"] = 0] = "UTF8_VALIDATION_UNKNOWN";
      FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["VERIFY"] = 2] = "VERIFY";
      FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["NONE"] = 3] = "NONE";
    })(FeatureSet_Utf8Validation || (exports.FeatureSet_Utf8Validation = FeatureSet_Utf8Validation = {}));
    exports.FeatureSet_Utf8ValidationSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 19, 3);
    var FeatureSet_MessageEncoding;
    (function(FeatureSet_MessageEncoding2) {
      FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["MESSAGE_ENCODING_UNKNOWN"] = 0] = "MESSAGE_ENCODING_UNKNOWN";
      FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["LENGTH_PREFIXED"] = 1] = "LENGTH_PREFIXED";
      FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["DELIMITED"] = 2] = "DELIMITED";
    })(FeatureSet_MessageEncoding || (exports.FeatureSet_MessageEncoding = FeatureSet_MessageEncoding = {}));
    exports.FeatureSet_MessageEncodingSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 19, 4);
    var FeatureSet_JsonFormat;
    (function(FeatureSet_JsonFormat2) {
      FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["JSON_FORMAT_UNKNOWN"] = 0] = "JSON_FORMAT_UNKNOWN";
      FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["ALLOW"] = 1] = "ALLOW";
      FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["LEGACY_BEST_EFFORT"] = 2] = "LEGACY_BEST_EFFORT";
    })(FeatureSet_JsonFormat || (exports.FeatureSet_JsonFormat = FeatureSet_JsonFormat = {}));
    exports.FeatureSet_JsonFormatSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 19, 5);
    exports.FeatureSetDefaultsSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 20);
    exports.FeatureSetDefaults_FeatureSetEditionDefaultSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 20, 0);
    exports.SourceCodeInfoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 21);
    exports.SourceCodeInfo_LocationSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 21, 0);
    exports.GeneratedCodeInfoSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 22);
    exports.GeneratedCodeInfo_AnnotationSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_descriptor, 22, 0);
    var GeneratedCodeInfo_Annotation_Semantic;
    (function(GeneratedCodeInfo_Annotation_Semantic2) {
      GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
      GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
      GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
    })(GeneratedCodeInfo_Annotation_Semantic || (exports.GeneratedCodeInfo_Annotation_Semantic = GeneratedCodeInfo_Annotation_Semantic = {}));
    exports.GeneratedCodeInfo_Annotation_SemanticSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 22, 0, 0);
    var Edition;
    (function(Edition2) {
      Edition2[Edition2["EDITION_UNKNOWN"] = 0] = "EDITION_UNKNOWN";
      Edition2[Edition2["EDITION_LEGACY"] = 900] = "EDITION_LEGACY";
      Edition2[Edition2["EDITION_PROTO2"] = 998] = "EDITION_PROTO2";
      Edition2[Edition2["EDITION_PROTO3"] = 999] = "EDITION_PROTO3";
      Edition2[Edition2["EDITION_2023"] = 1e3] = "EDITION_2023";
      Edition2[Edition2["EDITION_2024"] = 1001] = "EDITION_2024";
      Edition2[Edition2["EDITION_1_TEST_ONLY"] = 1] = "EDITION_1_TEST_ONLY";
      Edition2[Edition2["EDITION_2_TEST_ONLY"] = 2] = "EDITION_2_TEST_ONLY";
      Edition2[Edition2["EDITION_99997_TEST_ONLY"] = 99997] = "EDITION_99997_TEST_ONLY";
      Edition2[Edition2["EDITION_99998_TEST_ONLY"] = 99998] = "EDITION_99998_TEST_ONLY";
      Edition2[Edition2["EDITION_99999_TEST_ONLY"] = 99999] = "EDITION_99999_TEST_ONLY";
      Edition2[Edition2["EDITION_MAX"] = 2147483647] = "EDITION_MAX";
    })(Edition || (exports.Edition = Edition = {}));
    exports.EditionSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_descriptor, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/embed.js
var require_embed = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/embed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.embedFileDesc = embedFileDesc;
    exports.pathInFileDesc = pathInFileDesc;
    exports.createFileDescriptorProtoBoot = createFileDescriptorProtoBoot;
    var names_js_1 = require_names();
    var fields_js_1 = require_fields();
    var base64_encoding_js_1 = require_base64_encoding();
    var to_binary_js_1 = require_to_binary();
    var clone_js_1 = require_clone();
    var descriptor_pb_js_1 = require_descriptor_pb();
    function embedFileDesc(file) {
      const embed = {
        bootable: false,
        proto() {
          const stripped = (0, clone_js_1.clone)(descriptor_pb_js_1.FileDescriptorProtoSchema, file);
          (0, fields_js_1.clearField)(stripped, descriptor_pb_js_1.FileDescriptorProtoSchema.field.dependency);
          (0, fields_js_1.clearField)(stripped, descriptor_pb_js_1.FileDescriptorProtoSchema.field.sourceCodeInfo);
          stripped.messageType.map(stripJsonNames);
          return stripped;
        },
        base64() {
          const bytes = (0, to_binary_js_1.toBinary)(descriptor_pb_js_1.FileDescriptorProtoSchema, this.proto());
          return (0, base64_encoding_js_1.base64Encode)(bytes, "std_raw");
        }
      };
      return file.name == "google/protobuf/descriptor.proto" ? Object.assign(Object.assign({}, embed), { bootable: true, boot() {
        return createFileDescriptorProtoBoot(this.proto());
      } }) : embed;
    }
    function stripJsonNames(d) {
      for (const f of d.field) {
        if (f.jsonName === (0, names_js_1.protoCamelCase)(f.name)) {
          (0, fields_js_1.clearField)(f, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.jsonName);
        }
      }
      for (const n of d.nestedType) {
        stripJsonNames(n);
      }
    }
    function pathInFileDesc(desc) {
      if (desc.kind == "service") {
        return [desc.file.services.indexOf(desc)];
      }
      const parent = desc.parent;
      if (parent == void 0) {
        switch (desc.kind) {
          case "enum":
            return [desc.file.enums.indexOf(desc)];
          case "message":
            return [desc.file.messages.indexOf(desc)];
          case "extension":
            return [desc.file.extensions.indexOf(desc)];
        }
      }
      function findPath(cur) {
        const nested = [];
        for (let parent2 = cur.parent; parent2; ) {
          const idx = parent2.nestedMessages.indexOf(cur);
          nested.unshift(idx);
          cur = parent2;
          parent2 = cur.parent;
        }
        nested.unshift(cur.file.messages.indexOf(cur));
        return nested;
      }
      const path = findPath(parent);
      switch (desc.kind) {
        case "extension":
          return [...path, parent.nestedExtensions.indexOf(desc)];
        case "message":
          return [...path, parent.nestedMessages.indexOf(desc)];
        case "enum":
          return [...path, parent.nestedEnums.indexOf(desc)];
      }
    }
    function createFileDescriptorProtoBoot(proto) {
      var _a;
      assert(proto.name == "google/protobuf/descriptor.proto");
      assert(proto.package == "google.protobuf");
      assert(!proto.dependency.length);
      assert(!proto.publicDependency.length);
      assert(!proto.weakDependency.length);
      assert(!proto.service.length);
      assert(!proto.extension.length);
      assert(proto.sourceCodeInfo === void 0);
      assert(proto.syntax == "" || proto.syntax == "proto2");
      assert(!((_a = proto.options) === null || _a === void 0 ? void 0 : _a.features));
      assert(proto.edition === descriptor_pb_js_1.Edition.EDITION_UNKNOWN);
      return {
        name: proto.name,
        package: proto.package,
        messageType: proto.messageType.map(createDescriptorBoot),
        enumType: proto.enumType.map(createEnumDescriptorBoot)
      };
    }
    function createDescriptorBoot(proto) {
      assert(proto.extension.length == 0);
      assert(!proto.oneofDecl.length);
      assert(!proto.options);
      const b = {
        name: proto.name
      };
      if (proto.field.length) {
        b.field = proto.field.map(createFieldDescriptorBoot);
      }
      if (proto.nestedType.length) {
        b.nestedType = proto.nestedType.map(createDescriptorBoot);
      }
      if (proto.enumType.length) {
        b.enumType = proto.enumType.map(createEnumDescriptorBoot);
      }
      if (proto.extensionRange.length) {
        b.extensionRange = proto.extensionRange.map((r) => {
          assert(!r.options);
          return { start: r.start, end: r.end };
        });
      }
      return b;
    }
    function createFieldDescriptorBoot(proto) {
      assert((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.name));
      assert((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.number));
      assert((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.type));
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.oneofIndex));
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.jsonName) || proto.jsonName === (0, names_js_1.protoCamelCase)(proto.name));
      const b = {
        name: proto.name,
        number: proto.number,
        type: proto.type
      };
      if ((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.label)) {
        b.label = proto.label;
      }
      if ((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.typeName)) {
        b.typeName = proto.typeName;
      }
      if ((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.extendee)) {
        b.extendee = proto.extendee;
      }
      if ((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldDescriptorProtoSchema.field.defaultValue)) {
        b.defaultValue = proto.defaultValue;
      }
      if (proto.options) {
        b.options = createFieldOptionsBoot(proto.options);
      }
      return b;
    }
    function createFieldOptionsBoot(proto) {
      const b = {};
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.ctype));
      if ((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.packed)) {
        b.packed = proto.packed;
      }
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.jstype));
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.lazy));
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.unverifiedLazy));
      if ((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.deprecated)) {
        b.deprecated = proto.deprecated;
      }
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.weak));
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.debugRedact));
      if ((0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.retention)) {
        b.retention = proto.retention;
      }
      if (proto.targets.length) {
        b.targets = proto.targets;
      }
      if (proto.editionDefaults.length) {
        b.editionDefaults = proto.editionDefaults.map((d) => ({
          value: d.value,
          edition: d.edition
        }));
      }
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.features));
      assert(!(0, fields_js_1.isFieldSet)(proto, descriptor_pb_js_1.FieldOptionsSchema.field.uninterpretedOption));
      return b;
    }
    function createEnumDescriptorBoot(proto) {
      assert(!proto.options);
      return {
        name: proto.name,
        value: proto.value.map((v) => {
          assert(!v.options);
          return {
            name: v.name,
            number: v.number
          };
        })
      };
    }
    function assert(condition) {
      if (!condition) {
        throw new Error();
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/extension.js
var require_extension = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/extension.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extDesc = extDesc;
    function extDesc(file, path, ...paths) {
      if (paths.length == 0) {
        return file.extensions[path];
      }
      const e = paths.pop();
      return paths.reduce((acc, cur) => acc.nestedMessages[cur], file.messages[path]).nestedExtensions[e];
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/from-binary.js
var require_from_binary = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/from-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromBinary = fromBinary;
    exports.mergeFromBinary = mergeFromBinary;
    exports.readField = readField;
    var descriptors_js_1 = require_descriptors();
    var scalar_js_1 = require_scalar();
    var reflect_js_1 = require_reflect();
    var binary_encoding_js_1 = require_binary_encoding();
    var readDefaults = {
      readUnknownFields: true
    };
    function makeReadOptions(options) {
      return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
    }
    function fromBinary(schema, bytes, options) {
      const msg = (0, reflect_js_1.reflect)(schema, void 0, false);
      readMessage(msg, new binary_encoding_js_1.BinaryReader(bytes), makeReadOptions(options), false, bytes.byteLength);
      return msg.message;
    }
    function mergeFromBinary(schema, target, bytes, options) {
      readMessage((0, reflect_js_1.reflect)(schema, target, false), new binary_encoding_js_1.BinaryReader(bytes), makeReadOptions(options), false, bytes.byteLength);
      return target;
    }
    function readMessage(message, reader, options, delimited, lengthOrDelimitedFieldNo) {
      var _a;
      const end = delimited ? reader.len : reader.pos + lengthOrDelimitedFieldNo;
      let fieldNo, wireType;
      const unknownFields = (_a = message.getUnknown()) !== null && _a !== void 0 ? _a : [];
      while (reader.pos < end) {
        [fieldNo, wireType] = reader.tag();
        if (delimited && wireType == binary_encoding_js_1.WireType.EndGroup) {
          break;
        }
        const field = message.findNumber(fieldNo);
        if (!field) {
          const data = reader.skip(wireType, fieldNo);
          if (options.readUnknownFields) {
            unknownFields.push({ no: fieldNo, wireType, data });
          }
          continue;
        }
        readField(message, reader, field, wireType, options);
      }
      if (delimited) {
        if (wireType != binary_encoding_js_1.WireType.EndGroup || fieldNo !== lengthOrDelimitedFieldNo) {
          throw new Error(`invalid end group tag`);
        }
      }
      if (unknownFields.length > 0) {
        message.setUnknown(unknownFields);
      }
    }
    function readField(message, reader, field, wireType, options) {
      switch (field.fieldKind) {
        case "scalar":
          message.set(field, readScalar(reader, field.scalar));
          break;
        case "enum":
          message.set(field, readScalar(reader, descriptors_js_1.ScalarType.INT32));
          break;
        case "message":
          message.set(field, readMessageField(reader, options, field, message.get(field)));
          break;
        case "list":
          readListField(reader, wireType, message.get(field), options);
          break;
        case "map":
          readMapEntry(reader, message.get(field), options);
          break;
      }
    }
    function readMapEntry(reader, map2, options) {
      const field = map2.field();
      let key, val;
      const end = reader.pos + reader.uint32();
      while (reader.pos < end) {
        const [fieldNo] = reader.tag();
        switch (fieldNo) {
          case 1:
            key = readScalar(reader, field.mapKey);
            break;
          case 2:
            switch (field.mapKind) {
              case "scalar":
                val = readScalar(reader, field.scalar);
                break;
              case "enum":
                val = reader.int32();
                break;
              case "message":
                val = readMessageField(reader, options, field);
                break;
            }
            break;
        }
      }
      if (key === void 0) {
        key = (0, scalar_js_1.scalarZeroValue)(field.mapKey, false);
      }
      if (val === void 0) {
        switch (field.mapKind) {
          case "scalar":
            val = (0, scalar_js_1.scalarZeroValue)(field.scalar, false);
            break;
          case "enum":
            val = field.enum.values[0].number;
            break;
          case "message":
            val = (0, reflect_js_1.reflect)(field.message, void 0, false);
            break;
        }
      }
      map2.set(key, val);
    }
    function readListField(reader, wireType, list, options) {
      var _a;
      const field = list.field();
      if (field.listKind === "message") {
        list.add(readMessageField(reader, options, field));
        return;
      }
      const scalarType = (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1.ScalarType.INT32;
      const packed = wireType == binary_encoding_js_1.WireType.LengthDelimited && scalarType != descriptors_js_1.ScalarType.STRING && scalarType != descriptors_js_1.ScalarType.BYTES;
      if (!packed) {
        list.add(readScalar(reader, scalarType));
        return;
      }
      const e = reader.uint32() + reader.pos;
      while (reader.pos < e) {
        list.add(readScalar(reader, scalarType));
      }
    }
    function readMessageField(reader, options, field, mergeMessage) {
      const delimited = field.delimitedEncoding;
      const message = mergeMessage !== null && mergeMessage !== void 0 ? mergeMessage : (0, reflect_js_1.reflect)(field.message, void 0, false);
      readMessage(message, reader, options, delimited, delimited ? field.number : reader.uint32());
      return message;
    }
    function readScalar(reader, type) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          return reader.string();
        case descriptors_js_1.ScalarType.BOOL:
          return reader.bool();
        case descriptors_js_1.ScalarType.DOUBLE:
          return reader.double();
        case descriptors_js_1.ScalarType.FLOAT:
          return reader.float();
        case descriptors_js_1.ScalarType.INT32:
          return reader.int32();
        case descriptors_js_1.ScalarType.INT64:
          return reader.int64();
        case descriptors_js_1.ScalarType.UINT64:
          return reader.uint64();
        case descriptors_js_1.ScalarType.FIXED64:
          return reader.fixed64();
        case descriptors_js_1.ScalarType.BYTES:
          return reader.bytes();
        case descriptors_js_1.ScalarType.FIXED32:
          return reader.fixed32();
        case descriptors_js_1.ScalarType.SFIXED32:
          return reader.sfixed32();
        case descriptors_js_1.ScalarType.SFIXED64:
          return reader.sfixed64();
        case descriptors_js_1.ScalarType.SINT64:
          return reader.sint64();
        case descriptors_js_1.ScalarType.UINT32:
          return reader.uint32();
        case descriptors_js_1.ScalarType.SINT32:
          return reader.sint32();
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/file.js
var require_file = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fileDesc = fileDesc;
    var base64_encoding_js_1 = require_base64_encoding();
    var descriptor_pb_js_1 = require_descriptor_pb();
    var registry_js_1 = require_registry();
    var restore_json_names_js_1 = require_restore_json_names();
    var from_binary_js_1 = require_from_binary();
    function fileDesc(b64, imports) {
      var _a;
      const root = (0, from_binary_js_1.fromBinary)(descriptor_pb_js_1.FileDescriptorProtoSchema, (0, base64_encoding_js_1.base64Decode)(b64));
      root.messageType.forEach(restore_json_names_js_1.restoreJsonNames);
      root.dependency = (_a = imports === null || imports === void 0 ? void 0 : imports.map((f) => f.proto.name)) !== null && _a !== void 0 ? _a : [];
      const reg = (0, registry_js_1.createFileRegistry)(root, (protoFileName) => imports === null || imports === void 0 ? void 0 : imports.find((f) => f.proto.name === protoFileName));
      return reg.getFile(root.name);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/service.js
var require_service = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serviceDesc = serviceDesc;
    function serviceDesc(file, path, ...paths) {
      if (paths.length > 0) {
        throw new Error();
      }
      return file.services[path];
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/symbols.js
var require_symbols = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/symbols.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.symbols = exports.wktPublicImportPaths = exports.packageName = void 0;
    exports.packageName = "@bufbuild/protobuf";
    exports.wktPublicImportPaths = {
      "google/protobuf/compiler/plugin.proto": exports.packageName + "/wkt",
      "google/protobuf/any.proto": exports.packageName + "/wkt",
      "google/protobuf/api.proto": exports.packageName + "/wkt",
      "google/protobuf/descriptor.proto": exports.packageName + "/wkt",
      "google/protobuf/duration.proto": exports.packageName + "/wkt",
      "google/protobuf/empty.proto": exports.packageName + "/wkt",
      "google/protobuf/field_mask.proto": exports.packageName + "/wkt",
      "google/protobuf/source_context.proto": exports.packageName + "/wkt",
      "google/protobuf/struct.proto": exports.packageName + "/wkt",
      "google/protobuf/timestamp.proto": exports.packageName + "/wkt",
      "google/protobuf/type.proto": exports.packageName + "/wkt",
      "google/protobuf/wrappers.proto": exports.packageName + "/wkt"
    };
    exports.symbols = {
      isMessage: { typeOnly: false, bootstrapWktFrom: "../../is-message.js", from: exports.packageName },
      Message: { typeOnly: true, bootstrapWktFrom: "../../types.js", from: exports.packageName },
      create: { typeOnly: false, bootstrapWktFrom: "../../create.js", from: exports.packageName },
      fromJson: { typeOnly: false, bootstrapWktFrom: "../../from-json.js", from: exports.packageName },
      fromJsonString: { typeOnly: false, bootstrapWktFrom: "../../from-json.js", from: exports.packageName },
      fromBinary: { typeOnly: false, bootstrapWktFrom: "../../from-binary.js", from: exports.packageName },
      toBinary: { typeOnly: false, bootstrapWktFrom: "../../to-binary.js", from: exports.packageName },
      toJson: { typeOnly: false, bootstrapWktFrom: "../../to-json.js", from: exports.packageName },
      toJsonString: { typeOnly: false, bootstrapWktFrom: "../../to-json.js", from: exports.packageName },
      protoInt64: { typeOnly: false, bootstrapWktFrom: "../../proto-int64.js", from: exports.packageName },
      JsonValue: { typeOnly: true, bootstrapWktFrom: "../../json-value.js", from: exports.packageName },
      JsonObject: { typeOnly: true, bootstrapWktFrom: "../../json-value.js", from: exports.packageName },
      codegen: {
        boot: { typeOnly: false, bootstrapWktFrom: "../../codegenv1/boot.js", from: exports.packageName + "/codegenv1" },
        fileDesc: { typeOnly: false, bootstrapWktFrom: "../../codegenv1/file.js", from: exports.packageName + "/codegenv1" },
        enumDesc: { typeOnly: false, bootstrapWktFrom: "../../codegenv1/enum.js", from: exports.packageName + "/codegenv1" },
        extDesc: { typeOnly: false, bootstrapWktFrom: "../../codegenv1/extension.js", from: exports.packageName + "/codegenv1" },
        messageDesc: { typeOnly: false, bootstrapWktFrom: "../../codegenv1/message.js", from: exports.packageName + "/codegenv1" },
        serviceDesc: { typeOnly: false, bootstrapWktFrom: "../../codegenv1/service.js", from: exports.packageName + "/codegenv1" },
        tsEnum: { typeOnly: false, bootstrapWktFrom: "../../codegenv1/enum.js", from: exports.packageName + "/codegenv1" },
        GenFile: { typeOnly: true, bootstrapWktFrom: "../../codegenv1/types.js", from: exports.packageName + "/codegenv1" },
        GenEnum: { typeOnly: true, bootstrapWktFrom: "../../codegenv1/types.js", from: exports.packageName + "/codegenv1" },
        GenExtension: { typeOnly: true, bootstrapWktFrom: "../../codegenv1/types.js", from: exports.packageName + "/codegenv1" },
        GenMessage: { typeOnly: true, bootstrapWktFrom: "../../codegenv1/types.js", from: exports.packageName + "/codegenv1" },
        GenService: { typeOnly: true, bootstrapWktFrom: "../../codegenv1/types.js", from: exports.packageName + "/codegenv1" }
      }
    };
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/scalar.js
var require_scalar2 = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/scalar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scalarTypeScriptType = scalarTypeScriptType;
    exports.scalarJsonType = scalarJsonType;
    var descriptors_js_1 = require_descriptors();
    function scalarTypeScriptType(scalar, longAsString) {
      switch (scalar) {
        case descriptors_js_1.ScalarType.STRING:
          return "string";
        case descriptors_js_1.ScalarType.BOOL:
          return "boolean";
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.SINT64:
        case descriptors_js_1.ScalarType.INT64:
          return longAsString ? "string" : "bigint";
        case descriptors_js_1.ScalarType.BYTES:
          return "Uint8Array";
        default:
          return "number";
      }
    }
    function scalarJsonType(scalar) {
      switch (scalar) {
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FLOAT:
          return `number | "NaN" | "Infinity" | "-Infinity"`;
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.SINT64:
        case descriptors_js_1.ScalarType.INT64:
          return "string";
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
          return "number";
        case descriptors_js_1.ScalarType.STRING:
          return "string";
        case descriptors_js_1.ScalarType.BOOL:
          return "boolean";
        case descriptors_js_1.ScalarType.BYTES:
          return "string";
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/types.js
var require_types = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/index.js
var require_codegenv1 = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/codegenv1/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_boot(), exports);
    __exportStar(require_embed(), exports);
    __exportStar(require_enum(), exports);
    __exportStar(require_extension(), exports);
    __exportStar(require_file(), exports);
    __exportStar(require_message(), exports);
    __exportStar(require_service(), exports);
    __exportStar(require_symbols(), exports);
    __exportStar(require_scalar2(), exports);
    __exportStar(require_types(), exports);
  }
});

// node_modules/sass-embedded/dist/lib/src/vendor/embedded_sass_pb.js
var require_embedded_sass_pb = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/vendor/embedded_sass_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingletonValue = exports.ListSeparatorSchema = exports.ListSeparator = exports.ProtocolErrorTypeSchema = exports.ProtocolErrorType = exports.LogEventTypeSchema = exports.LogEventType = exports.SyntaxSchema = exports.Syntax = exports.OutputStyleSchema = exports.OutputStyle = exports.NodePackageImporterSchema = exports.Value_Calculation_CalculationOperationSchema = exports.Value_Calculation_CalculationValueSchema = exports.Value_CalculationSchema = exports.Value_ArgumentListSchema = exports.Value_CompilerMixinSchema = exports.Value_HostFunctionSchema = exports.Value_CompilerFunctionSchema = exports.Value_Map_EntrySchema = exports.Value_MapSchema = exports.Value_ListSchema = exports.Value_ColorSchema = exports.Value_NumberSchema = exports.Value_StringSchema = exports.ValueSchema = exports.SourceSpan_SourceLocationSchema = exports.SourceSpanSchema = exports.ProtocolErrorSchema = exports.OutboundMessage_FunctionCallRequestSchema = exports.OutboundMessage_FileImportRequestSchema = exports.OutboundMessage_ImportRequestSchema = exports.OutboundMessage_CanonicalizeRequestSchema = exports.OutboundMessage_LogEventSchema = exports.OutboundMessage_CompileResponse_CompileFailureSchema = exports.OutboundMessage_CompileResponse_CompileSuccessSchema = exports.OutboundMessage_CompileResponseSchema = exports.OutboundMessage_VersionResponseSchema = exports.OutboundMessageSchema = exports.InboundMessage_FunctionCallResponseSchema = exports.InboundMessage_FileImportResponseSchema = exports.InboundMessage_ImportResponse_ImportSuccessSchema = exports.InboundMessage_ImportResponseSchema = exports.InboundMessage_CanonicalizeResponseSchema = exports.InboundMessage_CompileRequest_ImporterSchema = exports.InboundMessage_CompileRequest_StringInputSchema = exports.InboundMessage_CompileRequestSchema = exports.InboundMessage_VersionRequestSchema = exports.InboundMessageSchema = exports.file_embedded_sass = void 0;
    exports.CalculationOperatorSchema = exports.CalculationOperator = exports.SingletonValueSchema = void 0;
    var codegenv1_1 = require_codegenv1();
    exports.file_embedded_sass = (0, codegenv1_1.fileDesc)("ChNlbWJlZGRlZF9zYXNzLnByb3RvEhZzYXNzLmVtYmVkZGVkX3Byb3RvY29sIugQCg5JbmJvdW5kTWVzc2FnZRJQCg9jb21waWxlX3JlcXVlc3QYAiABKAsyNS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLkluYm91bmRNZXNzYWdlLkNvbXBpbGVSZXF1ZXN0SAASXAoVY2Fub25pY2FsaXplX3Jlc3BvbnNlGAMgASgLMjsuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5JbmJvdW5kTWVzc2FnZS5DYW5vbmljYWxpemVSZXNwb25zZUgAElAKD2ltcG9ydF9yZXNwb25zZRgEIAEoCzI1LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuSW1wb3J0UmVzcG9uc2VIABJZChRmaWxlX2ltcG9ydF9yZXNwb25zZRgFIAEoCzI5LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuRmlsZUltcG9ydFJlc3BvbnNlSAASXQoWZnVuY3Rpb25fY2FsbF9yZXNwb25zZRgGIAEoCzI7LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuRnVuY3Rpb25DYWxsUmVzcG9uc2VIABJQCg92ZXJzaW9uX3JlcXVlc3QYByABKAsyNS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLkluYm91bmRNZXNzYWdlLlZlcnNpb25SZXF1ZXN0SAAaHAoOVmVyc2lvblJlcXVlc3QSCgoCaWQYASABKA0amAcKDkNvbXBpbGVSZXF1ZXN0ElMKBnN0cmluZxgCIAEoCzJBLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuQ29tcGlsZVJlcXVlc3QuU3RyaW5nSW5wdXRIABIOCgRwYXRoGAMgASgJSAASMgoFc3R5bGUYBCABKA4yIy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk91dHB1dFN0eWxlEhIKCnNvdXJjZV9tYXAYBSABKAgSUQoJaW1wb3J0ZXJzGAYgAygLMj4uc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5JbmJvdW5kTWVzc2FnZS5Db21waWxlUmVxdWVzdC5JbXBvcnRlchIYChBnbG9iYWxfZnVuY3Rpb25zGAcgAygJEhMKC2FsZXJ0X2NvbG9yGAggASgIEhMKC2FsZXJ0X2FzY2lpGAkgASgIEg8KB3ZlcmJvc2UYCiABKAgSEgoKcXVpZXRfZGVwcxgLIAEoCBIiChpzb3VyY2VfbWFwX2luY2x1ZGVfc291cmNlcxgMIAEoCBIPCgdjaGFyc2V0GA0gASgIEg4KBnNpbGVudBgOIAEoCBIZChFmYXRhbF9kZXByZWNhdGlvbhgPIAMoCRIbChNzaWxlbmNlX2RlcHJlY2F0aW9uGBAgAygJEhoKEmZ1dHVyZV9kZXByZWNhdGlvbhgRIAMoCRqsAQoLU3RyaW5nSW5wdXQSDgoGc291cmNlGAEgASgJEgsKA3VybBgCIAEoCRIuCgZzeW50YXgYAyABKA4yHi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlN5bnRheBJQCghpbXBvcnRlchgEIAEoCzI+LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuSW5ib3VuZE1lc3NhZ2UuQ29tcGlsZVJlcXVlc3QuSW1wb3J0ZXIaxQEKCEltcG9ydGVyEg4KBHBhdGgYASABKAlIABIVCgtpbXBvcnRlcl9pZBgCIAEoDUgAEhoKEGZpbGVfaW1wb3J0ZXJfaWQYAyABKA1IABJMChVub2RlX3BhY2thZ2VfaW1wb3J0ZXIYBSABKAsyKy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk5vZGVQYWNrYWdlSW1wb3J0ZXJIABIcChRub25fY2Fub25pY2FsX3NjaGVtZRgEIAMoCUIKCghpbXBvcnRlckIHCgVpbnB1dEoECAEQAhprChRDYW5vbmljYWxpemVSZXNwb25zZRIKCgJpZBgBIAEoDRINCgN1cmwYAiABKAlIABIPCgVlcnJvchgDIAEoCUgAEh0KFWNvbnRhaW5pbmdfdXJsX3VudXNlZBgEIAEoCEIICgZyZXN1bHQakwIKDkltcG9ydFJlc3BvbnNlEgoKAmlkGAEgASgNElYKB3N1Y2Nlc3MYAiABKAsyQy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLkluYm91bmRNZXNzYWdlLkltcG9ydFJlc3BvbnNlLkltcG9ydFN1Y2Nlc3NIABIPCgVlcnJvchgDIAEoCUgAGoEBCg1JbXBvcnRTdWNjZXNzEhAKCGNvbnRlbnRzGAEgASgJEi4KBnN5bnRheBgCIAEoDjIeLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuU3ludGF4EhsKDnNvdXJjZV9tYXBfdXJsGAMgASgJSACIAQFCEQoPX3NvdXJjZV9tYXBfdXJsQggKBnJlc3VsdBpuChJGaWxlSW1wb3J0UmVzcG9uc2USCgoCaWQYASABKA0SEgoIZmlsZV91cmwYAiABKAlIABIPCgVlcnJvchgDIAEoCUgAEh0KFWNvbnRhaW5pbmdfdXJsX3VudXNlZBgEIAEoCEIICgZyZXN1bHQakAEKFEZ1bmN0aW9uQ2FsbFJlc3BvbnNlEgoKAmlkGAEgASgNEjAKB3N1Y2Nlc3MYAiABKAsyHS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlSAASDwoFZXJyb3IYAyABKAlIABIfChdhY2Nlc3NlZF9hcmd1bWVudF9saXN0cxgEIAMoDUIICgZyZXN1bHRCCQoHbWVzc2FnZSLLDwoPT3V0Ym91bmRNZXNzYWdlEjYKBWVycm9yGAEgASgLMiUuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5Qcm90b2NvbEVycm9ySAASUwoQY29tcGlsZV9yZXNwb25zZRgCIAEoCzI3LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuT3V0Ym91bmRNZXNzYWdlLkNvbXBpbGVSZXNwb25zZUgAEkUKCWxvZ19ldmVudBgDIAEoCzIwLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuT3V0Ym91bmRNZXNzYWdlLkxvZ0V2ZW50SAASWwoUY2Fub25pY2FsaXplX3JlcXVlc3QYBCABKAsyOy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk91dGJvdW5kTWVzc2FnZS5DYW5vbmljYWxpemVSZXF1ZXN0SAASTwoOaW1wb3J0X3JlcXVlc3QYBSABKAsyNS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk91dGJvdW5kTWVzc2FnZS5JbXBvcnRSZXF1ZXN0SAASWAoTZmlsZV9pbXBvcnRfcmVxdWVzdBgGIAEoCzI5LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuT3V0Ym91bmRNZXNzYWdlLkZpbGVJbXBvcnRSZXF1ZXN0SAASXAoVZnVuY3Rpb25fY2FsbF9yZXF1ZXN0GAcgASgLMjsuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5PdXRib3VuZE1lc3NhZ2UuRnVuY3Rpb25DYWxsUmVxdWVzdEgAElMKEHZlcnNpb25fcmVzcG9uc2UYCCABKAsyNy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLk91dGJvdW5kTWVzc2FnZS5WZXJzaW9uUmVzcG9uc2VIABqOAQoPVmVyc2lvblJlc3BvbnNlEgoKAmlkGAUgASgNEhgKEHByb3RvY29sX3ZlcnNpb24YASABKAkSGAoQY29tcGlsZXJfdmVyc2lvbhgCIAEoCRIeChZpbXBsZW1lbnRhdGlvbl92ZXJzaW9uGAMgASgJEhsKE2ltcGxlbWVudGF0aW9uX25hbWUYBCABKAkaogMKD0NvbXBpbGVSZXNwb25zZRJZCgdzdWNjZXNzGAIgASgLMkYuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5PdXRib3VuZE1lc3NhZ2UuQ29tcGlsZVJlc3BvbnNlLkNvbXBpbGVTdWNjZXNzSAASWQoHZmFpbHVyZRgDIAEoCzJGLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuT3V0Ym91bmRNZXNzYWdlLkNvbXBpbGVSZXNwb25zZS5Db21waWxlRmFpbHVyZUgAEhMKC2xvYWRlZF91cmxzGAQgAygJGjcKDkNvbXBpbGVTdWNjZXNzEgsKA2NzcxgBIAEoCRISCgpzb3VyY2VfbWFwGAIgASgJSgQIAxAEGnsKDkNvbXBpbGVGYWlsdXJlEg8KB21lc3NhZ2UYASABKAkSMAoEc3BhbhgCIAEoCzIiLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuU291cmNlU3BhbhITCgtzdGFja190cmFjZRgDIAEoCRIRCglmb3JtYXR0ZWQYBCABKAlCCAoGcmVzdWx0SgQIARACGvEBCghMb2dFdmVudBIyCgR0eXBlGAIgASgOMiQuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5Mb2dFdmVudFR5cGUSDwoHbWVzc2FnZRgDIAEoCRI1CgRzcGFuGAQgASgLMiIuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5Tb3VyY2VTcGFuSACIAQESEwoLc3RhY2tfdHJhY2UYBSABKAkSEQoJZm9ybWF0dGVkGAYgASgJEh0KEGRlcHJlY2F0aW9uX3R5cGUYByABKAlIAYgBAUIHCgVfc3BhbkITChFfZGVwcmVjYXRpb25fdHlwZUoECAEQAhqOAQoTQ2Fub25pY2FsaXplUmVxdWVzdBIKCgJpZBgBIAEoDRITCgtpbXBvcnRlcl9pZBgDIAEoDRILCgN1cmwYBCABKAkSEwoLZnJvbV9pbXBvcnQYBSABKAgSGwoOY29udGFpbmluZ191cmwYBiABKAlIAIgBAUIRCg9fY29udGFpbmluZ191cmxKBAgCEAMaQwoNSW1wb3J0UmVxdWVzdBIKCgJpZBgBIAEoDRITCgtpbXBvcnRlcl9pZBgDIAEoDRILCgN1cmwYBCABKAlKBAgCEAMajAEKEUZpbGVJbXBvcnRSZXF1ZXN0EgoKAmlkGAEgASgNEhMKC2ltcG9ydGVyX2lkGAMgASgNEgsKA3VybBgEIAEoCRITCgtmcm9tX2ltcG9ydBgFIAEoCBIbCg5jb250YWluaW5nX3VybBgGIAEoCUgAiAEBQhEKD19jb250YWluaW5nX3VybEoECAIQAxqOAQoTRnVuY3Rpb25DYWxsUmVxdWVzdBIKCgJpZBgBIAEoDRIOCgRuYW1lGAMgASgJSAASFQoLZnVuY3Rpb25faWQYBCABKA1IABIwCglhcmd1bWVudHMYBSADKAsyHS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlQgwKCmlkZW50aWZpZXJKBAgCEANCCQoHbWVzc2FnZSJlCg1Qcm90b2NvbEVycm9yEjcKBHR5cGUYASABKA4yKS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlByb3RvY29sRXJyb3JUeXBlEgoKAmlkGAIgASgNEg8KB21lc3NhZ2UYAyABKAkihwIKClNvdXJjZVNwYW4SDAoEdGV4dBgBIAEoCRJACgVzdGFydBgCIAEoCzIxLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuU291cmNlU3Bhbi5Tb3VyY2VMb2NhdGlvbhJDCgNlbmQYAyABKAsyMS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlNvdXJjZVNwYW4uU291cmNlTG9jYXRpb25IAIgBARILCgN1cmwYBCABKAkSDwoHY29udGV4dBgFIAEoCRo+Cg5Tb3VyY2VMb2NhdGlvbhIOCgZvZmZzZXQYASABKA0SDAoEbGluZRgCIAEoDRIOCgZjb2x1bW4YAyABKA1CBgoEX2VuZCL4EQoFVmFsdWUSNgoGc3RyaW5nGAEgASgLMiQuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5TdHJpbmdIABI2CgZudW1iZXIYAiABKAsyJC5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLk51bWJlckgAEjIKBGxpc3QYBSABKAsyIi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkxpc3RIABIwCgNtYXAYBiABKAsyIS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLk1hcEgAEjsKCXNpbmdsZXRvbhgHIAEoDjImLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuU2luZ2xldG9uVmFsdWVIABJLChFjb21waWxlcl9mdW5jdGlvbhgIIAEoCzIuLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWUuQ29tcGlsZXJGdW5jdGlvbkgAEkMKDWhvc3RfZnVuY3Rpb24YCSABKAsyKi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkhvc3RGdW5jdGlvbkgAEkMKDWFyZ3VtZW50X2xpc3QYCiABKAsyKi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkFyZ3VtZW50TGlzdEgAEkAKC2NhbGN1bGF0aW9uGAwgASgLMikuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5DYWxjdWxhdGlvbkgAEkUKDmNvbXBpbGVyX21peGluGA0gASgLMisuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5Db21waWxlck1peGluSAASNAoFY29sb3IYDiABKAsyIy5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNvbG9ySAAaJgoGU3RyaW5nEgwKBHRleHQYASABKAkSDgoGcXVvdGVkGAIgASgIGkEKBk51bWJlchINCgV2YWx1ZRgBIAEoARISCgpudW1lcmF0b3JzGAIgAygJEhQKDGRlbm9taW5hdG9ycxgDIAMoCRqgAQoFQ29sb3ISDQoFc3BhY2UYASABKAkSFQoIY2hhbm5lbDEYAiABKAFIAIgBARIVCghjaGFubmVsMhgDIAEoAUgBiAEBEhUKCGNoYW5uZWwzGAQgASgBSAKIAQESEgoFYWxwaGEYBSABKAFIA4gBAUILCglfY2hhbm5lbDFCCwoJX2NoYW5uZWwyQgsKCV9jaGFubmVsM0IICgZfYWxwaGEahwEKBExpc3QSOAoJc2VwYXJhdG9yGAEgASgOMiUuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5MaXN0U2VwYXJhdG9yEhQKDGhhc19icmFja2V0cxgCIAEoCBIvCghjb250ZW50cxgDIAMoCzIdLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWUaogEKA01hcBI4CgdlbnRyaWVzGAEgAygLMicuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5NYXAuRW50cnkaYQoFRW50cnkSKgoDa2V5GAEgASgLMh0uc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZRIsCgV2YWx1ZRgCIAEoCzIdLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWUaHgoQQ29tcGlsZXJGdW5jdGlvbhIKCgJpZBgBIAEoDRotCgxIb3N0RnVuY3Rpb24SCgoCaWQYASABKA0SEQoJc2lnbmF0dXJlGAIgASgJGhsKDUNvbXBpbGVyTWl4aW4SCgoCaWQYASABKA0aoQIKDEFyZ3VtZW50TGlzdBIKCgJpZBgBIAEoDRI4CglzZXBhcmF0b3IYAiABKA4yJS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLkxpc3RTZXBhcmF0b3ISLwoIY29udGVudHMYAyADKAsyHS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlEkoKCGtleXdvcmRzGAQgAygLMjguc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5WYWx1ZS5Bcmd1bWVudExpc3QuS2V5d29yZHNFbnRyeRpOCg1LZXl3b3Jkc0VudHJ5EgsKA2tleRgBIAEoCRIsCgV2YWx1ZRgCIAEoCzIdLnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWU6AjgBGu8ECgtDYWxjdWxhdGlvbhIMCgRuYW1lGAEgASgJEk0KCWFyZ3VtZW50cxgCIAMoCzI6LnNhc3MuZW1iZWRkZWRfcHJvdG9jb2wuVmFsdWUuQ2FsY3VsYXRpb24uQ2FsY3VsYXRpb25WYWx1ZRqVAgoQQ2FsY3VsYXRpb25WYWx1ZRI2CgZudW1iZXIYASABKAsyJC5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLk51bWJlckgAEhAKBnN0cmluZxgCIAEoCUgAEhcKDWludGVycG9sYXRpb24YAyABKAlIABJTCglvcGVyYXRpb24YBCABKAsyPi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNhbGN1bGF0aW9uLkNhbGN1bGF0aW9uT3BlcmF0aW9uSAASQAoLY2FsY3VsYXRpb24YBSABKAsyKS5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNhbGN1bGF0aW9uSABCBwoFdmFsdWUa6gEKFENhbGN1bGF0aW9uT3BlcmF0aW9uEj0KCG9wZXJhdG9yGAEgASgOMisuc2Fzcy5lbWJlZGRlZF9wcm90b2NvbC5DYWxjdWxhdGlvbk9wZXJhdG9yEkgKBGxlZnQYAiABKAsyOi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNhbGN1bGF0aW9uLkNhbGN1bGF0aW9uVmFsdWUSSQoFcmlnaHQYAyABKAsyOi5zYXNzLmVtYmVkZGVkX3Byb3RvY29sLlZhbHVlLkNhbGN1bGF0aW9uLkNhbGN1bGF0aW9uVmFsdWVCBwoFdmFsdWUiNAoTTm9kZVBhY2thZ2VJbXBvcnRlchIdChVlbnRyeV9wb2ludF9kaXJlY3RvcnkYASABKAkqKwoLT3V0cHV0U3R5bGUSDAoIRVhQQU5ERUQQABIOCgpDT01QUkVTU0VEEAEqKQoGU3ludGF4EggKBFNDU1MQABIMCghJTkRFTlRFRBABEgcKA0NTUxACKj8KDExvZ0V2ZW50VHlwZRILCgdXQVJOSU5HEAASFwoTREVQUkVDQVRJT05fV0FSTklORxABEgkKBURFQlVHEAIqOAoRUHJvdG9jb2xFcnJvclR5cGUSCQoFUEFSU0UQABIKCgZQQVJBTVMQARIMCghJTlRFUk5BTBACKj8KDUxpc3RTZXBhcmF0b3ISCQoFQ09NTUEQABIJCgVTUEFDRRABEgkKBVNMQVNIEAISDQoJVU5ERUNJREVEEAMqLwoOU2luZ2xldG9uVmFsdWUSCAoEVFJVRRAAEgkKBUZBTFNFEAESCAoETlVMTBACKkEKE0NhbGN1bGF0aW9uT3BlcmF0b3ISCAoEUExVUxAAEgkKBU1JTlVTEAESCQoFVElNRVMQAhIKCgZESVZJREUQA0IjCh9jb20uc2Fzc19sYW5nLmVtYmVkZGVkX3Byb3RvY29sUAFiBnByb3RvMw");
    exports.InboundMessageSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0);
    exports.InboundMessage_VersionRequestSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 0);
    exports.InboundMessage_CompileRequestSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 1);
    exports.InboundMessage_CompileRequest_StringInputSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 1, 0);
    exports.InboundMessage_CompileRequest_ImporterSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 1, 1);
    exports.InboundMessage_CanonicalizeResponseSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 2);
    exports.InboundMessage_ImportResponseSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 3);
    exports.InboundMessage_ImportResponse_ImportSuccessSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 3, 0);
    exports.InboundMessage_FileImportResponseSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 4);
    exports.InboundMessage_FunctionCallResponseSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 0, 5);
    exports.OutboundMessageSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1);
    exports.OutboundMessage_VersionResponseSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 0);
    exports.OutboundMessage_CompileResponseSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 1);
    exports.OutboundMessage_CompileResponse_CompileSuccessSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 1, 0);
    exports.OutboundMessage_CompileResponse_CompileFailureSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 1, 1);
    exports.OutboundMessage_LogEventSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 2);
    exports.OutboundMessage_CanonicalizeRequestSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 3);
    exports.OutboundMessage_ImportRequestSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 4);
    exports.OutboundMessage_FileImportRequestSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 5);
    exports.OutboundMessage_FunctionCallRequestSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 1, 6);
    exports.ProtocolErrorSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 2);
    exports.SourceSpanSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 3);
    exports.SourceSpan_SourceLocationSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 3, 0);
    exports.ValueSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4);
    exports.Value_StringSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 0);
    exports.Value_NumberSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 1);
    exports.Value_ColorSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 2);
    exports.Value_ListSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 3);
    exports.Value_MapSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 4);
    exports.Value_Map_EntrySchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 4, 0);
    exports.Value_CompilerFunctionSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 5);
    exports.Value_HostFunctionSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 6);
    exports.Value_CompilerMixinSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 7);
    exports.Value_ArgumentListSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 8);
    exports.Value_CalculationSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 9);
    exports.Value_Calculation_CalculationValueSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 9, 0);
    exports.Value_Calculation_CalculationOperationSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 4, 9, 1);
    exports.NodePackageImporterSchema = (0, codegenv1_1.messageDesc)(exports.file_embedded_sass, 5);
    var OutputStyle;
    (function(OutputStyle2) {
      OutputStyle2[OutputStyle2["EXPANDED"] = 0] = "EXPANDED";
      OutputStyle2[OutputStyle2["COMPRESSED"] = 1] = "COMPRESSED";
    })(OutputStyle || (exports.OutputStyle = OutputStyle = {}));
    exports.OutputStyleSchema = (0, codegenv1_1.enumDesc)(exports.file_embedded_sass, 0);
    var Syntax;
    (function(Syntax2) {
      Syntax2[Syntax2["SCSS"] = 0] = "SCSS";
      Syntax2[Syntax2["INDENTED"] = 1] = "INDENTED";
      Syntax2[Syntax2["CSS"] = 2] = "CSS";
    })(Syntax || (exports.Syntax = Syntax = {}));
    exports.SyntaxSchema = (0, codegenv1_1.enumDesc)(exports.file_embedded_sass, 1);
    var LogEventType;
    (function(LogEventType2) {
      LogEventType2[LogEventType2["WARNING"] = 0] = "WARNING";
      LogEventType2[LogEventType2["DEPRECATION_WARNING"] = 1] = "DEPRECATION_WARNING";
      LogEventType2[LogEventType2["DEBUG"] = 2] = "DEBUG";
    })(LogEventType || (exports.LogEventType = LogEventType = {}));
    exports.LogEventTypeSchema = (0, codegenv1_1.enumDesc)(exports.file_embedded_sass, 2);
    var ProtocolErrorType;
    (function(ProtocolErrorType2) {
      ProtocolErrorType2[ProtocolErrorType2["PARSE"] = 0] = "PARSE";
      ProtocolErrorType2[ProtocolErrorType2["PARAMS"] = 1] = "PARAMS";
      ProtocolErrorType2[ProtocolErrorType2["INTERNAL"] = 2] = "INTERNAL";
    })(ProtocolErrorType || (exports.ProtocolErrorType = ProtocolErrorType = {}));
    exports.ProtocolErrorTypeSchema = (0, codegenv1_1.enumDesc)(exports.file_embedded_sass, 3);
    var ListSeparator3;
    (function(ListSeparator4) {
      ListSeparator4[ListSeparator4["COMMA"] = 0] = "COMMA";
      ListSeparator4[ListSeparator4["SPACE"] = 1] = "SPACE";
      ListSeparator4[ListSeparator4["SLASH"] = 2] = "SLASH";
      ListSeparator4[ListSeparator4["UNDECIDED"] = 3] = "UNDECIDED";
    })(ListSeparator3 || (exports.ListSeparator = ListSeparator3 = {}));
    exports.ListSeparatorSchema = (0, codegenv1_1.enumDesc)(exports.file_embedded_sass, 4);
    var SingletonValue;
    (function(SingletonValue2) {
      SingletonValue2[SingletonValue2["TRUE"] = 0] = "TRUE";
      SingletonValue2[SingletonValue2["FALSE"] = 1] = "FALSE";
      SingletonValue2[SingletonValue2["NULL"] = 2] = "NULL";
    })(SingletonValue || (exports.SingletonValue = SingletonValue = {}));
    exports.SingletonValueSchema = (0, codegenv1_1.enumDesc)(exports.file_embedded_sass, 5);
    var CalculationOperator3;
    (function(CalculationOperator4) {
      CalculationOperator4[CalculationOperator4["PLUS"] = 0] = "PLUS";
      CalculationOperator4[CalculationOperator4["MINUS"] = 1] = "MINUS";
      CalculationOperator4[CalculationOperator4["TIMES"] = 2] = "TIMES";
      CalculationOperator4[CalculationOperator4["DIVIDE"] = 3] = "DIVIDE";
    })(CalculationOperator3 || (exports.CalculationOperator = CalculationOperator3 = {}));
    exports.CalculationOperatorSchema = (0, codegenv1_1.enumDesc)(exports.file_embedded_sass, 6);
  }
});

// node_modules/sass-embedded/dist/lib/src/utils.js
var require_utils = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thenOr = thenOr;
    exports.catchOr = catchOr;
    exports.isNullOrUndefined = isNullOrUndefined;
    exports.asImmutableList = asImmutableList;
    exports.compilerError = compilerError;
    exports.mandatoryError = mandatoryError;
    exports.hostError = hostError;
    exports.valueError = valueError;
    exports.pathToUrlString = pathToUrlString;
    exports.fileUrlToPathCrossPlatform = fileUrlToPathCrossPlatform;
    exports.withoutExtension = withoutExtension;
    exports.protofySyntax = protofySyntax;
    exports.isErrnoException = isErrnoException;
    exports.putIfAbsent = putIfAbsent;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var p = require_path();
    var url = require_url();
    var proto = require_embedded_sass_pb();
    function thenOr(promiseOrValue, callback) {
      return promiseOrValue instanceof Promise ? promiseOrValue.then(callback) : callback(promiseOrValue);
    }
    function catchOr(promiseOrValueCallback, callback) {
      try {
        const result = promiseOrValueCallback();
        return result instanceof Promise ? result.catch(callback) : result;
      } catch (error) {
        return callback(error);
      }
    }
    function isNullOrUndefined(object) {
      return object === null || object === void 0;
    }
    function asImmutableList(collection) {
      return immutable_1.List.isList(collection) ? collection : (0, immutable_1.List)(collection);
    }
    function compilerError(message) {
      return Error(`Compiler caused error: ${message}.`);
    }
    function mandatoryError(field) {
      return compilerError(`Missing mandatory field ${field}`);
    }
    function hostError(message) {
      return Error(`Compiler reported error: ${message}.`);
    }
    function valueError(message, name) {
      return Error(name ? `$${name}: ${message}.` : `${message}.`);
    }
    var unsafePathToFileURL = url.pathToFileURL("~").pathname.endsWith("~");
    function pathToUrlString(path) {
      if (p.isAbsolute(path))
        return url.pathToFileURL(path).toString();
      let fileUrl = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
      if (unsafePathToFileURL) {
        fileUrl = fileUrl.replace(/%(5B|5D|5E|7C)/g, decodeURIComponent);
      } else {
        fileUrl = fileUrl.replace(/~/g, "%7E");
      }
      if (process.platform === "win32") {
        fileUrl = fileUrl.replace(/%5C/g, "/");
      }
      return fileUrl;
    }
    function fileUrlToPathCrossPlatform(fileUrl) {
      const path = url.fileURLToPath(fileUrl);
      return /^\/[A-Za-z]:\//.test(path) ? path.substring(1) : path;
    }
    function withoutExtension(path) {
      const extension = p.extname(path);
      return path.substring(0, path.length - extension.length);
    }
    function protofySyntax(syntax) {
      switch (syntax) {
        case "scss":
          return proto.Syntax.SCSS;
        case "indented":
          return proto.Syntax.INDENTED;
        case "css":
          return proto.Syntax.CSS;
        default:
          throw new Error(`Unknown syntax: "${syntax}"`);
      }
    }
    function isErrnoException(error) {
      return error instanceof Error && ("errno" in error || "code" in error);
    }
    function putIfAbsent(map2, key, provider) {
      const val = map2.get(key);
      if (val !== void 0) {
        return val;
      } else {
        const newVal = provider();
        map2.set(key, newVal);
        return newVal;
      }
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/value/index.js
var require_value = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Value = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var utils_1 = require_utils();
    var Value3 = class {
      /** Whether `this` counts as `true`. */
      get isTruthy() {
        return true;
      }
      /** Returns JS null if `this` is `sassNull`. Otherwise, returns `this`. */
      get realNull() {
        return this;
      }
      /** `this` as a list. */
      get asList() {
        return (0, immutable_1.List)([this]);
      }
      /** The separator for `this` as a list. */
      get separator() {
        return null;
      }
      /** Whether `this`, as a list, has brackets. */
      get hasBrackets() {
        return false;
      }
      // Subclasses can override this to change the behavior of
      // `sassIndexToListIndex`.
      get lengthAsList() {
        return 1;
      }
      /**
       * Converts `sassIndex` to a JS index into the array returned by `asList`.
       *
       * Sass indices start counting at 1, and may be negative in order to index
       * from the end of the list.
       *
       * `sassIndex` must be...
       * - a number, and
       * - an integer, and
       * - a valid index into `asList`.
       *
       * Otherwise, this throws an error.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      sassIndexToListIndex(sassIndex, name) {
        const index = sassIndex.assertNumber().assertInt();
        if (index === 0) {
          throw Error("List index may not be 0.");
        }
        if (Math.abs(index) > this.lengthAsList) {
          throw (0, utils_1.valueError)(`Invalid index ${sassIndex} for a list with ${this.lengthAsList} elements.`, name);
        }
        return index < 0 ? this.lengthAsList + index : index - 1;
      }
      /** Returns `this.asList.get(index)`. */
      get(index) {
        return index < 1 && index >= -1 ? this : void 0;
      }
      /**
       * Casts `this` to `SassBoolean`; throws if `this` isn't a boolean.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertBoolean(name) {
        throw (0, utils_1.valueError)(`${this} is not a boolean`, name);
      }
      /**
       * Casts `this` to `SassCalculation`; throws if `this` isn't a calculation.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertCalculation(name) {
        throw (0, utils_1.valueError)(`${this} is not a calculation`, name);
      }
      /**
       * Casts `this` to `SassColor`; throws if `this` isn't a color.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertColor(name) {
        throw (0, utils_1.valueError)(`${this} is not a color`, name);
      }
      /**
       * Casts `this` to `SassFunction`; throws if `this` isn't a function
       * reference.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertFunction(name) {
        throw (0, utils_1.valueError)(`${this} is not a function reference`, name);
      }
      /**
       * Casts `this` to `SassMixin`; throws if `this` isn't a mixin
       * reference.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertMixin(name) {
        throw (0, utils_1.valueError)(`${this} is not a mixin reference`, name);
      }
      /**
       * Casts `this` to `SassMap`; throws if `this` isn't a map.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertMap(name) {
        throw (0, utils_1.valueError)(`${this} is not a map`, name);
      }
      /**
       * Returns `this` as a `SassMap` if it counts as one (including empty lists),
       * or `null` if it does not.
       */
      tryMap() {
        return null;
      }
      /**
       * Casts `this` to `SassString`; throws if `this` isn't a string.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertNumber(name) {
        throw (0, utils_1.valueError)(`${this} is not a number`, name);
      }
      /**
       * Casts `this` to `SassString`; throws if `this` isn't a string.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertString(name) {
        throw (0, utils_1.valueError)(`${this} is not a string`, name);
      }
    };
    exports.Value = Value3;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/boolean.js
var require_boolean = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/boolean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sassFalse = exports.sassTrue = exports.SassBooleanInternal = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var index_1 = require_value();
    var trueHash = (0, immutable_1.hash)(true);
    var falseHash = (0, immutable_1.hash)(false);
    var _SassBooleanInternal = class _SassBooleanInternal extends index_1.Value {
      constructor(valueInternal) {
        super();
        __publicField(this, "valueInternal");
        this.valueInternal = valueInternal;
        if (!_SassBooleanInternal.constructionAllowed) {
          throw "new sass.types.Boolean() isn't allowed.\nUse sass.types.Boolean.TRUE or sass.types.Boolean.FALSE instead.";
        }
        Object.freeze(this);
      }
      get value() {
        return this.valueInternal;
      }
      get isTruthy() {
        return this.value;
      }
      assertBoolean() {
        return this;
      }
      equals(other) {
        return this === other;
      }
      hashCode() {
        return this.value ? trueHash : falseHash;
      }
      toString() {
        return this.value ? "sassTrue" : "sassFalse";
      }
      getValue() {
        return this.value;
      }
    };
    // Whether callers are allowed to construct this class. This is set to
    // `false` once the two constants are constructed so that the constructor
    // throws an error for future calls, in accordance with the legacy API.
    __publicField(_SassBooleanInternal, "constructionAllowed", true);
    // Legacy API support
    __publicField(_SassBooleanInternal, "TRUE");
    __publicField(_SassBooleanInternal, "FALSE");
    var SassBooleanInternal = _SassBooleanInternal;
    exports.SassBooleanInternal = SassBooleanInternal;
    exports.sassTrue = new SassBooleanInternal(true);
    exports.sassFalse = new SassBooleanInternal(false);
    SassBooleanInternal.constructionAllowed = false;
    SassBooleanInternal.TRUE = exports.sassTrue;
    SassBooleanInternal.FALSE = exports.sassFalse;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/null.js
var require_null = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/null.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sassNull = exports.SassNull = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var index_1 = require_value();
    var hashCode3 = (0, immutable_1.hash)(null);
    var _SassNull = class _SassNull extends index_1.Value {
      constructor() {
        super();
        if (!_SassNull.constructionAllowed) {
          throw "new sass.types.Null() isn't allowed.\nUse sass.types.Null.NULL instead.";
        }
        Object.freeze(this);
      }
      get isTruthy() {
        return false;
      }
      get realNull() {
        return null;
      }
      equals(other) {
        return this === other;
      }
      hashCode() {
        return hashCode3;
      }
      toString() {
        return "sassNull";
      }
    };
    // Whether callers are allowed to construct this class. This is set to
    // `false` once the two constants are constructed so that the constructor
    // throws an error for future calls, in accordance with the legacy API.
    __publicField(_SassNull, "constructionAllowed", true);
    // Legacy API support
    __publicField(_SassNull, "NULL");
    var SassNull = _SassNull;
    exports.SassNull = SassNull;
    exports.sassNull = new SassNull();
    SassNull.constructionAllowed = false;
    SassNull.NULL = exports.sassNull;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/map.js
var require_map = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SassMap = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var index_1 = require_value();
    var list_1 = require_list();
    var SassMap3 = class _SassMap extends index_1.Value {
      /** Returns a map that contains `contents`. */
      constructor(contents) {
        super();
        __publicField(this, "contentsInternal");
        this.contentsInternal = contents ?? (0, immutable_1.OrderedMap)();
      }
      /** The separator for `this`'s contents as a list. */
      get separator() {
        return this.contentsInternal.isEmpty() ? null : ",";
      }
      /** `this`'s contents. */
      get contents() {
        return this.contentsInternal;
      }
      /**
       * Returns an immutable list of `contents`'s keys and values as two-element
       * `SassList`s.
       */
      get asList() {
        const list = [];
        for (const entry of this.contents.entries()) {
          list.push(new list_1.SassList(entry, { separator: " " }));
        }
        return (0, immutable_1.List)(list);
      }
      get lengthAsList() {
        return this.contentsInternal.size;
      }
      get(indexOrKey) {
        if (indexOrKey instanceof index_1.Value) {
          return this.contentsInternal.get(indexOrKey);
        } else {
          const entry = this.contentsInternal.entrySeq().get(Math.floor(indexOrKey));
          return entry ? new list_1.SassList(entry, { separator: " " }) : void 0;
        }
      }
      assertMap() {
        return this;
      }
      tryMap() {
        return this;
      }
      equals(other) {
        if (other instanceof list_1.SassList && this.contents.size === 0 && other.asList.size === 0) {
          return true;
        }
        if (!(other instanceof _SassMap) || this.contents.size !== other.contents.size) {
          return false;
        }
        for (const [key, value] of this.contents.entries()) {
          const otherValue = other.contents.get(key);
          if (otherValue === void 0 || !otherValue.equals(value)) {
            return false;
          }
        }
        return true;
      }
      hashCode() {
        return this.contents.isEmpty() ? new list_1.SassList().hashCode() : (
          // SassMaps with the same key-value pairs are considered equal
          // regardless of key-value order, so this hash must be order
          // independent. Since OrderedMap.hashCode() encodes the key-value order,
          // we use a manual XOR accumulator instead.
          this.contents.reduce((accumulator, value, key) => accumulator ^ value.hashCode() ^ key.hashCode(), 0)
        );
      }
      toString() {
        let string = "(";
        string += Array.from(this.contents.entries(), ([key, value]) => `${key}: ${value}`).join(", ");
        string += ")";
        return string;
      }
    };
    exports.SassMap = SassMap3;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/list.js
var require_list = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SassList = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var index_1 = require_value();
    var map_1 = require_map();
    var utils_1 = require_utils();
    var emptyListHashCode = (0, immutable_1.hash)([]);
    var SassList3 = class _SassList extends index_1.Value {
      constructor(contentsOrOptions, options) {
        super();
        __publicField(this, "contentsInternal");
        __publicField(this, "separatorInternal");
        __publicField(this, "hasBracketsInternal");
        if ((0, immutable_1.isList)(contentsOrOptions) || Array.isArray(contentsOrOptions)) {
          this.contentsInternal = (0, utils_1.asImmutableList)(contentsOrOptions);
        } else {
          this.contentsInternal = (0, immutable_1.List)();
          options = contentsOrOptions;
        }
        if (this.contentsInternal.size > 1 && (options == null ? void 0 : options.separator) === null) {
          throw Error("Non-null separator required for SassList with more than one element.");
        }
        this.separatorInternal = (options == null ? void 0 : options.separator) === void 0 ? "," : options.separator;
        this.hasBracketsInternal = (options == null ? void 0 : options.brackets) ?? false;
      }
      get asList() {
        return this.contentsInternal;
      }
      /** Whether `this` has brackets. */
      get hasBrackets() {
        return this.hasBracketsInternal;
      }
      /** `this`'s list separator. */
      get separator() {
        return this.separatorInternal;
      }
      get lengthAsList() {
        return this.contentsInternal.size;
      }
      get(index) {
        return this.contentsInternal.get(index);
      }
      assertList() {
        return this;
      }
      assertMap(name) {
        if (this.contentsInternal.isEmpty())
          return new map_1.SassMap();
        throw (0, utils_1.valueError)(`${this} is not a map`, name);
      }
      /**
       * If `this` is empty, returns an empty OrderedMap.
       *
       * Otherwise, returns null.
       */
      tryMap() {
        return this.contentsInternal.isEmpty() ? new map_1.SassMap() : null;
      }
      equals(other) {
        if ((other instanceof _SassList || other instanceof map_1.SassMap) && this.contentsInternal.isEmpty() && other.asList.isEmpty()) {
          return true;
        }
        if (!(other instanceof _SassList) || this.hasBrackets !== other.hasBrackets || this.separator !== other.separator) {
          return false;
        }
        return this.contentsInternal.equals(other.asList);
      }
      hashCode() {
        return this.contentsInternal.isEmpty() ? emptyListHashCode : this.contentsInternal.hashCode() ^ (0, immutable_1.hash)(this.hasBrackets) ^ (0, immutable_1.hash)(this.separator);
      }
      toString() {
        let string = "";
        if (this.hasBrackets)
          string += "[";
        string += `${this.contentsInternal.join(this.separator === " " || this.separator === null ? " " : `${this.separator} `)}`;
        if (this.hasBrackets)
          string += "]";
        return string;
      }
    };
    exports.SassList = SassList3;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/argument-list.js
var require_argument_list = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/argument-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SassArgumentList = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var list_1 = require_list();
    var SassArgumentList3 = class extends list_1.SassList {
      constructor(contents, keywords, separator, id) {
        super(contents, { separator });
        /**
         * The `FunctionCallRequest`-scoped ID of this argument list, used to tell the
         * compiler which argument lists have had their keywords accessed during a
         * function call.
         *
         * The special ID 0 indicates an argument list constructed in the host.
         *
         * This is marked as public so that the protofier can access it, but it's not
         * part of the package's public API and should not be accessed by user code.
         * It may be renamed or removed without warning in the future.
         */
        __publicField(this, "id");
        /**
         * The argument list's keywords. This isn't exposed directly so that we can
         * set `keywordsAccessed` when the user reads it.
         *
         * This is marked as public so that the protofier can access it, but it's not
         * part of the package's public API and should not be accessed by user code.
         * It may be renamed or removed without warning in the future.
         */
        __publicField(this, "keywordsInternal");
        __publicField(this, "_keywordsAccessed", false);
        this.keywordsInternal = (0, immutable_1.isOrderedMap)(keywords) ? keywords : (0, immutable_1.OrderedMap)(keywords);
        this.id = id ?? 0;
      }
      /**
       * Whether the `keywords` getter has been accessed.
       *
       * This is marked as public so that the protofier can access it, but it's not
       * part of the package's public API and should not be accessed by user code.
       * It may be renamed or removed without warning in the future.
       */
      get keywordsAccessed() {
        return this._keywordsAccessed;
      }
      get keywords() {
        this._keywordsAccessed = true;
        return this.keywordsInternal;
      }
    };
    exports.SassArgumentList = SassArgumentList3;
  }
});

// node_modules/sass-embedded/dist/lib/src/version.js
var require_version = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Version = void 0;
    var Version3 = class _Version {
      constructor(major, minor, patch) {
        __publicField(this, "major");
        __publicField(this, "minor");
        __publicField(this, "patch");
        this.major = major;
        this.minor = minor;
        this.patch = patch;
      }
      static parse(version2) {
        const match = version2.match(/^(\d+)\.(\d+)\.(\d+)$/);
        if (match === null) {
          throw new Error(`Invalid version ${version2}`);
        }
        return new _Version(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
      }
      toString() {
        return `${this.major}.${this.minor}.${this.patch}`;
      }
    };
    exports.Version = Version3;
  }
});

// node_modules/sass-embedded/dist/lib/src/vendor/deprecations.js
var require_deprecations = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/vendor/deprecations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deprecations = void 0;
    var version_1 = require_version();
    exports.deprecations = {
      "call-string": {
        id: "call-string",
        description: "Passing a string directly to meta.call().",
        status: "active",
        deprecatedIn: new version_1.Version(0, 0, 0),
        obsoleteIn: null
      },
      elseif: {
        id: "elseif",
        description: "@elseif.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 3, 2),
        obsoleteIn: null
      },
      "moz-document": {
        id: "moz-document",
        description: "@-moz-document.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 7, 2),
        obsoleteIn: null
      },
      "relative-canonical": {
        id: "relative-canonical",
        description: "Imports using relative canonical URLs.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 14, 2),
        obsoleteIn: null
      },
      "new-global": {
        id: "new-global",
        description: "Declaring new variables with !global.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 17, 2),
        obsoleteIn: null
      },
      "color-module-compat": {
        id: "color-module-compat",
        description: "Using color module functions in place of plain CSS functions.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 23, 0),
        obsoleteIn: null
      },
      "slash-div": {
        id: "slash-div",
        description: "/ operator for division.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 33, 0),
        obsoleteIn: null
      },
      "bogus-combinators": {
        id: "bogus-combinators",
        description: "Leading, trailing, and repeated combinators.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 54, 0),
        obsoleteIn: null
      },
      "strict-unary": {
        id: "strict-unary",
        description: "Ambiguous + and - operators.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 55, 0),
        obsoleteIn: null
      },
      "function-units": {
        id: "function-units",
        description: "Passing invalid units to built-in functions.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 56, 0),
        obsoleteIn: null
      },
      "duplicate-var-flags": {
        id: "duplicate-var-flags",
        description: "Using !default or !global multiple times for one variable.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 62, 0),
        obsoleteIn: null
      },
      "null-alpha": {
        id: "null-alpha",
        description: "Passing null as alpha in the $PLATFORM API.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 62, 3),
        obsoleteIn: null
      },
      "abs-percent": {
        id: "abs-percent",
        description: "Passing percentages to the Sass abs() function.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 65, 0),
        obsoleteIn: null
      },
      "fs-importer-cwd": {
        id: "fs-importer-cwd",
        description: "Using the current working directory as an implicit load path.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 73, 0),
        obsoleteIn: null
      },
      "css-function-mixin": {
        id: "css-function-mixin",
        description: "Function and mixin names beginning with --.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 76, 0),
        obsoleteIn: null
      },
      "mixed-decls": {
        id: "mixed-decls",
        description: "Declarations after or between nested rules.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 77, 7),
        obsoleteIn: null
      },
      "feature-exists": {
        id: "feature-exists",
        description: "meta.feature-exists",
        status: "active",
        deprecatedIn: new version_1.Version(1, 78, 0),
        obsoleteIn: null
      },
      "color-4-api": {
        id: "color-4-api",
        description: "Certain uses of built-in sass:color functions.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 79, 0),
        obsoleteIn: null
      },
      "color-functions": {
        id: "color-functions",
        description: "Using global color functions instead of sass:color.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 79, 0),
        obsoleteIn: null
      },
      "legacy-js-api": {
        id: "legacy-js-api",
        description: "Legacy JS API.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 79, 0),
        obsoleteIn: null
      },
      import: {
        id: "import",
        description: "@import rules.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 80, 0),
        obsoleteIn: null
      },
      "global-builtin": {
        id: "global-builtin",
        description: "Global built-in functions that are available in sass: modules.",
        status: "active",
        deprecatedIn: new version_1.Version(1, 80, 0),
        obsoleteIn: null
      },
      "user-authored": {
        id: "user-authored",
        status: "user",
        deprecatedIn: null,
        obsoleteIn: null
      }
    };
  }
});

// node_modules/sass-embedded/dist/lib/src/deprecations.js
var require_deprecations2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/deprecations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.activeDeprecationOptions = exports.deprecations = void 0;
    exports.getDeprecationIds = getDeprecationIds;
    exports.warnForHostSideDeprecation = warnForHostSideDeprecation;
    var version_1 = require_version();
    var deprecations_1 = require_deprecations();
    Object.defineProperty(exports, "deprecations", { enumerable: true, get: function() {
      return deprecations_1.deprecations;
    } });
    function getDeprecationIds(arr) {
      return arr.map((item) => {
        if (item instanceof version_1.Version) {
          return item.toString();
        } else if (typeof item === "string") {
          return item;
        }
        return item.id;
      });
    }
    exports.activeDeprecationOptions = /* @__PURE__ */ new Map();
    function warnForHostSideDeprecation(message, deprecation, options) {
      if (deprecation.status === "future" && !isEnabledFuture(deprecation, options)) {
        return;
      }
      const fullMessage = `Deprecation [${deprecation.id}]: ${message}`;
      if (isFatal(deprecation, options)) {
        throw Error(fullMessage);
      }
      if (!isSilent(deprecation, options)) {
        console.warn(fullMessage);
      }
    }
    function isSilent(deprecation, options) {
      if (!options) {
        for (const potentialOptions of exports.activeDeprecationOptions.values()) {
          if (isSilent(deprecation, potentialOptions))
            return true;
        }
        return false;
      }
      return getDeprecationIds(options.silenceDeprecations ?? []).includes(deprecation.id);
    }
    function isEnabledFuture(deprecation, options) {
      if (!options) {
        for (const potentialOptions of exports.activeDeprecationOptions.values()) {
          if (!isEnabledFuture(deprecation, potentialOptions))
            return false;
        }
        return exports.activeDeprecationOptions.size > 0;
      }
      return getDeprecationIds(options.futureDeprecations ?? []).includes(deprecation.id);
    }
    function isFatal(deprecation, options) {
      if (!options) {
        for (const potentialOptions of exports.activeDeprecationOptions.values()) {
          if (!isFatal(deprecation, potentialOptions))
            return false;
        }
        return exports.activeDeprecationOptions.size > 0;
      }
      const versionNumber = deprecation.deprecatedIn === null ? null : deprecation.deprecatedIn.major * 1e6 + deprecation.deprecatedIn.minor * 1e3 + deprecation.deprecatedIn.patch;
      for (const fatal of options.fatalDeprecations ?? []) {
        if (fatal instanceof version_1.Version) {
          if (versionNumber === null)
            continue;
          if (versionNumber <= fatal.major * 1e6 + fatal.minor * 1e3 + fatal.patch) {
            return true;
          }
        } else if (typeof fatal === "string") {
          if (fatal === deprecation.id)
            return true;
        } else {
          if (fatal.id === deprecation.id)
            return true;
        }
      }
      return false;
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/value/utils.js
var require_utils2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.precision = void 0;
    exports.fuzzyEquals = fuzzyEquals;
    exports.fuzzyHashCode = fuzzyHashCode;
    exports.fuzzyLessThan = fuzzyLessThan;
    exports.fuzzyLessThanOrEquals = fuzzyLessThanOrEquals;
    exports.fuzzyGreaterThan = fuzzyGreaterThan;
    exports.fuzzyGreaterThanOrEquals = fuzzyGreaterThanOrEquals;
    exports.fuzzyIsInt = fuzzyIsInt;
    exports.fuzzyAsInt = fuzzyAsInt;
    exports.fuzzyRound = fuzzyRound;
    exports.fuzzyInRange = fuzzyInRange;
    exports.fuzzyAssertInRange = fuzzyAssertInRange;
    exports.positiveMod = positiveMod;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var utils_1 = require_utils();
    exports.precision = 10;
    var epsilon = 10 ** (-exports.precision - 1);
    function fuzzyEquals(num1, num2) {
      return Math.abs(num1 - num2) < epsilon;
    }
    function fuzzyHashCode(num) {
      return !isFinite(num) || isNaN(num) ? (0, immutable_1.hash)(num) : (0, immutable_1.hash)(Math.round(num / epsilon));
    }
    function fuzzyLessThan(num1, num2) {
      return num1 < num2 && !fuzzyEquals(num1, num2);
    }
    function fuzzyLessThanOrEquals(num1, num2) {
      return num1 < num2 || fuzzyEquals(num1, num2);
    }
    function fuzzyGreaterThan(num1, num2) {
      return num1 > num2 && !fuzzyEquals(num1, num2);
    }
    function fuzzyGreaterThanOrEquals(num1, num2) {
      return num1 > num2 || fuzzyEquals(num1, num2);
    }
    function fuzzyIsInt(num) {
      return !isFinite(num) || isNaN(num) ? false : (
        // Check against 0.5 rather than 0.0 so that we catch numbers that are
        // both very slightly above an integer, and very slightly below.
        fuzzyEquals(Math.abs(num - 0.5) % 1, 0.5)
      );
    }
    function fuzzyAsInt(num) {
      return fuzzyIsInt(num) ? Math.round(num) : null;
    }
    function fuzzyRound(num) {
      if (num > 0) {
        return fuzzyLessThan(num % 1, 0.5) ? Math.floor(num) : Math.ceil(num);
      } else {
        return fuzzyGreaterThan(num % 1, -0.5) ? Math.ceil(num) : Math.floor(num);
      }
    }
    function fuzzyInRange(num, min2, max2) {
      if (fuzzyEquals(num, min2))
        return min2;
      if (fuzzyEquals(num, max2))
        return max2;
      if (num > min2 && num < max2)
        return num;
      return null;
    }
    function fuzzyAssertInRange(num, min2, max2, name) {
      if (fuzzyEquals(num, min2))
        return min2;
      if (fuzzyEquals(num, max2))
        return max2;
      if (num > min2 && num < max2)
        return num;
      throw (0, utils_1.valueError)(`${num} must be between ${min2} and ${max2}`, name);
    }
    function positiveMod(dividend, modulus) {
      const result = dividend % modulus;
      return result < 0 ? result + modulus : result;
    }
  }
});

// node_modules/colorjs.io/dist/color.cjs
var require_color = __commonJS({
  "node_modules/colorjs.io/dist/color.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function multiplyMatrices(A, B) {
      let m3 = A.length;
      if (!Array.isArray(A[0])) {
        A = [A];
      }
      if (!Array.isArray(B[0])) {
        B = B.map((x) => [x]);
      }
      let p2 = B[0].length;
      let B_cols = B[0].map((_, i) => B.map((x) => x[i]));
      let product = A.map((row) => B_cols.map((col) => {
        let ret = 0;
        if (!Array.isArray(row)) {
          for (let c4 of col) {
            ret += row * c4;
          }
          return ret;
        }
        for (let i = 0; i < row.length; i++) {
          ret += row[i] * (col[i] || 0);
        }
        return ret;
      }));
      if (m3 === 1) {
        product = product[0];
      }
      if (p2 === 1) {
        return product.map((x) => x[0]);
      }
      return product;
    }
    function isString(str) {
      return type(str) === "string";
    }
    function type(o) {
      let str = Object.prototype.toString.call(o);
      return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
    }
    function serializeNumber(n2, { precision, unit }) {
      if (isNone(n2)) {
        return "none";
      }
      return toPrecision(n2, precision) + (unit ?? "");
    }
    function isNone(n2) {
      return Number.isNaN(n2) || n2 instanceof Number && (n2 == null ? void 0 : n2.none);
    }
    function skipNone(n2) {
      return isNone(n2) ? 0 : n2;
    }
    function toPrecision(n2, precision) {
      if (n2 === 0) {
        return 0;
      }
      let integer = ~~n2;
      let digits = 0;
      if (integer && precision) {
        digits = ~~Math.log10(Math.abs(integer)) + 1;
      }
      const multiplier = 10 ** (precision - digits);
      return Math.floor(n2 * multiplier + 0.5) / multiplier;
    }
    var angleFactor = {
      deg: 1,
      grad: 0.9,
      rad: 180 / Math.PI,
      turn: 360
    };
    function parseFunction(str) {
      if (!str) {
        return;
      }
      str = str.trim();
      const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
      const isNumberRegex = /^-?[\d.]+$/;
      const unitValueRegex = /%|deg|g?rad|turn$/;
      const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
      let parts = str.match(isFunctionRegex);
      if (parts) {
        let args = [];
        parts[2].replace(singleArgument, ($0, rawArg) => {
          let match = rawArg.match(unitValueRegex);
          let arg = rawArg;
          if (match) {
            let unit = match[0];
            let unitlessArg = arg.slice(0, -unit.length);
            if (unit === "%") {
              arg = new Number(unitlessArg / 100);
              arg.type = "<percentage>";
            } else {
              arg = new Number(unitlessArg * angleFactor[unit]);
              arg.type = "<angle>";
              arg.unit = unit;
            }
          } else if (isNumberRegex.test(arg)) {
            arg = new Number(arg);
            arg.type = "<number>";
          } else if (arg === "none") {
            arg = new Number(NaN);
            arg.none = true;
          }
          if ($0.startsWith("/")) {
            arg = arg instanceof Number ? arg : new Number(arg);
            arg.alpha = true;
          }
          if (typeof arg === "object" && arg instanceof Number) {
            arg.raw = rawArg;
          }
          args.push(arg);
        });
        return {
          name: parts[1].toLowerCase(),
          rawName: parts[1],
          rawArgs: parts[2],
          // An argument could be (as of css-color-4):
          // a number, percentage, degrees (hue), ident (in color())
          args
        };
      }
    }
    function last3(arr) {
      return arr[arr.length - 1];
    }
    function interpolate(start, end, p2) {
      if (isNaN(start)) {
        return end;
      }
      if (isNaN(end)) {
        return start;
      }
      return start + (end - start) * p2;
    }
    function interpolateInv(start, end, value) {
      return (value - start) / (end - start);
    }
    function mapRange(from, to2, value) {
      return interpolate(to2[0], to2[1], interpolateInv(from[0], from[1], value));
    }
    function parseCoordGrammar(coordGrammars) {
      return coordGrammars.map((coordGrammar2) => {
        return coordGrammar2.split("|").map((type2) => {
          type2 = type2.trim();
          let range2 = type2.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
          if (range2) {
            let ret = new String(range2[1]);
            ret.range = [+range2[2], +range2[3]];
            return ret;
          }
          return type2;
        });
      });
    }
    function clamp(min2, val, max3) {
      return Math.max(Math.min(max3, val), min2);
    }
    function copySign(to2, from) {
      return Math.sign(to2) === Math.sign(from) ? to2 : -to2;
    }
    function spow(base, exp) {
      return copySign(Math.abs(base) ** exp, base);
    }
    function zdiv(n2, d2) {
      return d2 === 0 ? 0 : n2 / d2;
    }
    function bisectLeft(arr, value, lo = 0, hi = arr.length) {
      while (lo < hi) {
        const mid = lo + hi >> 1;
        if (arr[mid] < value) {
          lo = mid + 1;
        } else {
          hi = mid;
        }
      }
      return lo;
    }
    var util = Object.freeze({
      __proto__: null,
      bisectLeft,
      clamp,
      copySign,
      interpolate,
      interpolateInv,
      isNone,
      isString,
      last: last3,
      mapRange,
      multiplyMatrices,
      parseCoordGrammar,
      parseFunction,
      serializeNumber,
      skipNone,
      spow,
      toPrecision,
      type,
      zdiv
    });
    var Hooks = class {
      add(name, callback, first3) {
        if (typeof arguments[0] != "string") {
          for (var name in arguments[0]) {
            this.add(name, arguments[0][name], arguments[1]);
          }
          return;
        }
        (Array.isArray(name) ? name : [name]).forEach(function(name2) {
          this[name2] = this[name2] || [];
          if (callback) {
            this[name2][first3 ? "unshift" : "push"](callback);
          }
        }, this);
      }
      run(name, env) {
        this[name] = this[name] || [];
        this[name].forEach(function(callback) {
          callback.call(env && env.context ? env.context : env, env);
        });
      }
    };
    var hooks = new Hooks();
    var _a, _b, _c;
    var defaults = {
      gamut_mapping: "css",
      precision: 5,
      deltaE: "76",
      // Default deltaE method
      verbose: ((_c = (_b = (_a = globalThis == null ? void 0 : globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.NODE_ENV) == null ? void 0 : _c.toLowerCase()) !== "test",
      warn: function warn(msg) {
        var _a2, _b2;
        if (this.verbose) {
          (_b2 = (_a2 = globalThis == null ? void 0 : globalThis.console) == null ? void 0 : _a2.warn) == null ? void 0 : _b2.call(_a2, msg);
        }
      }
    };
    var WHITES = {
      // for compatibility, the four-digit chromaticity-derived ones everyone else uses
      D50: [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585],
      D65: [0.3127 / 0.329, 1, (1 - 0.3127 - 0.329) / 0.329]
    };
    function getWhite(name) {
      if (Array.isArray(name)) {
        return name;
      }
      return WHITES[name];
    }
    function adapt$2(W1, W2, XYZ, options = {}) {
      W1 = getWhite(W1);
      W2 = getWhite(W2);
      if (!W1 || !W2) {
        throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
      }
      if (W1 === W2) {
        return XYZ;
      }
      let env = { W1, W2, XYZ, options };
      hooks.run("chromatic-adaptation-start", env);
      if (!env.M) {
        if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
          env.M = [
            [1.0479297925449969, 0.022946870601609652, -0.05019226628920524],
            [0.02962780877005599, 0.9904344267538799, -0.017073799063418826],
            [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]
          ];
        } else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {
          env.M = [
            [0.955473421488075, -0.02309845494876471, 0.06325924320057072],
            [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323],
            [0.012314014864481998, -0.020507649298898964, 1.330365926242124]
          ];
        }
      }
      hooks.run("chromatic-adaptation-end", env);
      if (env.M) {
        return multiplyMatrices(env.M, env.XYZ);
      } else {
        throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
      }
    }
    var noneTypes = /* @__PURE__ */ new Set(["<number>", "<percentage>", "<angle>"]);
    function coerceCoords(space, format, name, coords) {
      let types3 = Object.entries(space.coords).map(([id, coordMeta], i) => {
        let coordGrammar2 = format.coordGrammar[i];
        let arg = coords[i];
        let providedType = arg == null ? void 0 : arg.type;
        let type2;
        if (arg.none) {
          type2 = coordGrammar2.find((c4) => noneTypes.has(c4));
        } else {
          type2 = coordGrammar2.find((c4) => c4 == providedType);
        }
        if (!type2) {
          let coordName = coordMeta.name || id;
          throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
        }
        let fromRange = type2.range;
        if (providedType === "<percentage>") {
          fromRange || (fromRange = [0, 1]);
        }
        let toRange = coordMeta.range || coordMeta.refRange;
        if (fromRange && toRange) {
          coords[i] = mapRange(fromRange, toRange, coords[i]);
        }
        return type2;
      });
      return types3;
    }
    function parse(str, { meta } = {}) {
      var _a2, _b2, _c2, _d;
      let env = { "str": (_a2 = String(str)) == null ? void 0 : _a2.trim() };
      hooks.run("parse-start", env);
      if (env.color) {
        return env.color;
      }
      env.parsed = parseFunction(env.str);
      if (env.parsed) {
        let name = env.parsed.name;
        if (name === "color") {
          let id = env.parsed.args.shift();
          let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
          let ids = [id, alternateId];
          let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
          for (let space of ColorSpace.all) {
            let colorSpec = space.getFormat("color");
            if (colorSpec) {
              if (ids.includes(colorSpec.id) || ((_b2 = colorSpec.ids) == null ? void 0 : _b2.filter((specId) => ids.includes(specId)).length)) {
                const coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);
                let types3;
                if (colorSpec.coordGrammar) {
                  types3 = coerceCoords(space, colorSpec, "color", coords);
                }
                if (meta) {
                  Object.assign(meta, { formatId: "color", types: types3 });
                }
                if (colorSpec.id.startsWith("--") && !id.startsWith("--")) {
                  defaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
                }
                if (id.startsWith("--") && !colorSpec.id.startsWith("--")) {
                  defaults.warn(`${space.name} is a standard space and supported in the CSS spec. Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
                }
                return { spaceId: space.id, coords, alpha };
              }
            }
          }
          let didYouMean = "";
          let registryId = id in ColorSpace.registry ? id : alternateId;
          if (registryId in ColorSpace.registry) {
            let cssId = (_d = (_c2 = ColorSpace.registry[registryId].formats) == null ? void 0 : _c2.color) == null ? void 0 : _d.id;
            if (cssId) {
              didYouMean = `Did you mean color(${cssId})?`;
            }
          }
          throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
        } else {
          for (let space of ColorSpace.all) {
            let format = space.getFormat(name);
            if (format && format.type === "function") {
              let alpha = 1;
              if (format.lastAlpha || last3(env.parsed.args).alpha) {
                alpha = env.parsed.args.pop();
              }
              let coords = env.parsed.args;
              let types3;
              if (format.coordGrammar) {
                types3 = coerceCoords(space, format, name, coords);
              }
              if (meta) {
                Object.assign(meta, { formatId: format.name, types: types3 });
              }
              return {
                spaceId: space.id,
                coords,
                alpha
              };
            }
          }
        }
      } else {
        for (let space of ColorSpace.all) {
          for (let formatId in space.formats) {
            let format = space.formats[formatId];
            if (format.type !== "custom") {
              continue;
            }
            if (format.test && !format.test(env.str)) {
              continue;
            }
            let color = format.parse(env.str);
            if (color) {
              color.alpha ?? (color.alpha = 1);
              if (meta) {
                meta.formatId = formatId;
              }
              return color;
            }
          }
        }
      }
      throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
    }
    function getColor(color) {
      if (Array.isArray(color)) {
        return color.map(getColor);
      }
      if (!color) {
        throw new TypeError("Empty color reference");
      }
      if (isString(color)) {
        color = parse(color);
      }
      let space = color.space || color.spaceId;
      if (!(space instanceof ColorSpace)) {
        color.space = ColorSpace.get(space);
      }
      if (color.alpha === void 0) {
        color.alpha = 1;
      }
      return color;
    }
    var ε$7 = 75e-6;
    var _ColorSpace = class _ColorSpace {
      constructor(options) {
        var _a2;
        this.id = options.id;
        this.name = options.name;
        this.base = options.base ? _ColorSpace.get(options.base) : null;
        this.aliases = options.aliases;
        if (this.base) {
          this.fromBase = options.fromBase;
          this.toBase = options.toBase;
        }
        let coords = options.coords ?? this.base.coords;
        for (let name in coords) {
          if (!("name" in coords[name])) {
            coords[name].name = name;
          }
        }
        this.coords = coords;
        let white2 = options.white ?? this.base.white ?? "D65";
        this.white = getWhite(white2);
        this.formats = options.formats ?? {};
        for (let name in this.formats) {
          let format = this.formats[name];
          format.type || (format.type = "function");
          format.name || (format.name = name);
        }
        if (!((_a2 = this.formats.color) == null ? void 0 : _a2.id)) {
          this.formats.color = {
            ...this.formats.color ?? {},
            id: options.cssId || this.id
          };
        }
        if (options.gamutSpace) {
          this.gamutSpace = options.gamutSpace === "self" ? this : _ColorSpace.get(options.gamutSpace);
        } else {
          if (this.isPolar) {
            this.gamutSpace = this.base;
          } else {
            this.gamutSpace = this;
          }
        }
        if (this.gamutSpace.isUnbounded) {
          this.inGamut = (coords2, options2) => {
            return true;
          };
        }
        this.referred = options.referred;
        Object.defineProperty(this, "path", {
          value: getPath(this).reverse(),
          writable: false,
          enumerable: true,
          configurable: true
        });
        hooks.run("colorspace-init-end", this);
      }
      inGamut(coords, { epsilon = ε$7 } = {}) {
        if (!this.equals(this.gamutSpace)) {
          coords = this.to(this.gamutSpace, coords);
          return this.gamutSpace.inGamut(coords, { epsilon });
        }
        let coordMeta = Object.values(this.coords);
        return coords.every((c4, i) => {
          let meta = coordMeta[i];
          if (meta.type !== "angle" && meta.range) {
            if (Number.isNaN(c4)) {
              return true;
            }
            let [min2, max3] = meta.range;
            return (min2 === void 0 || c4 >= min2 - epsilon) && (max3 === void 0 || c4 <= max3 + epsilon);
          }
          return true;
        });
      }
      get isUnbounded() {
        return Object.values(this.coords).every((coord) => !("range" in coord));
      }
      get cssId() {
        var _a2, _b2;
        return ((_b2 = (_a2 = this.formats) == null ? void 0 : _a2.color) == null ? void 0 : _b2.id) || this.id;
      }
      get isPolar() {
        for (let id in this.coords) {
          if (this.coords[id].type === "angle") {
            return true;
          }
        }
        return false;
      }
      getFormat(format) {
        if (typeof format === "object") {
          format = processFormat(format, this);
          return format;
        }
        let ret;
        if (format === "default") {
          ret = Object.values(this.formats)[0];
        } else {
          ret = this.formats[format];
        }
        if (ret) {
          ret = processFormat(ret, this);
          return ret;
        }
        return null;
      }
      /**
       * Check if this color space is the same as another color space reference.
       * Allows proxying color space objects and comparing color spaces with ids.
       * @param {string | ColorSpace} space ColorSpace object or id to compare to
       * @returns {boolean}
       */
      equals(space) {
        if (!space) {
          return false;
        }
        return this === space || this.id === space || this.id === space.id;
      }
      to(space, coords) {
        if (arguments.length === 1) {
          const color = getColor(space);
          [space, coords] = [color.space, color.coords];
        }
        space = _ColorSpace.get(space);
        if (this.equals(space)) {
          return coords;
        }
        coords = coords.map((c4) => Number.isNaN(c4) ? 0 : c4);
        let myPath = this.path;
        let otherPath = space.path;
        let connectionSpace, connectionSpaceIndex;
        for (let i = 0; i < myPath.length; i++) {
          if (myPath[i].equals(otherPath[i])) {
            connectionSpace = myPath[i];
            connectionSpaceIndex = i;
          } else {
            break;
          }
        }
        if (!connectionSpace) {
          throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
        }
        for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {
          coords = myPath[i].toBase(coords);
        }
        for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {
          coords = otherPath[i].fromBase(coords);
        }
        return coords;
      }
      from(space, coords) {
        if (arguments.length === 1) {
          const color = getColor(space);
          [space, coords] = [color.space, color.coords];
        }
        space = _ColorSpace.get(space);
        return space.to(this, coords);
      }
      toString() {
        return `${this.name} (${this.id})`;
      }
      getMinCoords() {
        let ret = [];
        for (let id in this.coords) {
          let meta = this.coords[id];
          let range2 = meta.range || meta.refRange;
          ret.push((range2 == null ? void 0 : range2.min) ?? 0);
        }
        return ret;
      }
      // Returns array of unique color spaces
      static get all() {
        return [...new Set(Object.values(_ColorSpace.registry))];
      }
      static register(id, space) {
        if (arguments.length === 1) {
          space = arguments[0];
          id = space.id;
        }
        space = this.get(space);
        if (this.registry[id] && this.registry[id] !== space) {
          throw new Error(`Duplicate color space registration: '${id}'`);
        }
        this.registry[id] = space;
        if (arguments.length === 1 && space.aliases) {
          for (let alias of space.aliases) {
            this.register(alias, space);
          }
        }
        return space;
      }
      /**
       * Lookup ColorSpace object by name
       * @param {ColorSpace | string} name
       */
      static get(space, ...alternatives) {
        if (!space || space instanceof _ColorSpace) {
          return space;
        }
        let argType = type(space);
        if (argType === "string") {
          let ret = _ColorSpace.registry[space.toLowerCase()];
          if (!ret) {
            throw new TypeError(`No color space found with id = "${space}"`);
          }
          return ret;
        }
        if (alternatives.length) {
          return _ColorSpace.get(...alternatives);
        }
        throw new TypeError(`${space} is not a valid color space`);
      }
      /**
       * Get metadata about a coordinate of a color space
       *
       * @static
       * @param {Array | string} ref
       * @param {ColorSpace | string} [workingSpace]
       * @return {Object}
       */
      static resolveCoord(ref, workingSpace) {
        var _a2;
        let coordType = type(ref);
        let space, coord;
        if (coordType === "string") {
          if (ref.includes(".")) {
            [space, coord] = ref.split(".");
          } else {
            [space, coord] = [, ref];
          }
        } else if (Array.isArray(ref)) {
          [space, coord] = ref;
        } else {
          space = ref.space;
          coord = ref.coordId;
        }
        space = _ColorSpace.get(space);
        if (!space) {
          space = workingSpace;
        }
        if (!space) {
          throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
        }
        coordType = type(coord);
        if (coordType === "number" || coordType === "string" && coord >= 0) {
          let meta = Object.entries(space.coords)[coord];
          if (meta) {
            return { space, id: meta[0], index: coord, ...meta[1] };
          }
        }
        space = _ColorSpace.get(space);
        let normalizedCoord = coord.toLowerCase();
        let i = 0;
        for (let id in space.coords) {
          let meta = space.coords[id];
          if (id.toLowerCase() === normalizedCoord || ((_a2 = meta.name) == null ? void 0 : _a2.toLowerCase()) === normalizedCoord) {
            return { space, id, index: i, ...meta };
          }
          i++;
        }
        throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
      }
    };
    __publicField(_ColorSpace, "registry", {});
    __publicField(_ColorSpace, "DEFAULT_FORMAT", {
      type: "functions",
      name: "color"
    });
    var ColorSpace = _ColorSpace;
    function getPath(space) {
      let ret = [space];
      for (let s = space; s = s.base; ) {
        ret.push(s);
      }
      return ret;
    }
    function processFormat(format, { coords } = {}) {
      if (format.coords && !format.coordGrammar) {
        format.type || (format.type = "function");
        format.name || (format.name = "color");
        format.coordGrammar = parseCoordGrammar(format.coords);
        let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {
          let outputType = format.coordGrammar[i][0];
          let fromRange = coordMeta.range || coordMeta.refRange;
          let toRange = outputType.range, suffix = "";
          if (outputType == "<percentage>") {
            toRange = [0, 100];
            suffix = "%";
          } else if (outputType == "<angle>") {
            suffix = "deg";
          }
          return { fromRange, toRange, suffix };
        });
        format.serializeCoords = (coords2, precision) => {
          return coords2.map((c4, i) => {
            let { fromRange, toRange, suffix } = coordFormats[i];
            if (fromRange && toRange) {
              c4 = mapRange(fromRange, toRange, c4);
            }
            c4 = serializeNumber(c4, { precision, unit: suffix });
            return c4;
          });
        };
      }
      return format;
    }
    var xyz_d65 = new ColorSpace({
      id: "xyz-d65",
      name: "XYZ D65",
      coords: {
        x: { name: "X" },
        y: { name: "Y" },
        z: { name: "Z" }
      },
      white: "D65",
      formats: {
        color: {
          ids: ["xyz-d65", "xyz"]
        }
      },
      aliases: ["xyz"]
    });
    var RGBColorSpace = class extends ColorSpace {
      /**
       * Creates a new RGB ColorSpace.
       * If coords are not specified, they will use the default RGB coords.
       * Instead of `fromBase()` and `toBase()` functions,
       * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.
       * @param {*} options - Same options as {@link ColorSpace} plus:
       * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ
       * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ
       */
      constructor(options) {
        if (!options.coords) {
          options.coords = {
            r: {
              range: [0, 1],
              name: "Red"
            },
            g: {
              range: [0, 1],
              name: "Green"
            },
            b: {
              range: [0, 1],
              name: "Blue"
            }
          };
        }
        if (!options.base) {
          options.base = xyz_d65;
        }
        if (options.toXYZ_M && options.fromXYZ_M) {
          options.toBase ?? (options.toBase = (rgb) => {
            let xyz = multiplyMatrices(options.toXYZ_M, rgb);
            if (this.white !== this.base.white) {
              xyz = adapt$2(this.white, this.base.white, xyz);
            }
            return xyz;
          });
          options.fromBase ?? (options.fromBase = (xyz) => {
            xyz = adapt$2(this.base.white, this.white, xyz);
            return multiplyMatrices(options.fromXYZ_M, xyz);
          });
        }
        options.referred ?? (options.referred = "display");
        super(options);
      }
    };
    function getAll(color, space) {
      color = getColor(color);
      if (!space || color.space.equals(space)) {
        return color.coords.slice();
      }
      space = ColorSpace.get(space);
      return space.from(color);
    }
    function get11(color, prop) {
      color = getColor(color);
      let { space, index } = ColorSpace.resolveCoord(prop, color.space);
      let coords = getAll(color, space);
      return coords[index];
    }
    function setAll(color, space, coords) {
      color = getColor(color);
      space = ColorSpace.get(space);
      color.coords = space.to(color.space, coords);
      return color;
    }
    setAll.returns = "color";
    function set3(color, prop, value) {
      color = getColor(color);
      if (arguments.length === 2 && type(arguments[1]) === "object") {
        let object = arguments[1];
        for (let p2 in object) {
          set3(color, p2, object[p2]);
        }
      } else {
        if (typeof value === "function") {
          value = value(get11(color, prop));
        }
        let { space, index } = ColorSpace.resolveCoord(prop, color.space);
        let coords = getAll(color, space);
        coords[index] = value;
        setAll(color, space, coords);
      }
      return color;
    }
    set3.returns = "color";
    var XYZ_D50 = new ColorSpace({
      id: "xyz-d50",
      name: "XYZ D50",
      white: "D50",
      base: xyz_d65,
      fromBase: (coords) => adapt$2(xyz_d65.white, "D50", coords),
      toBase: (coords) => adapt$2("D50", xyz_d65.white, coords)
    });
    var ε$6 = 216 / 24389;
    var ε3$1 = 24 / 116;
    var κ$4 = 24389 / 27;
    var white$4 = WHITES.D50;
    var lab = new ColorSpace({
      id: "lab",
      name: "Lab",
      coords: {
        l: {
          refRange: [0, 100],
          name: "Lightness"
        },
        a: {
          refRange: [-125, 125]
        },
        b: {
          refRange: [-125, 125]
        }
      },
      // Assuming XYZ is relative to D50, convert to CIE Lab
      // from CIE standard, which now defines these as a rational fraction
      white: white$4,
      base: XYZ_D50,
      // Convert D50-adapted XYX to Lab
      //  CIE 15.3:2004 section 8.2.1.1
      fromBase(XYZ) {
        let xyz = XYZ.map((value, i) => value / white$4[i]);
        let f = xyz.map((value) => value > ε$6 ? Math.cbrt(value) : (κ$4 * value + 16) / 116);
        return [
          116 * f[1] - 16,
          // L
          500 * (f[0] - f[1]),
          // a
          200 * (f[1] - f[2])
          // b
        ];
      },
      // Convert Lab to D50-adapted XYZ
      // Same result as CIE 15.3:2004 Appendix D although the derivation is different
      // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
      toBase(Lab) {
        let f = [];
        f[1] = (Lab[0] + 16) / 116;
        f[0] = Lab[1] / 500 + f[1];
        f[2] = f[1] - Lab[2] / 200;
        let xyz = [
          f[0] > ε3$1 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$4,
          Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ$4,
          f[2] > ε3$1 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$4
        ];
        return xyz.map((value, i) => value * white$4[i]);
      },
      formats: {
        "lab": {
          coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
        }
      }
    });
    function constrain(angle) {
      return (angle % 360 + 360) % 360;
    }
    function adjust(arc, angles) {
      if (arc === "raw") {
        return angles;
      }
      let [a1, a2] = angles.map(constrain);
      let angleDiff = a2 - a1;
      if (arc === "increasing") {
        if (angleDiff < 0) {
          a2 += 360;
        }
      } else if (arc === "decreasing") {
        if (angleDiff > 0) {
          a1 += 360;
        }
      } else if (arc === "longer") {
        if (-180 < angleDiff && angleDiff < 180) {
          if (angleDiff > 0) {
            a1 += 360;
          } else {
            a2 += 360;
          }
        }
      } else if (arc === "shorter") {
        if (angleDiff > 180) {
          a1 += 360;
        } else if (angleDiff < -180) {
          a2 += 360;
        }
      }
      return [a1, a2];
    }
    var lch = new ColorSpace({
      id: "lch",
      name: "LCH",
      coords: {
        l: {
          refRange: [0, 100],
          name: "Lightness"
        },
        c: {
          refRange: [0, 150],
          name: "Chroma"
        },
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        }
      },
      base: lab,
      fromBase(Lab) {
        let [L, a2, b2] = Lab;
        let hue;
        const ε2 = 0.02;
        if (Math.abs(a2) < ε2 && Math.abs(b2) < ε2) {
          hue = NaN;
        } else {
          hue = Math.atan2(b2, a2) * 180 / Math.PI;
        }
        return [
          L,
          // L is still L
          Math.sqrt(a2 ** 2 + b2 ** 2),
          // Chroma
          constrain(hue)
          // Hue, in degrees [0 to 360)
        ];
      },
      toBase(LCH) {
        let [Lightness, Chroma, Hue] = LCH;
        if (Chroma < 0) {
          Chroma = 0;
        }
        if (isNaN(Hue)) {
          Hue = 0;
        }
        return [
          Lightness,
          // L is still L
          Chroma * Math.cos(Hue * Math.PI / 180),
          // a
          Chroma * Math.sin(Hue * Math.PI / 180)
          // b
        ];
      },
      formats: {
        "lch": {
          coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
        }
      }
    });
    var Gfactor = 25 ** 7;
    var π$1 = Math.PI;
    var r2d = 180 / π$1;
    var d2r$1 = π$1 / 180;
    function pow7(x) {
      const x2 = x * x;
      const x7 = x2 * x2 * x2 * x;
      return x7;
    }
    function deltaE2000(color, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
      [color, sample] = getColor([color, sample]);
      let [L1, a1, b1] = lab.from(color);
      let C1 = lch.from(lab, [L1, a1, b1])[1];
      let [L2, a2, b2] = lab.from(sample);
      let C2 = lch.from(lab, [L2, a2, b2])[1];
      if (C1 < 0) {
        C1 = 0;
      }
      if (C2 < 0) {
        C2 = 0;
      }
      let Cbar = (C1 + C2) / 2;
      let C7 = pow7(Cbar);
      let G = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
      let adash1 = (1 + G) * a1;
      let adash2 = (1 + G) * a2;
      let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
      let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);
      let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
      let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);
      if (h1 < 0) {
        h1 += 2 * π$1;
      }
      if (h2 < 0) {
        h2 += 2 * π$1;
      }
      h1 *= r2d;
      h2 *= r2d;
      let ΔL = L2 - L1;
      let ΔC = Cdash2 - Cdash1;
      let hdiff = h2 - h1;
      let hsum = h1 + h2;
      let habs = Math.abs(hdiff);
      let Δh;
      if (Cdash1 * Cdash2 === 0) {
        Δh = 0;
      } else if (habs <= 180) {
        Δh = hdiff;
      } else if (hdiff > 180) {
        Δh = hdiff - 360;
      } else if (hdiff < -180) {
        Δh = hdiff + 360;
      } else {
        defaults.warn("the unthinkable has happened");
      }
      let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);
      let Ldash = (L1 + L2) / 2;
      let Cdash = (Cdash1 + Cdash2) / 2;
      let Cdash7 = pow7(Cdash);
      let hdash;
      if (Cdash1 * Cdash2 === 0) {
        hdash = hsum;
      } else if (habs <= 180) {
        hdash = hsum / 2;
      } else if (hsum < 360) {
        hdash = (hsum + 360) / 2;
      } else {
        hdash = (hsum - 360) / 2;
      }
      let lsq = (Ldash - 50) ** 2;
      let SL = 1 + 0.015 * lsq / Math.sqrt(20 + lsq);
      let SC = 1 + 0.045 * Cdash;
      let T = 1;
      T -= 0.17 * Math.cos((hdash - 30) * d2r$1);
      T += 0.24 * Math.cos(2 * hdash * d2r$1);
      T += 0.32 * Math.cos((3 * hdash + 6) * d2r$1);
      T -= 0.2 * Math.cos((4 * hdash - 63) * d2r$1);
      let SH = 1 + 0.015 * Cdash * T;
      let Δθ = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
      let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
      let RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;
      let dE = (ΔL / (kL * SL)) ** 2;
      dE += (ΔC / (kC * SC)) ** 2;
      dE += (ΔH / (kH * SH)) ** 2;
      dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));
      return Math.sqrt(dE);
    }
    var XYZtoLMS_M$1 = [
      [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
      [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
      [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
    ];
    var LMStoXYZ_M$1 = [
      [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
      [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
      [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
    ];
    var LMStoLab_M = [
      [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
      [1.9779985324311684, -2.42859224204858, 0.450593709617411],
      [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
    ];
    var LabtoLMS_M = [
      [1, 0.3963377773761749, 0.2158037573099136],
      [1, -0.1055613458156586, -0.0638541728258133],
      [1, -0.0894841775298119, -1.2914855480194092]
    ];
    var OKLab = new ColorSpace({
      id: "oklab",
      name: "Oklab",
      coords: {
        l: {
          refRange: [0, 1],
          name: "Lightness"
        },
        a: {
          refRange: [-0.4, 0.4]
        },
        b: {
          refRange: [-0.4, 0.4]
        }
      },
      // Note that XYZ is relative to D65
      white: "D65",
      base: xyz_d65,
      fromBase(XYZ) {
        let LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);
        let LMSg = LMS.map((val) => Math.cbrt(val));
        return multiplyMatrices(LMStoLab_M, LMSg);
      },
      toBase(OKLab2) {
        let LMSg = multiplyMatrices(LabtoLMS_M, OKLab2);
        let LMS = LMSg.map((val) => val ** 3);
        return multiplyMatrices(LMStoXYZ_M$1, LMS);
      },
      formats: {
        "oklab": {
          coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
        }
      }
    });
    function deltaEOK(color, sample) {
      [color, sample] = getColor([color, sample]);
      let [L1, a1, b1] = OKLab.from(color);
      let [L2, a2, b2] = OKLab.from(sample);
      let ΔL = L1 - L2;
      let Δa = a1 - a2;
      let Δb = b1 - b2;
      return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);
    }
    var ε$5 = 75e-6;
    function inGamut(color, space, { epsilon = ε$5 } = {}) {
      color = getColor(color);
      if (!space) {
        space = color.space;
      }
      space = ColorSpace.get(space);
      let coords = color.coords;
      if (space !== color.space) {
        coords = space.from(color);
      }
      return space.inGamut(coords, { epsilon });
    }
    function clone(color) {
      return {
        space: color.space,
        coords: color.coords.slice(),
        alpha: color.alpha
      };
    }
    function distance(color1, color2, space = "lab") {
      space = ColorSpace.get(space);
      let coords1 = space.from(color1);
      let coords2 = space.from(color2);
      return Math.sqrt(coords1.reduce((acc, c12, i) => {
        let c22 = coords2[i];
        if (isNaN(c12) || isNaN(c22)) {
          return acc;
        }
        return acc + (c22 - c12) ** 2;
      }, 0));
    }
    function deltaE76(color, sample) {
      return distance(color, sample, "lab");
    }
    var π = Math.PI;
    var d2r = π / 180;
    function deltaECMC(color, sample, { l = 2, c: c4 = 1 } = {}) {
      [color, sample] = getColor([color, sample]);
      let [L1, a1, b1] = lab.from(color);
      let [, C1, H1] = lch.from(lab, [L1, a1, b1]);
      let [L2, a2, b2] = lab.from(sample);
      let C2 = lch.from(lab, [L2, a2, b2])[1];
      if (C1 < 0) {
        C1 = 0;
      }
      if (C2 < 0) {
        C2 = 0;
      }
      let ΔL = L1 - L2;
      let ΔC = C1 - C2;
      let Δa = a1 - a2;
      let Δb = b1 - b2;
      let H2 = Δa ** 2 + Δb ** 2 - ΔC ** 2;
      let SL = 0.511;
      if (L1 >= 16) {
        SL = 0.040975 * L1 / (1 + 0.01765 * L1);
      }
      let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;
      let T;
      if (Number.isNaN(H1)) {
        H1 = 0;
      }
      if (H1 >= 164 && H1 <= 345) {
        T = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));
      } else {
        T = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));
      }
      let C4 = Math.pow(C1, 4);
      let F = Math.sqrt(C4 / (C4 + 1900));
      let SH = SC * (F * T + 1 - F);
      let dE = (ΔL / (l * SL)) ** 2;
      dE += (ΔC / (c4 * SC)) ** 2;
      dE += H2 / SH ** 2;
      return Math.sqrt(dE);
    }
    var Yw$1 = 203;
    var XYZ_Abs_D65 = new ColorSpace({
      // Absolute CIE XYZ, with a D65 whitepoint,
      // as used in most HDR colorspaces as a starting point.
      // SDR spaces are converted per BT.2048
      // so that diffuse, media white is 203 cd/m²
      id: "xyz-abs-d65",
      cssId: "--xyz-abs-d65",
      name: "Absolute XYZ D65",
      coords: {
        x: {
          refRange: [0, 9504.7],
          name: "Xa"
        },
        y: {
          refRange: [0, 1e4],
          name: "Ya"
        },
        z: {
          refRange: [0, 10888.3],
          name: "Za"
        }
      },
      base: xyz_d65,
      fromBase(XYZ) {
        return XYZ.map((v) => Math.max(v * Yw$1, 0));
      },
      toBase(AbsXYZ) {
        return AbsXYZ.map((v) => Math.max(v / Yw$1, 0));
      }
    });
    var b$1 = 1.15;
    var g = 0.66;
    var n$1 = 2610 / 2 ** 14;
    var ninv$1 = 2 ** 14 / 2610;
    var c1$2 = 3424 / 2 ** 12;
    var c2$2 = 2413 / 2 ** 7;
    var c3$2 = 2392 / 2 ** 7;
    var p = 1.7 * 2523 / 2 ** 5;
    var pinv = 2 ** 5 / (1.7 * 2523);
    var d = -0.56;
    var d0 = 16295499532821565e-27;
    var XYZtoCone_M = [
      [0.41478972, 0.579999, 0.014648],
      [-0.20151, 1.120649, 0.0531008],
      [-0.0166008, 0.2648, 0.6684799]
    ];
    var ConetoXYZ_M = [
      [1.9242264357876067, -1.0047923125953657, 0.037651404030618],
      [0.35031676209499907, 0.7264811939316552, -0.06538442294808501],
      [-0.09098281098284752, -0.3127282905230739, 1.5227665613052603]
    ];
    var ConetoIab_M = [
      [0.5, 0.5, 0],
      [3.524, -4.066708, 0.542708],
      [0.199076, 1.096799, -1.295875]
    ];
    var IabtoCone_M = [
      [1, 0.1386050432715393, 0.05804731615611886],
      [0.9999999999999999, -0.1386050432715393, -0.05804731615611886],
      [0.9999999999999998, -0.09601924202631895, -0.8118918960560388]
    ];
    var Jzazbz = new ColorSpace({
      id: "jzazbz",
      name: "Jzazbz",
      coords: {
        jz: {
          refRange: [0, 1],
          name: "Jz"
        },
        az: {
          refRange: [-0.5, 0.5]
        },
        bz: {
          refRange: [-0.5, 0.5]
        }
      },
      base: XYZ_Abs_D65,
      fromBase(XYZ) {
        let [Xa, Ya, Za] = XYZ;
        let Xm = b$1 * Xa - (b$1 - 1) * Za;
        let Ym = g * Ya - (g - 1) * Xa;
        let LMS = multiplyMatrices(XYZtoCone_M, [Xm, Ym, Za]);
        let PQLMS = LMS.map(function(val) {
          let num = c1$2 + c2$2 * (val / 1e4) ** n$1;
          let denom = 1 + c3$2 * (val / 1e4) ** n$1;
          return (num / denom) ** p;
        });
        let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
        let Jz = (1 + d) * Iz / (1 + d * Iz) - d0;
        return [Jz, az, bz];
      },
      toBase(Jzazbz2) {
        let [Jz, az, bz] = Jzazbz2;
        let Iz = (Jz + d0) / (1 + d - d * (Jz + d0));
        let PQLMS = multiplyMatrices(IabtoCone_M, [Iz, az, bz]);
        let LMS = PQLMS.map(function(val) {
          let num = c1$2 - val ** pinv;
          let denom = c3$2 * val ** pinv - c2$2;
          let x = 1e4 * (num / denom) ** ninv$1;
          return x;
        });
        let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, LMS);
        let Xa = (Xm + (b$1 - 1) * Za) / b$1;
        let Ya = (Ym + (g - 1) * Xa) / g;
        return [Xa, Ya, Za];
      },
      formats: {
        // https://drafts.csswg.org/css-color-hdr/#Jzazbz
        "color": {
          coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
        }
      }
    });
    var jzczhz = new ColorSpace({
      id: "jzczhz",
      name: "JzCzHz",
      coords: {
        jz: {
          refRange: [0, 1],
          name: "Jz"
        },
        cz: {
          refRange: [0, 1],
          name: "Chroma"
        },
        hz: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        }
      },
      base: Jzazbz,
      fromBase(jzazbz) {
        let [Jz, az, bz] = jzazbz;
        let hue;
        const ε2 = 2e-4;
        if (Math.abs(az) < ε2 && Math.abs(bz) < ε2) {
          hue = NaN;
        } else {
          hue = Math.atan2(bz, az) * 180 / Math.PI;
        }
        return [
          Jz,
          // Jz is still Jz
          Math.sqrt(az ** 2 + bz ** 2),
          // Chroma
          constrain(hue)
          // Hue, in degrees [0 to 360)
        ];
      },
      toBase(jzczhz2) {
        return [
          jzczhz2[0],
          // Jz is still Jz
          jzczhz2[1] * Math.cos(jzczhz2[2] * Math.PI / 180),
          // az
          jzczhz2[1] * Math.sin(jzczhz2[2] * Math.PI / 180)
          // bz
        ];
      }
    });
    function deltaEJz(color, sample) {
      [color, sample] = getColor([color, sample]);
      let [Jz1, Cz1, Hz1] = jzczhz.from(color);
      let [Jz2, Cz2, Hz2] = jzczhz.from(sample);
      let ΔJ = Jz1 - Jz2;
      let ΔC = Cz1 - Cz2;
      if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
        Hz1 = 0;
        Hz2 = 0;
      } else if (Number.isNaN(Hz1)) {
        Hz1 = Hz2;
      } else if (Number.isNaN(Hz2)) {
        Hz2 = Hz1;
      }
      let Δh = Hz1 - Hz2;
      let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(Δh / 2 * (Math.PI / 180));
      return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);
    }
    var c1$1 = 3424 / 4096;
    var c2$1 = 2413 / 128;
    var c3$1 = 2392 / 128;
    var m1$1 = 2610 / 16384;
    var m2 = 2523 / 32;
    var im1 = 16384 / 2610;
    var im2 = 32 / 2523;
    var XYZtoLMS_M = [
      [0.3592832590121217, 0.6976051147779502, -0.035891593232029],
      [-0.1920808463704993, 1.100476797037432, 0.0753748658519118],
      [0.0070797844607479, 0.0748396662186362, 0.8433265453898765]
    ];
    var LMStoIPT_M = [
      [2048 / 4096, 2048 / 4096, 0],
      [6610 / 4096, -13613 / 4096, 7003 / 4096],
      [17933 / 4096, -17390 / 4096, -543 / 4096]
    ];
    var IPTtoLMS_M = [
      [0.9999999999999998, 0.0086090370379328, 0.111029625003026],
      [0.9999999999999998, -0.0086090370379328, -0.1110296250030259],
      [0.9999999999999998, 0.5600313357106791, -0.3206271749873188]
    ];
    var LMStoXYZ_M = [
      [2.0701522183894223, -1.3263473389671563, 0.2066510476294053],
      [0.3647385209748072, 0.6805660249472273, -0.0453045459220347],
      [-0.0497472075358123, -0.0492609666966131, 1.1880659249923042]
    ];
    var ictcp = new ColorSpace({
      id: "ictcp",
      name: "ICTCP",
      // From BT.2100-2 page 7:
      // During production, signal values are expected to exceed the
      // range E′ = [0.0 : 1.0]. This provides processing headroom and avoids
      // signal degradation during cascaded processing. Such values of E′,
      // below 0.0 or exceeding 1.0, should not be clipped during production
      // and exchange.
      // Values below 0.0 should not be clipped in reference displays (even
      // though they represent “negative” light) to allow the black level of
      // the signal (LB) to be properly set using test signals known as “PLUGE”
      coords: {
        i: {
          refRange: [0, 1],
          // Constant luminance,
          name: "I"
        },
        ct: {
          refRange: [-0.5, 0.5],
          // Full BT.2020 gamut in range [-0.5, 0.5]
          name: "CT"
        },
        cp: {
          refRange: [-0.5, 0.5],
          name: "CP"
        }
      },
      base: XYZ_Abs_D65,
      fromBase(XYZ) {
        let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);
        return LMStoICtCp(LMS);
      },
      toBase(ICtCp) {
        let LMS = ICtCptoLMS(ICtCp);
        return multiplyMatrices(LMStoXYZ_M, LMS);
      }
    });
    function LMStoICtCp(LMS) {
      let PQLMS = LMS.map(function(val) {
        let num = c1$1 + c2$1 * (val / 1e4) ** m1$1;
        let denom = 1 + c3$1 * (val / 1e4) ** m1$1;
        return (num / denom) ** m2;
      });
      return multiplyMatrices(LMStoIPT_M, PQLMS);
    }
    function ICtCptoLMS(ICtCp) {
      let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);
      let LMS = PQLMS.map(function(val) {
        let num = Math.max(val ** im2 - c1$1, 0);
        let denom = c2$1 - c3$1 * val ** im2;
        return 1e4 * (num / denom) ** im1;
      });
      return LMS;
    }
    function deltaEITP(color, sample) {
      [color, sample] = getColor([color, sample]);
      let [I1, T1, P1] = ictcp.from(color);
      let [I2, T2, P2] = ictcp.from(sample);
      return 720 * Math.sqrt((I1 - I2) ** 2 + 0.25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
    }
    var white$3 = WHITES.D65;
    var adaptedCoef = 0.42;
    var adaptedCoefInv = 1 / adaptedCoef;
    var tau = 2 * Math.PI;
    var cat16 = [
      [0.401288, 0.650173, -0.051461],
      [-0.250268, 1.204414, 0.045854],
      [-2079e-6, 0.048952, 0.953127]
    ];
    var cat16Inv = [
      [1.8620678550872327, -1.0112546305316843, 0.14918677544445175],
      [0.38752654323613717, 0.6214474419314753, -0.008973985167612518],
      [-0.015841498849333856, -0.03412293802851557, 1.0499644368778496]
    ];
    var m1 = [
      [460, 451, 288],
      [460, -891, -261],
      [460, -220, -6300]
    ];
    var surroundMap = {
      dark: [0.8, 0.525, 0.8],
      dim: [0.9, 0.59, 0.9],
      average: [1, 0.69, 1]
    };
    var hueQuadMap = {
      // Red, Yellow, Green, Blue, Red
      h: [20.14, 90, 164.25, 237.53, 380.14],
      e: [0.8, 0.7, 1, 1.2, 0.8],
      H: [0, 100, 200, 300, 400]
    };
    var rad2deg = 180 / Math.PI;
    var deg2rad$1 = Math.PI / 180;
    function adapt$1(coords, fl) {
      const temp = coords.map((c4) => {
        const x = spow(fl * Math.abs(c4) * 0.01, adaptedCoef);
        return 400 * copySign(x, c4) / (x + 27.13);
      });
      return temp;
    }
    function unadapt(adapted, fl) {
      const constant = 100 / fl * 27.13 ** adaptedCoefInv;
      return adapted.map((c4) => {
        const cabs = Math.abs(c4);
        return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c4);
      });
    }
    function hueQuadrature(h) {
      let hp = constrain(h);
      if (hp <= hueQuadMap.h[0]) {
        hp += 360;
      }
      const i = bisectLeft(hueQuadMap.h, hp) - 1;
      const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
      const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
      const Hi = hueQuadMap.H[i];
      const t = (hp - hi) / ei;
      return Hi + 100 * t / (t + (hii - hp) / eii);
    }
    function invHueQuadrature(H) {
      let Hp = (H % 400 + 400) % 400;
      const i = Math.floor(0.01 * Hp);
      Hp = Hp % 100;
      const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
      const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
      return constrain(
        (Hp * (eii * hi - ei * hii) - 100 * hi * eii) / (Hp * (eii - ei) - 100 * eii)
      );
    }
    function environment(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
      const env = {};
      env.discounting = discounting;
      env.refWhite = refWhite;
      env.surround = surround;
      const xyzW = refWhite.map((c4) => {
        return c4 * 100;
      });
      env.la = adaptingLuminance;
      env.yb = backgroundLuminance;
      const yw = xyzW[1];
      const rgbW = multiplyMatrices(cat16, xyzW);
      surround = surroundMap[env.surround];
      const f = surround[0];
      env.c = surround[1];
      env.nc = surround[2];
      const k = 1 / (5 * env.la + 1);
      const k4 = k ** 4;
      env.fl = k4 * env.la + 0.1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
      env.flRoot = env.fl ** 0.25;
      env.n = env.yb / yw;
      env.z = 1.48 + Math.sqrt(env.n);
      env.nbb = 0.725 * env.n ** -0.2;
      env.ncb = env.nbb;
      const d2 = discounting ? 1 : Math.max(
        Math.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1),
        0
      );
      env.dRgb = rgbW.map((c4) => {
        return interpolate(1, yw / c4, d2);
      });
      env.dRgbInv = env.dRgb.map((c4) => {
        return 1 / c4;
      });
      const rgbCW = rgbW.map((c4, i) => {
        return c4 * env.dRgb[i];
      });
      const rgbAW = adapt$1(rgbCW, env.fl);
      env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + 0.05 * rgbAW[2]);
      return env;
    }
    var viewingConditions$1 = environment(
      white$3,
      64 / Math.PI * 0.2,
      20,
      "average",
      false
    );
    function fromCam16(cam162, env) {
      if (!(cam162.J !== void 0 ^ cam162.Q !== void 0)) {
        throw new Error("Conversion requires one and only one: 'J' or 'Q'");
      }
      if (!(cam162.C !== void 0 ^ cam162.M !== void 0 ^ cam162.s !== void 0)) {
        throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
      }
      if (!(cam162.h !== void 0 ^ cam162.H !== void 0)) {
        throw new Error("Conversion requires one and only one: 'h' or 'H'");
      }
      if (cam162.J === 0 || cam162.Q === 0) {
        return [0, 0, 0];
      }
      let hRad = 0;
      if (cam162.h !== void 0) {
        hRad = constrain(cam162.h) * deg2rad$1;
      } else {
        hRad = invHueQuadrature(cam162.H) * deg2rad$1;
      }
      const cosh = Math.cos(hRad);
      const sinh = Math.sin(hRad);
      let Jroot = 0;
      if (cam162.J !== void 0) {
        Jroot = spow(cam162.J, 1 / 2) * 0.1;
      } else if (cam162.Q !== void 0) {
        Jroot = 0.25 * env.c * cam162.Q / ((env.aW + 4) * env.flRoot);
      }
      let alpha = 0;
      if (cam162.C !== void 0) {
        alpha = cam162.C / Jroot;
      } else if (cam162.M !== void 0) {
        alpha = cam162.M / env.flRoot / Jroot;
      } else if (cam162.s !== void 0) {
        alpha = 4e-4 * cam162.s ** 2 * (env.aW + 4) / env.c;
      }
      const t = spow(
        alpha * Math.pow(1.64 - Math.pow(0.29, env.n), -0.73),
        10 / 9
      );
      const et = 0.25 * (Math.cos(hRad + 2) + 3.8);
      const A = env.aW * spow(Jroot, 2 / env.c / env.z);
      const p1 = 5e4 / 13 * env.nc * env.ncb * et;
      const p2 = A / env.nbb;
      const r = 23 * (p2 + 0.305) * zdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh));
      const a2 = r * cosh;
      const b2 = r * sinh;
      const rgb_c = unadapt(
        multiplyMatrices(m1, [p2, a2, b2]).map((c4) => {
          return c4 * 1 / 1403;
        }),
        env.fl
      );
      return multiplyMatrices(
        cat16Inv,
        rgb_c.map((c4, i) => {
          return c4 * env.dRgbInv[i];
        })
      ).map((c4) => {
        return c4 / 100;
      });
    }
    function toCam16(xyzd65, env) {
      const xyz100 = xyzd65.map((c4) => {
        return c4 * 100;
      });
      const rgbA = adapt$1(
        multiplyMatrices(cat16, xyz100).map((c4, i) => {
          return c4 * env.dRgb[i];
        }),
        env.fl
      );
      const a2 = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
      const b2 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
      const hRad = (Math.atan2(b2, a2) % tau + tau) % tau;
      const et = 0.25 * (Math.cos(hRad + 2) + 3.8);
      const t = 5e4 / 13 * env.nc * env.ncb * zdiv(
        et * Math.sqrt(a2 ** 2 + b2 ** 2),
        rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + 0.305
      );
      const alpha = spow(t, 0.9) * Math.pow(1.64 - Math.pow(0.29, env.n), 0.73);
      const A = env.nbb * (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]);
      const Jroot = spow(A / env.aW, 0.5 * env.c * env.z);
      const J = 100 * spow(Jroot, 2);
      const Q = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
      const C = alpha * Jroot;
      const M = C * env.flRoot;
      const h = constrain(hRad * rad2deg);
      const H = hueQuadrature(h);
      const s = 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2);
      return { J, C, h, s, Q, M, H };
    }
    var cam16 = new ColorSpace({
      id: "cam16-jmh",
      cssId: "--cam16-jmh",
      name: "CAM16-JMh",
      coords: {
        j: {
          refRange: [0, 100],
          name: "J"
        },
        m: {
          refRange: [0, 105],
          name: "Colorfulness"
        },
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        }
      },
      base: xyz_d65,
      fromBase(xyz) {
        const cam162 = toCam16(xyz, viewingConditions$1);
        return [cam162.J, cam162.M, cam162.h];
      },
      toBase(cam162) {
        return fromCam16(
          { J: cam162[0], M: cam162[1], h: cam162[2] },
          viewingConditions$1
        );
      }
    });
    var white$2 = WHITES.D65;
    var ε$4 = 216 / 24389;
    var κ$3 = 24389 / 27;
    function toLstar(y) {
      const fy = y > ε$4 ? Math.cbrt(y) : (κ$3 * y + 16) / 116;
      return 116 * fy - 16;
    }
    function fromLstar(lstar) {
      return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / κ$3;
    }
    function fromHct(coords, env) {
      let [h, c4, t] = coords;
      let xyz = [];
      let j = 0;
      if (t === 0) {
        return [0, 0, 0];
      }
      let y = fromLstar(t);
      if (t > 0) {
        j = 0.00379058511492914 * t ** 2 + 0.608983189401032 * t + 0.9155088574762233;
      } else {
        j = 9514440756550361e-21 * t ** 2 + 0.08693057439788597 * t - 21.928975842194614;
      }
      const threshold = 2e-12;
      const max_attempts = 15;
      let attempt = 0;
      let last4 = Infinity;
      while (attempt <= max_attempts) {
        xyz = fromCam16({ J: j, C: c4, h }, env);
        const delta = Math.abs(xyz[1] - y);
        if (delta < last4) {
          if (delta <= threshold) {
            return xyz;
          }
          last4 = delta;
        }
        j = j - (xyz[1] - y) * j / (2 * xyz[1]);
        attempt += 1;
      }
      return fromCam16({ J: j, C: c4, h }, env);
    }
    function toHct(xyz, env) {
      const t = toLstar(xyz[1]);
      if (t === 0) {
        return [0, 0, 0];
      }
      const cam162 = toCam16(xyz, viewingConditions);
      return [constrain(cam162.h), cam162.C, t];
    }
    var viewingConditions = environment(
      white$2,
      200 / Math.PI * fromLstar(50),
      fromLstar(50) * 100,
      "average",
      false
    );
    var hct = new ColorSpace({
      id: "hct",
      name: "HCT",
      coords: {
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        },
        c: {
          refRange: [0, 145],
          name: "Colorfulness"
        },
        t: {
          refRange: [0, 100],
          name: "Tone"
        }
      },
      base: xyz_d65,
      fromBase(xyz) {
        return toHct(xyz);
      },
      toBase(hct2) {
        return fromHct(hct2, viewingConditions);
      },
      formats: {
        color: {
          id: "--hct",
          coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
        }
      }
    });
    var deg2rad = Math.PI / 180;
    var ucsCoeff = [1, 7e-3, 0.0228];
    function convertUcsAb(coords) {
      if (coords[1] < 0) {
        coords = hct.fromBase(hct.toBase(coords));
      }
      const M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1)) / ucsCoeff[2];
      const hrad = coords[0] * deg2rad;
      const a2 = M * Math.cos(hrad);
      const b2 = M * Math.sin(hrad);
      return [coords[2], a2, b2];
    }
    function deltaEHCT(color, sample) {
      [color, sample] = getColor([color, sample]);
      let [t1, a1, b1] = convertUcsAb(hct.from(color));
      let [t2, a2, b2] = convertUcsAb(hct.from(sample));
      return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);
    }
    var deltaEMethods = {
      deltaE76,
      deltaECMC,
      deltaE2000,
      deltaEJz,
      deltaEITP,
      deltaEOK,
      deltaEHCT
    };
    function calcEpsilon(jnd) {
      const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
      return Math.max(parseFloat(`1e${order - 2}`), 1e-6);
    }
    var GMAPPRESET = {
      "hct": {
        method: "hct.c",
        jnd: 2,
        deltaEMethod: "hct",
        blackWhiteClamp: {}
      },
      "hct-tonal": {
        method: "hct.c",
        jnd: 0,
        deltaEMethod: "hct",
        blackWhiteClamp: { channel: "hct.t", min: 0, max: 100 }
      }
    };
    function toGamut(color, {
      method = defaults.gamut_mapping,
      space = void 0,
      deltaEMethod = "",
      jnd = 2,
      blackWhiteClamp = {}
    } = {}) {
      color = getColor(color);
      if (isString(arguments[1])) {
        space = arguments[1];
      } else if (!space) {
        space = color.space;
      }
      space = ColorSpace.get(space);
      if (inGamut(color, space, { epsilon: 0 })) {
        return color;
      }
      let spaceColor;
      if (method === "css") {
        spaceColor = toGamutCSS(color, { space });
      } else {
        if (method !== "clip" && !inGamut(color, space)) {
          if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {
            ({ method, jnd, deltaEMethod, blackWhiteClamp } = GMAPPRESET[method]);
          }
          let de = deltaE2000;
          if (deltaEMethod !== "") {
            for (let m3 in deltaEMethods) {
              if ("deltae" + deltaEMethod.toLowerCase() === m3.toLowerCase()) {
                de = deltaEMethods[m3];
                break;
              }
            }
          }
          let clipped = toGamut(to(color, space), { method: "clip", space });
          if (de(color, clipped) > jnd) {
            if (Object.keys(blackWhiteClamp).length === 3) {
              let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
              let channel = get11(to(color, channelMeta.space), channelMeta.id);
              if (isNone(channel)) {
                channel = 0;
              }
              if (channel >= blackWhiteClamp.max) {
                return to({ space: "xyz-d65", coords: WHITES["D65"] }, color.space);
              } else if (channel <= blackWhiteClamp.min) {
                return to({ space: "xyz-d65", coords: [0, 0, 0] }, color.space);
              }
            }
            let coordMeta = ColorSpace.resolveCoord(method);
            let mapSpace = coordMeta.space;
            let coordId = coordMeta.id;
            let mappedColor = to(color, mapSpace);
            mappedColor.coords.forEach((c4, i) => {
              if (isNone(c4)) {
                mappedColor.coords[i] = 0;
              }
            });
            let bounds = coordMeta.range || coordMeta.refRange;
            let min2 = bounds[0];
            let ε2 = calcEpsilon(jnd);
            let low = min2;
            let high = get11(mappedColor, coordId);
            while (high - low > ε2) {
              let clipped2 = clone(mappedColor);
              clipped2 = toGamut(clipped2, { space, method: "clip" });
              let deltaE2 = de(mappedColor, clipped2);
              if (deltaE2 - jnd < ε2) {
                low = get11(mappedColor, coordId);
              } else {
                high = get11(mappedColor, coordId);
              }
              set3(mappedColor, coordId, (low + high) / 2);
            }
            spaceColor = to(mappedColor, space);
          } else {
            spaceColor = clipped;
          }
        } else {
          spaceColor = to(color, space);
        }
        if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
          let bounds = Object.values(space.coords).map((c4) => c4.range || []);
          spaceColor.coords = spaceColor.coords.map((c4, i) => {
            let [min2, max3] = bounds[i];
            if (min2 !== void 0) {
              c4 = Math.max(min2, c4);
            }
            if (max3 !== void 0) {
              c4 = Math.min(c4, max3);
            }
            return c4;
          });
        }
      }
      if (space !== color.space) {
        spaceColor = to(spaceColor, color.space);
      }
      color.coords = spaceColor.coords;
      return color;
    }
    toGamut.returns = "color";
    var COLORS = {
      WHITE: { space: OKLab, coords: [1, 0, 0] },
      BLACK: { space: OKLab, coords: [0, 0, 0] }
    };
    function toGamutCSS(origin, { space } = {}) {
      const JND = 0.02;
      const ε2 = 1e-4;
      origin = getColor(origin);
      if (!space) {
        space = origin.space;
      }
      space = ColorSpace.get(space);
      const oklchSpace = ColorSpace.get("oklch");
      if (space.isUnbounded) {
        return to(origin, space);
      }
      const origin_OKLCH = to(origin, oklchSpace);
      let L = origin_OKLCH.coords[0];
      if (L >= 1) {
        const white2 = to(COLORS.WHITE, space);
        white2.alpha = origin.alpha;
        return to(white2, space);
      }
      if (L <= 0) {
        const black = to(COLORS.BLACK, space);
        black.alpha = origin.alpha;
        return to(black, space);
      }
      if (inGamut(origin_OKLCH, space, { epsilon: 0 })) {
        return to(origin_OKLCH, space);
      }
      function clip(_color) {
        const destColor = to(_color, space);
        const spaceCoords = Object.values(space.coords);
        destColor.coords = destColor.coords.map((coord, index) => {
          if ("range" in spaceCoords[index]) {
            const [min3, max4] = spaceCoords[index].range;
            return clamp(min3, coord, max4);
          }
          return coord;
        });
        return destColor;
      }
      let min2 = 0;
      let max3 = origin_OKLCH.coords[1];
      let min_inGamut = true;
      let current = clone(origin_OKLCH);
      let clipped = clip(current);
      let E = deltaEOK(clipped, current);
      if (E < JND) {
        return clipped;
      }
      while (max3 - min2 > ε2) {
        const chroma = (min2 + max3) / 2;
        current.coords[1] = chroma;
        if (min_inGamut && inGamut(current, space, { epsilon: 0 })) {
          min2 = chroma;
        } else {
          clipped = clip(current);
          E = deltaEOK(clipped, current);
          if (E < JND) {
            if (JND - E < ε2) {
              break;
            } else {
              min_inGamut = false;
              min2 = chroma;
            }
          } else {
            max3 = chroma;
          }
        }
      }
      return clipped;
    }
    function to(color, space, { inGamut: inGamut2 } = {}) {
      color = getColor(color);
      space = ColorSpace.get(space);
      let coords = space.from(color);
      let ret = { space, coords, alpha: color.alpha };
      if (inGamut2) {
        ret = toGamut(ret, inGamut2 === true ? void 0 : inGamut2);
      }
      return ret;
    }
    to.returns = "color";
    function serialize(color, {
      precision = defaults.precision,
      format = "default",
      inGamut: inGamut$1 = true,
      ...customOptions
    } = {}) {
      var _a2;
      let ret;
      color = getColor(color);
      let formatId = format;
      format = color.space.getFormat(format) ?? color.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
      let coords = color.coords.slice();
      inGamut$1 || (inGamut$1 = format.toGamut);
      if (inGamut$1 && !inGamut(color)) {
        coords = toGamut(clone(color), inGamut$1 === true ? void 0 : inGamut$1).coords;
      }
      if (format.type === "custom") {
        customOptions.precision = precision;
        if (format.serialize) {
          ret = format.serialize(coords, color.alpha, customOptions);
        } else {
          throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
        }
      } else {
        let name = format.name || "color";
        if (format.serializeCoords) {
          coords = format.serializeCoords(coords, precision);
        } else {
          if (precision !== null) {
            coords = coords.map((c4) => {
              return serializeNumber(c4, { precision });
            });
          }
        }
        let args = [...coords];
        if (name === "color") {
          let cssId = format.id || ((_a2 = format.ids) == null ? void 0 : _a2[0]) || color.space.id;
          args.unshift(cssId);
        }
        let alpha = color.alpha;
        if (precision !== null) {
          alpha = serializeNumber(alpha, { precision });
        }
        let strAlpha = color.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
        ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
      }
      return ret;
    }
    var toXYZ_M$5 = [
      [0.6369580483012914, 0.14461690358620832, 0.1688809751641721],
      [0.2627002120112671, 0.6779980715188708, 0.05930171646986196],
      [0, 0.028072693049087428, 1.060985057710791]
    ];
    var fromXYZ_M$5 = [
      [1.716651187971268, -0.355670783776392, -0.25336628137366],
      [-0.666684351832489, 1.616481236634939, 0.0157685458139111],
      [0.017639857445311, -0.042770613257809, 0.942103121235474]
    ];
    var REC2020Linear = new RGBColorSpace({
      id: "rec2020-linear",
      cssId: "--rec2020-linear",
      name: "Linear REC.2020",
      white: "D65",
      toXYZ_M: toXYZ_M$5,
      fromXYZ_M: fromXYZ_M$5
    });
    var α = 1.09929682680944;
    var β = 0.018053968510807;
    var REC2020 = new RGBColorSpace({
      id: "rec2020",
      name: "REC.2020",
      base: REC2020Linear,
      // Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4
      toBase(RGB) {
        return RGB.map(function(val) {
          if (val < β * 4.5) {
            return val / 4.5;
          }
          return Math.pow((val + α - 1) / α, 1 / 0.45);
        });
      },
      fromBase(RGB) {
        return RGB.map(function(val) {
          if (val >= β) {
            return α * Math.pow(val, 0.45) - (α - 1);
          }
          return 4.5 * val;
        });
      }
    });
    var toXYZ_M$4 = [
      [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
      [0.2289745640697488, 0.6917385218365064, 0.079286914093745],
      [0, 0.04511338185890264, 1.043944368900976]
    ];
    var fromXYZ_M$4 = [
      [2.493496911941425, -0.9313836179191239, -0.40271078445071684],
      [-0.8294889695615747, 1.7626640603183463, 0.023624685841943577],
      [0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
    ];
    var P3Linear = new RGBColorSpace({
      id: "p3-linear",
      cssId: "--display-p3-linear",
      name: "Linear P3",
      white: "D65",
      toXYZ_M: toXYZ_M$4,
      fromXYZ_M: fromXYZ_M$4
    });
    var toXYZ_M$3 = [
      [0.41239079926595934, 0.357584339383878, 0.1804807884018343],
      [0.21263900587151027, 0.715168678767756, 0.07219231536073371],
      [0.01933081871559182, 0.11919477979462598, 0.9505321522496607]
    ];
    var fromXYZ_M$3 = [
      [3.2409699419045226, -1.537383177570094, -0.4986107602930034],
      [-0.9692436362808796, 1.8759675015077202, 0.04155505740717559],
      [0.05563007969699366, -0.20397695888897652, 1.0569715142428786]
    ];
    var sRGBLinear = new RGBColorSpace({
      id: "srgb-linear",
      name: "Linear sRGB",
      white: "D65",
      toXYZ_M: toXYZ_M$3,
      fromXYZ_M: fromXYZ_M$3
    });
    var KEYWORDS = {
      "aliceblue": [240 / 255, 248 / 255, 1],
      "antiquewhite": [250 / 255, 235 / 255, 215 / 255],
      "aqua": [0, 1, 1],
      "aquamarine": [127 / 255, 1, 212 / 255],
      "azure": [240 / 255, 1, 1],
      "beige": [245 / 255, 245 / 255, 220 / 255],
      "bisque": [1, 228 / 255, 196 / 255],
      "black": [0, 0, 0],
      "blanchedalmond": [1, 235 / 255, 205 / 255],
      "blue": [0, 0, 1],
      "blueviolet": [138 / 255, 43 / 255, 226 / 255],
      "brown": [165 / 255, 42 / 255, 42 / 255],
      "burlywood": [222 / 255, 184 / 255, 135 / 255],
      "cadetblue": [95 / 255, 158 / 255, 160 / 255],
      "chartreuse": [127 / 255, 1, 0],
      "chocolate": [210 / 255, 105 / 255, 30 / 255],
      "coral": [1, 127 / 255, 80 / 255],
      "cornflowerblue": [100 / 255, 149 / 255, 237 / 255],
      "cornsilk": [1, 248 / 255, 220 / 255],
      "crimson": [220 / 255, 20 / 255, 60 / 255],
      "cyan": [0, 1, 1],
      "darkblue": [0, 0, 139 / 255],
      "darkcyan": [0, 139 / 255, 139 / 255],
      "darkgoldenrod": [184 / 255, 134 / 255, 11 / 255],
      "darkgray": [169 / 255, 169 / 255, 169 / 255],
      "darkgreen": [0, 100 / 255, 0],
      "darkgrey": [169 / 255, 169 / 255, 169 / 255],
      "darkkhaki": [189 / 255, 183 / 255, 107 / 255],
      "darkmagenta": [139 / 255, 0, 139 / 255],
      "darkolivegreen": [85 / 255, 107 / 255, 47 / 255],
      "darkorange": [1, 140 / 255, 0],
      "darkorchid": [153 / 255, 50 / 255, 204 / 255],
      "darkred": [139 / 255, 0, 0],
      "darksalmon": [233 / 255, 150 / 255, 122 / 255],
      "darkseagreen": [143 / 255, 188 / 255, 143 / 255],
      "darkslateblue": [72 / 255, 61 / 255, 139 / 255],
      "darkslategray": [47 / 255, 79 / 255, 79 / 255],
      "darkslategrey": [47 / 255, 79 / 255, 79 / 255],
      "darkturquoise": [0, 206 / 255, 209 / 255],
      "darkviolet": [148 / 255, 0, 211 / 255],
      "deeppink": [1, 20 / 255, 147 / 255],
      "deepskyblue": [0, 191 / 255, 1],
      "dimgray": [105 / 255, 105 / 255, 105 / 255],
      "dimgrey": [105 / 255, 105 / 255, 105 / 255],
      "dodgerblue": [30 / 255, 144 / 255, 1],
      "firebrick": [178 / 255, 34 / 255, 34 / 255],
      "floralwhite": [1, 250 / 255, 240 / 255],
      "forestgreen": [34 / 255, 139 / 255, 34 / 255],
      "fuchsia": [1, 0, 1],
      "gainsboro": [220 / 255, 220 / 255, 220 / 255],
      "ghostwhite": [248 / 255, 248 / 255, 1],
      "gold": [1, 215 / 255, 0],
      "goldenrod": [218 / 255, 165 / 255, 32 / 255],
      "gray": [128 / 255, 128 / 255, 128 / 255],
      "green": [0, 128 / 255, 0],
      "greenyellow": [173 / 255, 1, 47 / 255],
      "grey": [128 / 255, 128 / 255, 128 / 255],
      "honeydew": [240 / 255, 1, 240 / 255],
      "hotpink": [1, 105 / 255, 180 / 255],
      "indianred": [205 / 255, 92 / 255, 92 / 255],
      "indigo": [75 / 255, 0, 130 / 255],
      "ivory": [1, 1, 240 / 255],
      "khaki": [240 / 255, 230 / 255, 140 / 255],
      "lavender": [230 / 255, 230 / 255, 250 / 255],
      "lavenderblush": [1, 240 / 255, 245 / 255],
      "lawngreen": [124 / 255, 252 / 255, 0],
      "lemonchiffon": [1, 250 / 255, 205 / 255],
      "lightblue": [173 / 255, 216 / 255, 230 / 255],
      "lightcoral": [240 / 255, 128 / 255, 128 / 255],
      "lightcyan": [224 / 255, 1, 1],
      "lightgoldenrodyellow": [250 / 255, 250 / 255, 210 / 255],
      "lightgray": [211 / 255, 211 / 255, 211 / 255],
      "lightgreen": [144 / 255, 238 / 255, 144 / 255],
      "lightgrey": [211 / 255, 211 / 255, 211 / 255],
      "lightpink": [1, 182 / 255, 193 / 255],
      "lightsalmon": [1, 160 / 255, 122 / 255],
      "lightseagreen": [32 / 255, 178 / 255, 170 / 255],
      "lightskyblue": [135 / 255, 206 / 255, 250 / 255],
      "lightslategray": [119 / 255, 136 / 255, 153 / 255],
      "lightslategrey": [119 / 255, 136 / 255, 153 / 255],
      "lightsteelblue": [176 / 255, 196 / 255, 222 / 255],
      "lightyellow": [1, 1, 224 / 255],
      "lime": [0, 1, 0],
      "limegreen": [50 / 255, 205 / 255, 50 / 255],
      "linen": [250 / 255, 240 / 255, 230 / 255],
      "magenta": [1, 0, 1],
      "maroon": [128 / 255, 0, 0],
      "mediumaquamarine": [102 / 255, 205 / 255, 170 / 255],
      "mediumblue": [0, 0, 205 / 255],
      "mediumorchid": [186 / 255, 85 / 255, 211 / 255],
      "mediumpurple": [147 / 255, 112 / 255, 219 / 255],
      "mediumseagreen": [60 / 255, 179 / 255, 113 / 255],
      "mediumslateblue": [123 / 255, 104 / 255, 238 / 255],
      "mediumspringgreen": [0, 250 / 255, 154 / 255],
      "mediumturquoise": [72 / 255, 209 / 255, 204 / 255],
      "mediumvioletred": [199 / 255, 21 / 255, 133 / 255],
      "midnightblue": [25 / 255, 25 / 255, 112 / 255],
      "mintcream": [245 / 255, 1, 250 / 255],
      "mistyrose": [1, 228 / 255, 225 / 255],
      "moccasin": [1, 228 / 255, 181 / 255],
      "navajowhite": [1, 222 / 255, 173 / 255],
      "navy": [0, 0, 128 / 255],
      "oldlace": [253 / 255, 245 / 255, 230 / 255],
      "olive": [128 / 255, 128 / 255, 0],
      "olivedrab": [107 / 255, 142 / 255, 35 / 255],
      "orange": [1, 165 / 255, 0],
      "orangered": [1, 69 / 255, 0],
      "orchid": [218 / 255, 112 / 255, 214 / 255],
      "palegoldenrod": [238 / 255, 232 / 255, 170 / 255],
      "palegreen": [152 / 255, 251 / 255, 152 / 255],
      "paleturquoise": [175 / 255, 238 / 255, 238 / 255],
      "palevioletred": [219 / 255, 112 / 255, 147 / 255],
      "papayawhip": [1, 239 / 255, 213 / 255],
      "peachpuff": [1, 218 / 255, 185 / 255],
      "peru": [205 / 255, 133 / 255, 63 / 255],
      "pink": [1, 192 / 255, 203 / 255],
      "plum": [221 / 255, 160 / 255, 221 / 255],
      "powderblue": [176 / 255, 224 / 255, 230 / 255],
      "purple": [128 / 255, 0, 128 / 255],
      "rebeccapurple": [102 / 255, 51 / 255, 153 / 255],
      "red": [1, 0, 0],
      "rosybrown": [188 / 255, 143 / 255, 143 / 255],
      "royalblue": [65 / 255, 105 / 255, 225 / 255],
      "saddlebrown": [139 / 255, 69 / 255, 19 / 255],
      "salmon": [250 / 255, 128 / 255, 114 / 255],
      "sandybrown": [244 / 255, 164 / 255, 96 / 255],
      "seagreen": [46 / 255, 139 / 255, 87 / 255],
      "seashell": [1, 245 / 255, 238 / 255],
      "sienna": [160 / 255, 82 / 255, 45 / 255],
      "silver": [192 / 255, 192 / 255, 192 / 255],
      "skyblue": [135 / 255, 206 / 255, 235 / 255],
      "slateblue": [106 / 255, 90 / 255, 205 / 255],
      "slategray": [112 / 255, 128 / 255, 144 / 255],
      "slategrey": [112 / 255, 128 / 255, 144 / 255],
      "snow": [1, 250 / 255, 250 / 255],
      "springgreen": [0, 1, 127 / 255],
      "steelblue": [70 / 255, 130 / 255, 180 / 255],
      "tan": [210 / 255, 180 / 255, 140 / 255],
      "teal": [0, 128 / 255, 128 / 255],
      "thistle": [216 / 255, 191 / 255, 216 / 255],
      "tomato": [1, 99 / 255, 71 / 255],
      "turquoise": [64 / 255, 224 / 255, 208 / 255],
      "violet": [238 / 255, 130 / 255, 238 / 255],
      "wheat": [245 / 255, 222 / 255, 179 / 255],
      "white": [1, 1, 1],
      "whitesmoke": [245 / 255, 245 / 255, 245 / 255],
      "yellow": [1, 1, 0],
      "yellowgreen": [154 / 255, 205 / 255, 50 / 255]
    };
    var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
    var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
    var sRGB = new RGBColorSpace({
      id: "srgb",
      name: "sRGB",
      base: sRGBLinear,
      fromBase: (rgb) => {
        return rgb.map((val) => {
          let sign = val < 0 ? -1 : 1;
          let abs = val * sign;
          if (abs > 31308e-7) {
            return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
          }
          return 12.92 * val;
        });
      },
      toBase: (rgb) => {
        return rgb.map((val) => {
          let sign = val < 0 ? -1 : 1;
          let abs = val * sign;
          if (abs <= 0.04045) {
            return val / 12.92;
          }
          return sign * ((abs + 0.055) / 1.055) ** 2.4;
        });
      },
      formats: {
        "rgb": {
          coords: coordGrammar
        },
        "rgb_number": {
          name: "rgb",
          commas: true,
          coords: coordGrammarNumber,
          noAlpha: true
        },
        "color": {
          /* use defaults */
        },
        "rgba": {
          coords: coordGrammar,
          commas: true,
          lastAlpha: true
        },
        "rgba_number": {
          name: "rgba",
          commas: true,
          coords: coordGrammarNumber
        },
        "hex": {
          type: "custom",
          toGamut: true,
          test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
          parse(str) {
            if (str.length <= 5) {
              str = str.replace(/[a-f0-9]/gi, "$&$&");
            }
            let rgba = [];
            str.replace(/[a-f0-9]{2}/gi, (component) => {
              rgba.push(parseInt(component, 16) / 255);
            });
            return {
              spaceId: "srgb",
              coords: rgba.slice(0, 3),
              alpha: rgba.slice(3)[0]
            };
          },
          serialize: (coords, alpha, {
            collapse = true
            // collapse to 3-4 digit hex when possible?
          } = {}) => {
            if (alpha < 1) {
              coords.push(alpha);
            }
            coords = coords.map((c4) => Math.round(c4 * 255));
            let collapsible = collapse && coords.every((c4) => c4 % 17 === 0);
            let hex = coords.map((c4) => {
              if (collapsible) {
                return (c4 / 17).toString(16);
              }
              return c4.toString(16).padStart(2, "0");
            }).join("");
            return "#" + hex;
          }
        },
        "keyword": {
          type: "custom",
          test: (str) => /^[a-z]+$/i.test(str),
          parse(str) {
            str = str.toLowerCase();
            let ret = { spaceId: "srgb", coords: null, alpha: 1 };
            if (str === "transparent") {
              ret.coords = KEYWORDS.black;
              ret.alpha = 0;
            } else {
              ret.coords = KEYWORDS[str];
            }
            if (ret.coords) {
              return ret;
            }
          }
        }
      }
    });
    var P3 = new RGBColorSpace({
      id: "p3",
      cssId: "display-p3",
      name: "P3",
      base: P3Linear,
      // Gamma encoding/decoding is the same as sRGB
      fromBase: sRGB.fromBase,
      toBase: sRGB.toBase
    });
    defaults.display_space = sRGB;
    var supportsNone;
    if (typeof CSS !== "undefined" && CSS.supports) {
      for (let space of [lab, REC2020, P3]) {
        let coords = space.getMinCoords();
        let color = { space, coords, alpha: 1 };
        let str = serialize(color);
        if (CSS.supports("color", str)) {
          defaults.display_space = space;
          break;
        }
      }
    }
    function display(color, { space = defaults.display_space, ...options } = {}) {
      let ret = serialize(color, options);
      if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults.display_space) {
        ret = new String(ret);
        ret.color = color;
      } else {
        let fallbackColor = color;
        let hasNone = color.coords.some(isNone) || isNone(color.alpha);
        if (hasNone) {
          if (!(supportsNone ?? (supportsNone = CSS.supports("color", "hsl(none 50% 50%)")))) {
            fallbackColor = clone(color);
            fallbackColor.coords = fallbackColor.coords.map(skipNone);
            fallbackColor.alpha = skipNone(fallbackColor.alpha);
            ret = serialize(fallbackColor, options);
            if (CSS.supports("color", ret)) {
              ret = new String(ret);
              ret.color = fallbackColor;
              return ret;
            }
          }
        }
        fallbackColor = to(fallbackColor, space);
        ret = new String(serialize(fallbackColor, options));
        ret.color = fallbackColor;
      }
      return ret;
    }
    function equals3(color1, color2) {
      color1 = getColor(color1);
      color2 = getColor(color2);
      return color1.space === color2.space && color1.alpha === color2.alpha && color1.coords.every((c4, i) => c4 === color2.coords[i]);
    }
    function getLuminance(color) {
      return get11(color, [xyz_d65, "y"]);
    }
    function setLuminance(color, value) {
      set3(color, [xyz_d65, "y"], value);
    }
    function register$2(Color2) {
      Object.defineProperty(Color2.prototype, "luminance", {
        get() {
          return getLuminance(this);
        },
        set(value) {
          setLuminance(this, value);
        }
      });
    }
    var luminance = Object.freeze({
      __proto__: null,
      getLuminance,
      register: register$2,
      setLuminance
    });
    function contrastWCAG21(color1, color2) {
      color1 = getColor(color1);
      color2 = getColor(color2);
      let Y1 = Math.max(getLuminance(color1), 0);
      let Y2 = Math.max(getLuminance(color2), 0);
      if (Y2 > Y1) {
        [Y1, Y2] = [Y2, Y1];
      }
      return (Y1 + 0.05) / (Y2 + 0.05);
    }
    var normBG = 0.56;
    var normTXT = 0.57;
    var revTXT = 0.62;
    var revBG = 0.65;
    var blkThrs = 0.022;
    var blkClmp = 1.414;
    var loClip = 0.1;
    var deltaYmin = 5e-4;
    var scaleBoW = 1.14;
    var loBoWoffset = 0.027;
    var scaleWoB = 1.14;
    function fclamp(Y) {
      if (Y >= blkThrs) {
        return Y;
      }
      return Y + (blkThrs - Y) ** blkClmp;
    }
    function linearize(val) {
      let sign = val < 0 ? -1 : 1;
      let abs = Math.abs(val);
      return sign * Math.pow(abs, 2.4);
    }
    function contrastAPCA(background, foreground) {
      foreground = getColor(foreground);
      background = getColor(background);
      let S;
      let C;
      let Sapc;
      let R, G, B;
      foreground = to(foreground, "srgb");
      [R, G, B] = foreground.coords;
      let lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.072175;
      background = to(background, "srgb");
      [R, G, B] = background.coords;
      let lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.072175;
      let Ytxt = fclamp(lumTxt);
      let Ybg = fclamp(lumBg);
      let BoW = Ybg > Ytxt;
      if (Math.abs(Ybg - Ytxt) < deltaYmin) {
        C = 0;
      } else {
        if (BoW) {
          S = Ybg ** normBG - Ytxt ** normTXT;
          C = S * scaleBoW;
        } else {
          S = Ybg ** revBG - Ytxt ** revTXT;
          C = S * scaleWoB;
        }
      }
      if (Math.abs(C) < loClip) {
        Sapc = 0;
      } else if (C > 0) {
        Sapc = C - loBoWoffset;
      } else {
        Sapc = C + loBoWoffset;
      }
      return Sapc * 100;
    }
    function contrastMichelson(color1, color2) {
      color1 = getColor(color1);
      color2 = getColor(color2);
      let Y1 = Math.max(getLuminance(color1), 0);
      let Y2 = Math.max(getLuminance(color2), 0);
      if (Y2 > Y1) {
        [Y1, Y2] = [Y2, Y1];
      }
      let denom = Y1 + Y2;
      return denom === 0 ? 0 : (Y1 - Y2) / denom;
    }
    var max2 = 5e4;
    function contrastWeber(color1, color2) {
      color1 = getColor(color1);
      color2 = getColor(color2);
      let Y1 = Math.max(getLuminance(color1), 0);
      let Y2 = Math.max(getLuminance(color2), 0);
      if (Y2 > Y1) {
        [Y1, Y2] = [Y2, Y1];
      }
      return Y2 === 0 ? max2 : (Y1 - Y2) / Y2;
    }
    function contrastLstar(color1, color2) {
      color1 = getColor(color1);
      color2 = getColor(color2);
      let L1 = get11(color1, [lab, "l"]);
      let L2 = get11(color2, [lab, "l"]);
      return Math.abs(L1 - L2);
    }
    var ε$3 = 216 / 24389;
    var ε3 = 24 / 116;
    var κ$2 = 24389 / 27;
    var white$1 = WHITES.D65;
    var lab_d65 = new ColorSpace({
      id: "lab-d65",
      name: "Lab D65",
      coords: {
        l: {
          refRange: [0, 100],
          name: "Lightness"
        },
        a: {
          refRange: [-125, 125]
        },
        b: {
          refRange: [-125, 125]
        }
      },
      // Assuming XYZ is relative to D65, convert to CIE Lab
      // from CIE standard, which now defines these as a rational fraction
      white: white$1,
      base: xyz_d65,
      // Convert D65-adapted XYZ to Lab
      //  CIE 15.3:2004 section 8.2.1.1
      fromBase(XYZ) {
        let xyz = XYZ.map((value, i) => value / white$1[i]);
        let f = xyz.map((value) => value > ε$3 ? Math.cbrt(value) : (κ$2 * value + 16) / 116);
        return [
          116 * f[1] - 16,
          // L
          500 * (f[0] - f[1]),
          // a
          200 * (f[1] - f[2])
          // b
        ];
      },
      // Convert Lab to D65-adapted XYZ
      // Same result as CIE 15.3:2004 Appendix D although the derivation is different
      // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
      toBase(Lab) {
        let f = [];
        f[1] = (Lab[0] + 16) / 116;
        f[0] = Lab[1] / 500 + f[1];
        f[2] = f[1] - Lab[2] / 200;
        let xyz = [
          f[0] > ε3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$2,
          Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ$2,
          f[2] > ε3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$2
        ];
        return xyz.map((value, i) => value * white$1[i]);
      },
      formats: {
        "lab-d65": {
          coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
        }
      }
    });
    var phi = Math.pow(5, 0.5) * 0.5 + 0.5;
    function contrastDeltaPhi(color1, color2) {
      color1 = getColor(color1);
      color2 = getColor(color2);
      let Lstr1 = get11(color1, [lab_d65, "l"]);
      let Lstr2 = get11(color2, [lab_d65, "l"]);
      let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));
      let contrast2 = Math.pow(deltaPhiStar, 1 / phi) * Math.SQRT2 - 40;
      return contrast2 < 7.5 ? 0 : contrast2;
    }
    var contrastMethods = Object.freeze({
      __proto__: null,
      contrastAPCA,
      contrastDeltaPhi,
      contrastLstar,
      contrastMichelson,
      contrastWCAG21,
      contrastWeber
    });
    function contrast(background, foreground, o = {}) {
      if (isString(o)) {
        o = { algorithm: o };
      }
      let { algorithm, ...rest2 } = o;
      if (!algorithm) {
        let algorithms = Object.keys(contrastMethods).map((a2) => a2.replace(/^contrast/, "")).join(", ");
        throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
      }
      background = getColor(background);
      foreground = getColor(foreground);
      for (let a2 in contrastMethods) {
        if ("contrast" + algorithm.toLowerCase() === a2.toLowerCase()) {
          return contrastMethods[a2](background, foreground, rest2);
        }
      }
      throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
    }
    function uv(color) {
      let [X, Y, Z] = getAll(color, xyz_d65);
      let denom = X + 15 * Y + 3 * Z;
      return [4 * X / denom, 9 * Y / denom];
    }
    function xy(color) {
      let [X, Y, Z] = getAll(color, xyz_d65);
      let sum = X + Y + Z;
      return [X / sum, Y / sum];
    }
    function register$1(Color2) {
      Object.defineProperty(Color2.prototype, "uv", {
        get() {
          return uv(this);
        }
      });
      Object.defineProperty(Color2.prototype, "xy", {
        get() {
          return xy(this);
        }
      });
    }
    var chromaticity = Object.freeze({
      __proto__: null,
      register: register$1,
      uv,
      xy
    });
    function deltaE(c12, c22, o = {}) {
      if (isString(o)) {
        o = { method: o };
      }
      let { method = defaults.deltaE, ...rest2 } = o;
      for (let m3 in deltaEMethods) {
        if ("deltae" + method.toLowerCase() === m3.toLowerCase()) {
          return deltaEMethods[m3](c12, c22, rest2);
        }
      }
      throw new TypeError(`Unknown deltaE method: ${method}`);
    }
    function lighten(color, amount = 0.25) {
      let space = ColorSpace.get("oklch", "lch");
      let lightness = [space, "l"];
      return set3(color, lightness, (l) => l * (1 + amount));
    }
    function darken(color, amount = 0.25) {
      let space = ColorSpace.get("oklch", "lch");
      let lightness = [space, "l"];
      return set3(color, lightness, (l) => l * (1 - amount));
    }
    var variations = Object.freeze({
      __proto__: null,
      darken,
      lighten
    });
    function mix(c12, c22, p2 = 0.5, o = {}) {
      [c12, c22] = [getColor(c12), getColor(c22)];
      if (type(p2) === "object") {
        [p2, o] = [0.5, p2];
      }
      let r = range(c12, c22, o);
      return r(p2);
    }
    function steps(c12, c22, options = {}) {
      let colorRange;
      if (isRange(c12)) {
        [colorRange, options] = [c12, c22];
        [c12, c22] = colorRange.rangeArgs.colors;
      }
      let {
        maxDeltaE,
        deltaEMethod,
        steps: steps2 = 2,
        maxSteps = 1e3,
        ...rangeOptions
      } = options;
      if (!colorRange) {
        [c12, c22] = [getColor(c12), getColor(c22)];
        colorRange = range(c12, c22, rangeOptions);
      }
      let totalDelta = deltaE(c12, c22);
      let actualSteps = maxDeltaE > 0 ? Math.max(steps2, Math.ceil(totalDelta / maxDeltaE) + 1) : steps2;
      let ret = [];
      if (maxSteps !== void 0) {
        actualSteps = Math.min(actualSteps, maxSteps);
      }
      if (actualSteps === 1) {
        ret = [{ p: 0.5, color: colorRange(0.5) }];
      } else {
        let step = 1 / (actualSteps - 1);
        ret = Array.from({ length: actualSteps }, (_, i) => {
          let p2 = i * step;
          return { p: p2, color: colorRange(p2) };
        });
      }
      if (maxDeltaE > 0) {
        let maxDelta = ret.reduce((acc, cur, i) => {
          if (i === 0) {
            return 0;
          }
          let ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);
          return Math.max(acc, ΔΕ);
        }, 0);
        while (maxDelta > maxDeltaE) {
          maxDelta = 0;
          for (let i = 1; i < ret.length && ret.length < maxSteps; i++) {
            let prev = ret[i - 1];
            let cur = ret[i];
            let p2 = (cur.p + prev.p) / 2;
            let color = colorRange(p2);
            maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));
            ret.splice(i, 0, { p: p2, color: colorRange(p2) });
            i++;
          }
        }
      }
      ret = ret.map((a2) => a2.color);
      return ret;
    }
    function range(color1, color2, options = {}) {
      if (isRange(color1)) {
        let [r, options2] = [color1, color2];
        return range(...r.rangeArgs.colors, { ...r.rangeArgs.options, ...options2 });
      }
      let { space, outputSpace, progression, premultiplied } = options;
      color1 = getColor(color1);
      color2 = getColor(color2);
      color1 = clone(color1);
      color2 = clone(color2);
      let rangeArgs = { colors: [color1, color2], options };
      if (space) {
        space = ColorSpace.get(space);
      } else {
        space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;
      }
      outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
      color1 = to(color1, space);
      color2 = to(color2, space);
      color1 = toGamut(color1);
      color2 = toGamut(color2);
      if (space.coords.h && space.coords.h.type === "angle") {
        let arc = options.hue = options.hue || "shorter";
        let hue = [space, "h"];
        let [θ1, θ2] = [get11(color1, hue), get11(color2, hue)];
        if (isNaN(θ1) && !isNaN(θ2)) {
          θ1 = θ2;
        } else if (isNaN(θ2) && !isNaN(θ1)) {
          θ2 = θ1;
        }
        [θ1, θ2] = adjust(arc, [θ1, θ2]);
        set3(color1, hue, θ1);
        set3(color2, hue, θ2);
      }
      if (premultiplied) {
        color1.coords = color1.coords.map((c4) => c4 * color1.alpha);
        color2.coords = color2.coords.map((c4) => c4 * color2.alpha);
      }
      return Object.assign((p2) => {
        p2 = progression ? progression(p2) : p2;
        let coords = color1.coords.map((start, i) => {
          let end = color2.coords[i];
          return interpolate(start, end, p2);
        });
        let alpha = interpolate(color1.alpha, color2.alpha, p2);
        let ret = { space, coords, alpha };
        if (premultiplied) {
          ret.coords = ret.coords.map((c4) => c4 / alpha);
        }
        if (outputSpace !== space) {
          ret = to(ret, outputSpace);
        }
        return ret;
      }, {
        rangeArgs
      });
    }
    function isRange(val) {
      return type(val) === "function" && !!val.rangeArgs;
    }
    defaults.interpolationSpace = "lab";
    function register(Color2) {
      Color2.defineFunction("mix", mix, { returns: "color" });
      Color2.defineFunction("range", range, { returns: "function<color>" });
      Color2.defineFunction("steps", steps, { returns: "array<color>" });
    }
    var interpolation = Object.freeze({
      __proto__: null,
      isRange,
      mix,
      range,
      register,
      steps
    });
    var HSL = new ColorSpace({
      id: "hsl",
      name: "HSL",
      coords: {
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        },
        s: {
          range: [0, 100],
          name: "Saturation"
        },
        l: {
          range: [0, 100],
          name: "Lightness"
        }
      },
      base: sRGB,
      // Adapted from https://drafts.csswg.org/css-color-4/better-rgbToHsl.js
      fromBase: (rgb) => {
        let max3 = Math.max(...rgb);
        let min2 = Math.min(...rgb);
        let [r, g2, b2] = rgb;
        let [h, s, l] = [NaN, 0, (min2 + max3) / 2];
        let d2 = max3 - min2;
        if (d2 !== 0) {
          s = l === 0 || l === 1 ? 0 : (max3 - l) / Math.min(l, 1 - l);
          switch (max3) {
            case r:
              h = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h = (b2 - r) / d2 + 2;
              break;
            case b2:
              h = (r - g2) / d2 + 4;
          }
          h = h * 60;
        }
        if (s < 0) {
          h += 180;
          s = Math.abs(s);
        }
        if (h >= 360) {
          h -= 360;
        }
        return [h, s * 100, l * 100];
      },
      // Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative
      toBase: (hsl) => {
        let [h, s, l] = hsl;
        h = h % 360;
        if (h < 0) {
          h += 360;
        }
        s /= 100;
        l /= 100;
        function f(n2) {
          let k = (n2 + h / 30) % 12;
          let a2 = s * Math.min(l, 1 - l);
          return l - a2 * Math.max(-1, Math.min(k - 3, 9 - k, 1));
        }
        return [f(0), f(8), f(4)];
      },
      formats: {
        "hsl": {
          coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
        },
        "hsla": {
          coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
          commas: true,
          lastAlpha: true
        }
      }
    });
    var HSV = new ColorSpace({
      id: "hsv",
      name: "HSV",
      coords: {
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        },
        s: {
          range: [0, 100],
          name: "Saturation"
        },
        v: {
          range: [0, 100],
          name: "Value"
        }
      },
      base: HSL,
      // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
      fromBase(hsl) {
        let [h, s, l] = hsl;
        s /= 100;
        l /= 100;
        let v = l + s * Math.min(l, 1 - l);
        return [
          h,
          // h is the same
          v === 0 ? 0 : 200 * (1 - l / v),
          // s
          100 * v
        ];
      },
      // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
      toBase(hsv) {
        let [h, s, v] = hsv;
        s /= 100;
        v /= 100;
        let l = v * (1 - s / 2);
        return [
          h,
          // h is the same
          l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,
          l * 100
        ];
      },
      formats: {
        color: {
          id: "--hsv",
          coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
        }
      }
    });
    var hwb = new ColorSpace({
      id: "hwb",
      name: "HWB",
      coords: {
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        },
        w: {
          range: [0, 100],
          name: "Whiteness"
        },
        b: {
          range: [0, 100],
          name: "Blackness"
        }
      },
      base: HSV,
      fromBase(hsv) {
        let [h, s, v] = hsv;
        return [h, v * (100 - s) / 100, 100 - v];
      },
      toBase(hwb2) {
        let [h, w, b2] = hwb2;
        w /= 100;
        b2 /= 100;
        let sum = w + b2;
        if (sum >= 1) {
          let gray = w / sum;
          return [h, 0, gray * 100];
        }
        let v = 1 - b2;
        let s = v === 0 ? 0 : 1 - w / v;
        return [h, s * 100, v * 100];
      },
      formats: {
        "hwb": {
          coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
        }
      }
    });
    var toXYZ_M$2 = [
      [0.5766690429101305, 0.1855582379065463, 0.1882286462349947],
      [0.29734497525053605, 0.6273635662554661, 0.07529145849399788],
      [0.02703136138641234, 0.07068885253582723, 0.9913375368376388]
    ];
    var fromXYZ_M$2 = [
      [2.0415879038107465, -0.5650069742788596, -0.34473135077832956],
      [-0.9692436362808795, 1.8759675015077202, 0.04155505740717557],
      [0.013444280632031142, -0.11836239223101838, 1.0151749943912054]
    ];
    var A98Linear = new RGBColorSpace({
      id: "a98rgb-linear",
      cssId: "--a98-rgb-linear",
      name: "Linear Adobe® 98 RGB compatible",
      white: "D65",
      toXYZ_M: toXYZ_M$2,
      fromXYZ_M: fromXYZ_M$2
    });
    var a98rgb = new RGBColorSpace({
      id: "a98rgb",
      cssId: "a98-rgb",
      name: "Adobe® 98 RGB compatible",
      base: A98Linear,
      toBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
      fromBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val))
    });
    var toXYZ_M$1 = [
      [0.7977666449006423, 0.13518129740053308, 0.0313477341283922],
      [0.2880748288194013, 0.711835234241873, 8993693872564e-17],
      [0, 0, 0.8251046025104602]
    ];
    var fromXYZ_M$1 = [
      [1.3457868816471583, -0.25557208737979464, -0.05110186497554526],
      [-0.5446307051249019, 1.5082477428451468, 0.02052744743642139],
      [0, 0, 1.2119675456389452]
    ];
    var ProPhotoLinear = new RGBColorSpace({
      id: "prophoto-linear",
      cssId: "--prophoto-rgb-linear",
      name: "Linear ProPhoto",
      white: "D50",
      base: XYZ_D50,
      toXYZ_M: toXYZ_M$1,
      fromXYZ_M: fromXYZ_M$1
    });
    var Et = 1 / 512;
    var Et2 = 16 / 512;
    var prophoto = new RGBColorSpace({
      id: "prophoto",
      cssId: "prophoto-rgb",
      name: "ProPhoto",
      base: ProPhotoLinear,
      toBase(RGB) {
        return RGB.map((v) => v < Et2 ? v / 16 : v ** 1.8);
      },
      fromBase(RGB) {
        return RGB.map((v) => v >= Et ? v ** (1 / 1.8) : 16 * v);
      }
    });
    var oklch = new ColorSpace({
      id: "oklch",
      name: "Oklch",
      coords: {
        l: {
          refRange: [0, 1],
          name: "Lightness"
        },
        c: {
          refRange: [0, 0.4],
          name: "Chroma"
        },
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        }
      },
      white: "D65",
      base: OKLab,
      fromBase(oklab) {
        let [L, a2, b2] = oklab;
        let h;
        const ε2 = 2e-4;
        if (Math.abs(a2) < ε2 && Math.abs(b2) < ε2) {
          h = NaN;
        } else {
          h = Math.atan2(b2, a2) * 180 / Math.PI;
        }
        return [
          L,
          // OKLab L is still L
          Math.sqrt(a2 ** 2 + b2 ** 2),
          // Chroma
          constrain(h)
          // Hue, in degrees [0 to 360)
        ];
      },
      // Convert from polar form
      toBase(oklch2) {
        let [L, C, h] = oklch2;
        let a2, b2;
        if (isNaN(h)) {
          a2 = 0;
          b2 = 0;
        } else {
          a2 = C * Math.cos(h * Math.PI / 180);
          b2 = C * Math.sin(h * Math.PI / 180);
        }
        return [L, a2, b2];
      },
      formats: {
        "oklch": {
          coords: ["<percentage> | <number>", "<number> | <percentage>[0,1]", "<number> | <angle>"]
        }
      }
    });
    var white = WHITES.D65;
    var ε$2 = 216 / 24389;
    var κ$1 = 24389 / 27;
    var [U_PRIME_WHITE, V_PRIME_WHITE] = uv({ space: xyz_d65, coords: white });
    var Luv = new ColorSpace({
      id: "luv",
      name: "Luv",
      coords: {
        l: {
          refRange: [0, 100],
          name: "Lightness"
        },
        // Reference ranges from https://facelessuser.github.io/coloraide/colors/luv/
        u: {
          refRange: [-215, 215]
        },
        v: {
          refRange: [-215, 215]
        }
      },
      white,
      base: xyz_d65,
      // Convert D65-adapted XYZ to Luv
      // https://en.wikipedia.org/wiki/CIELUV#The_forward_transformation
      fromBase(XYZ) {
        let xyz = [skipNone(XYZ[0]), skipNone(XYZ[1]), skipNone(XYZ[2])];
        let y = xyz[1];
        let [up, vp] = uv({ space: xyz_d65, coords: xyz });
        if (!Number.isFinite(up) || !Number.isFinite(vp)) {
          return [0, 0, 0];
        }
        let L = y <= ε$2 ? κ$1 * y : 116 * Math.cbrt(y) - 16;
        return [
          L,
          13 * L * (up - U_PRIME_WHITE),
          13 * L * (vp - V_PRIME_WHITE)
        ];
      },
      // Convert Luv to D65-adapted XYZ
      // https://en.wikipedia.org/wiki/CIELUV#The_reverse_transformation
      toBase(Luv2) {
        let [L, u, v] = Luv2;
        if (L === 0 || isNone(L)) {
          return [0, 0, 0];
        }
        u = skipNone(u);
        v = skipNone(v);
        let up = u / (13 * L) + U_PRIME_WHITE;
        let vp = v / (13 * L) + V_PRIME_WHITE;
        let y = L <= 8 ? L / κ$1 : Math.pow((L + 16) / 116, 3);
        return [
          y * (9 * up / (4 * vp)),
          y,
          y * ((12 - 3 * up - 20 * vp) / (4 * vp))
        ];
      },
      formats: {
        color: {
          id: "--luv",
          coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
        }
      }
    });
    var LCHuv = new ColorSpace({
      id: "lchuv",
      name: "LChuv",
      coords: {
        l: {
          refRange: [0, 100],
          name: "Lightness"
        },
        c: {
          refRange: [0, 220],
          name: "Chroma"
        },
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        }
      },
      base: Luv,
      fromBase(Luv2) {
        let [L, u, v] = Luv2;
        let hue;
        const ε2 = 0.02;
        if (Math.abs(u) < ε2 && Math.abs(v) < ε2) {
          hue = NaN;
        } else {
          hue = Math.atan2(v, u) * 180 / Math.PI;
        }
        return [
          L,
          // L is still L
          Math.sqrt(u ** 2 + v ** 2),
          // Chroma
          constrain(hue)
          // Hue, in degrees [0 to 360)
        ];
      },
      toBase(LCH) {
        let [Lightness, Chroma, Hue] = LCH;
        if (Chroma < 0) {
          Chroma = 0;
        }
        if (isNaN(Hue)) {
          Hue = 0;
        }
        return [
          Lightness,
          // L is still L
          Chroma * Math.cos(Hue * Math.PI / 180),
          // u
          Chroma * Math.sin(Hue * Math.PI / 180)
          // v
        ];
      },
      formats: {
        color: {
          id: "--lchuv",
          coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
        }
      }
    });
    var ε$1 = 216 / 24389;
    var κ = 24389 / 27;
    var m_r0 = fromXYZ_M$3[0][0];
    var m_r1 = fromXYZ_M$3[0][1];
    var m_r2 = fromXYZ_M$3[0][2];
    var m_g0 = fromXYZ_M$3[1][0];
    var m_g1 = fromXYZ_M$3[1][1];
    var m_g2 = fromXYZ_M$3[1][2];
    var m_b0 = fromXYZ_M$3[2][0];
    var m_b1 = fromXYZ_M$3[2][1];
    var m_b2 = fromXYZ_M$3[2][2];
    function distanceFromOriginAngle(slope, intercept, angle) {
      const d2 = intercept / (Math.sin(angle) - slope * Math.cos(angle));
      return d2 < 0 ? Infinity : d2;
    }
    function calculateBoundingLines(l) {
      const sub1 = Math.pow(l + 16, 3) / 1560896;
      const sub2 = sub1 > ε$1 ? sub1 : l / κ;
      const s1r = sub2 * (284517 * m_r0 - 94839 * m_r2);
      const s2r = sub2 * (838422 * m_r2 + 769860 * m_r1 + 731718 * m_r0);
      const s3r = sub2 * (632260 * m_r2 - 126452 * m_r1);
      const s1g = sub2 * (284517 * m_g0 - 94839 * m_g2);
      const s2g = sub2 * (838422 * m_g2 + 769860 * m_g1 + 731718 * m_g0);
      const s3g = sub2 * (632260 * m_g2 - 126452 * m_g1);
      const s1b = sub2 * (284517 * m_b0 - 94839 * m_b2);
      const s2b = sub2 * (838422 * m_b2 + 769860 * m_b1 + 731718 * m_b0);
      const s3b = sub2 * (632260 * m_b2 - 126452 * m_b1);
      return {
        r0s: s1r / s3r,
        r0i: s2r * l / s3r,
        r1s: s1r / (s3r + 126452),
        r1i: (s2r - 769860) * l / (s3r + 126452),
        g0s: s1g / s3g,
        g0i: s2g * l / s3g,
        g1s: s1g / (s3g + 126452),
        g1i: (s2g - 769860) * l / (s3g + 126452),
        b0s: s1b / s3b,
        b0i: s2b * l / s3b,
        b1s: s1b / (s3b + 126452),
        b1i: (s2b - 769860) * l / (s3b + 126452)
      };
    }
    function calcMaxChromaHsluv(lines, h) {
      const hueRad = h / 360 * Math.PI * 2;
      const r0 = distanceFromOriginAngle(lines.r0s, lines.r0i, hueRad);
      const r1 = distanceFromOriginAngle(lines.r1s, lines.r1i, hueRad);
      const g0 = distanceFromOriginAngle(lines.g0s, lines.g0i, hueRad);
      const g1 = distanceFromOriginAngle(lines.g1s, lines.g1i, hueRad);
      const b0 = distanceFromOriginAngle(lines.b0s, lines.b0i, hueRad);
      const b1 = distanceFromOriginAngle(lines.b1s, lines.b1i, hueRad);
      return Math.min(r0, r1, g0, g1, b0, b1);
    }
    var hsluv = new ColorSpace({
      id: "hsluv",
      name: "HSLuv",
      coords: {
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        },
        s: {
          range: [0, 100],
          name: "Saturation"
        },
        l: {
          range: [0, 100],
          name: "Lightness"
        }
      },
      base: LCHuv,
      gamutSpace: sRGB,
      // Convert LCHuv to HSLuv
      fromBase(lch2) {
        let [l, c4, h] = [skipNone(lch2[0]), skipNone(lch2[1]), skipNone(lch2[2])];
        let s;
        if (l > 99.9999999) {
          s = 0;
          l = 100;
        } else if (l < 1e-8) {
          s = 0;
          l = 0;
        } else {
          let lines = calculateBoundingLines(l);
          let max3 = calcMaxChromaHsluv(lines, h);
          s = c4 / max3 * 100;
        }
        return [h, s, l];
      },
      // Convert HSLuv to LCHuv
      toBase(hsl) {
        let [h, s, l] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];
        let c4;
        if (l > 99.9999999) {
          l = 100;
          c4 = 0;
        } else if (l < 1e-8) {
          l = 0;
          c4 = 0;
        } else {
          let lines = calculateBoundingLines(l);
          let max3 = calcMaxChromaHsluv(lines, h);
          c4 = max3 / 100 * s;
        }
        return [l, c4, h];
      },
      formats: {
        color: {
          id: "--hsluv",
          coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
        }
      }
    });
    fromXYZ_M$3[0][0];
    fromXYZ_M$3[0][1];
    fromXYZ_M$3[0][2];
    fromXYZ_M$3[1][0];
    fromXYZ_M$3[1][1];
    fromXYZ_M$3[1][2];
    fromXYZ_M$3[2][0];
    fromXYZ_M$3[2][1];
    fromXYZ_M$3[2][2];
    function distanceFromOrigin(slope, intercept) {
      return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
    }
    function calcMaxChromaHpluv(lines) {
      let r0 = distanceFromOrigin(lines.r0s, lines.r0i);
      let r1 = distanceFromOrigin(lines.r1s, lines.r1i);
      let g0 = distanceFromOrigin(lines.g0s, lines.g0i);
      let g1 = distanceFromOrigin(lines.g1s, lines.g1i);
      let b0 = distanceFromOrigin(lines.b0s, lines.b0i);
      let b1 = distanceFromOrigin(lines.b1s, lines.b1i);
      return Math.min(r0, r1, g0, g1, b0, b1);
    }
    var hpluv = new ColorSpace({
      id: "hpluv",
      name: "HPLuv",
      coords: {
        h: {
          refRange: [0, 360],
          type: "angle",
          name: "Hue"
        },
        s: {
          range: [0, 100],
          name: "Saturation"
        },
        l: {
          range: [0, 100],
          name: "Lightness"
        }
      },
      base: LCHuv,
      gamutSpace: "self",
      // Convert LCHuv to HPLuv
      fromBase(lch2) {
        let [l, c4, h] = [skipNone(lch2[0]), skipNone(lch2[1]), skipNone(lch2[2])];
        let s;
        if (l > 99.9999999) {
          s = 0;
          l = 100;
        } else if (l < 1e-8) {
          s = 0;
          l = 0;
        } else {
          let lines = calculateBoundingLines(l);
          let max3 = calcMaxChromaHpluv(lines);
          s = c4 / max3 * 100;
        }
        return [h, s, l];
      },
      // Convert HPLuv to LCHuv
      toBase(hsl) {
        let [h, s, l] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];
        let c4;
        if (l > 99.9999999) {
          l = 100;
          c4 = 0;
        } else if (l < 1e-8) {
          l = 0;
          c4 = 0;
        } else {
          let lines = calculateBoundingLines(l);
          let max3 = calcMaxChromaHpluv(lines);
          c4 = max3 / 100 * s;
        }
        return [l, c4, h];
      },
      formats: {
        color: {
          id: "--hpluv",
          coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
        }
      }
    });
    var Yw = 203;
    var n = 2610 / 2 ** 14;
    var ninv = 2 ** 14 / 2610;
    var m = 2523 / 2 ** 5;
    var minv = 2 ** 5 / 2523;
    var c1 = 3424 / 2 ** 12;
    var c2 = 2413 / 2 ** 7;
    var c3 = 2392 / 2 ** 7;
    var rec2100Pq = new RGBColorSpace({
      id: "rec2100pq",
      cssId: "rec2100-pq",
      name: "REC.2100-PQ",
      base: REC2020Linear,
      toBase(RGB) {
        return RGB.map(function(val) {
          let x = (Math.max(val ** minv - c1, 0) / (c2 - c3 * val ** minv)) ** ninv;
          return x * 1e4 / Yw;
        });
      },
      fromBase(RGB) {
        return RGB.map(function(val) {
          let x = Math.max(val * Yw / 1e4, 0);
          let num = c1 + c2 * x ** n;
          let denom = 1 + c3 * x ** n;
          return (num / denom) ** m;
        });
      }
    });
    var a = 0.17883277;
    var b = 0.28466892;
    var c = 0.55991073;
    var scale = 3.7743;
    var rec2100Hlg = new RGBColorSpace({
      id: "rec2100hlg",
      cssId: "rec2100-hlg",
      name: "REC.2100-HLG",
      referred: "scene",
      base: REC2020Linear,
      toBase(RGB) {
        return RGB.map(function(val) {
          if (val <= 0.5) {
            return val ** 2 / 3 * scale;
          }
          return (Math.exp((val - c) / a) + b) / 12 * scale;
        });
      },
      fromBase(RGB) {
        return RGB.map(function(val) {
          val /= scale;
          if (val <= 1 / 12) {
            return Math.sqrt(3 * val);
          }
          return a * Math.log(12 * val - b) + c;
        });
      }
    });
    var CATs = {};
    hooks.add("chromatic-adaptation-start", (env) => {
      if (env.options.method) {
        env.M = adapt(env.W1, env.W2, env.options.method);
      }
    });
    hooks.add("chromatic-adaptation-end", (env) => {
      if (!env.M) {
        env.M = adapt(env.W1, env.W2, env.options.method);
      }
    });
    function defineCAT({ id, toCone_M, fromCone_M }) {
      CATs[id] = arguments[0];
    }
    function adapt(W1, W2, id = "Bradford") {
      let method = CATs[id];
      let [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);
      let [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);
      let scale2 = [
        [ρd / ρs, 0, 0],
        [0, γd / γs, 0],
        [0, 0, βd / βs]
      ];
      let scaled_cone_M = multiplyMatrices(scale2, method.toCone_M);
      let adapt_M = multiplyMatrices(method.fromCone_M, scaled_cone_M);
      return adapt_M;
    }
    defineCAT({
      id: "von Kries",
      toCone_M: [
        [0.40024, 0.7076, -0.08081],
        [-0.2263, 1.16532, 0.0457],
        [0, 0, 0.91822]
      ],
      fromCone_M: [
        [1.8599363874558397, -1.1293816185800916, 0.21989740959619328],
        [0.3611914362417676, 0.6388124632850422, -6370596838649899e-21],
        [0, 0, 1.0890636230968613]
      ]
    });
    defineCAT({
      id: "Bradford",
      // Convert an array of XYZ values in the range 0.0 - 1.0
      // to cone fundamentals
      toCone_M: [
        [0.8951, 0.2664, -0.1614],
        [-0.7502, 1.7135, 0.0367],
        [0.0389, -0.0685, 1.0296]
      ],
      // and back
      fromCone_M: [
        [0.9869929054667121, -0.14705425642099013, 0.15996265166373122],
        [0.4323052697233945, 0.5183602715367774, 0.049291228212855594],
        [-0.00852866457517732, 0.04004282165408486, 0.96848669578755]
      ]
    });
    defineCAT({
      id: "CAT02",
      // with complete chromatic adaptation to W2, so D = 1.0
      toCone_M: [
        [0.7328, 0.4296, -0.1624],
        [-0.7036, 1.6975, 61e-4],
        [3e-3, 0.0136, 0.9834]
      ],
      fromCone_M: [
        [1.0961238208355142, -0.27886900021828726, 0.18274517938277307],
        [0.4543690419753592, 0.4735331543074117, 0.07209780371722911],
        [-0.009627608738429355, -0.00569803121611342, 1.0153256399545427]
      ]
    });
    defineCAT({
      id: "CAT16",
      toCone_M: [
        [0.401288, 0.650173, -0.051461],
        [-0.250268, 1.204414, 0.045854],
        [-2079e-6, 0.048952, 0.953127]
      ],
      // the extra precision is needed to avoid roundtripping errors
      fromCone_M: [
        [1.862067855087233, -1.0112546305316845, 0.14918677544445172],
        [0.3875265432361372, 0.6214474419314753, -0.008973985167612521],
        [-0.01584149884933386, -0.03412293802851557, 1.0499644368778496]
      ]
    });
    Object.assign(WHITES, {
      // whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer
      // all normalized to Y (luminance) = 1.00000
      // Illuminant A is a tungsten electric light, giving a very warm, orange light.
      A: [1.0985, 1, 0.35585],
      // Illuminant C was an early approximation to daylight: illuminant A with a blue filter.
      C: [0.98074, 1, 1.18232],
      // The daylight series of illuminants simulate natural daylight.
      // The color temperature (in degrees Kelvin/100) ranges from
      // cool, overcast daylight (D50) to bright, direct sunlight (D65).
      D55: [0.95682, 1, 0.92149],
      D75: [0.94972, 1, 1.22638],
      // Equal-energy illuminant, used in two-stage CAT16
      E: [1, 1, 1],
      // The F series of illuminants represent fluorescent lights
      F2: [0.99186, 1, 0.67393],
      F7: [0.95041, 1, 1.08747],
      F11: [1.00962, 1, 0.6435]
    });
    WHITES.ACES = [0.32168 / 0.33767, 1, (1 - 0.32168 - 0.33767) / 0.33767];
    var toXYZ_M = [
      [0.6624541811085053, 0.13400420645643313, 0.1561876870049078],
      [0.27222871678091454, 0.6740817658111484, 0.05368951740793705],
      [-0.005574649490394108, 0.004060733528982826, 1.0103391003129971]
    ];
    var fromXYZ_M = [
      [1.6410233796943257, -0.32480329418479, -0.23642469523761225],
      [-0.6636628587229829, 1.6153315916573379, 0.016756347685530137],
      [0.011721894328375376, -0.008284441996237409, 0.9883948585390215]
    ];
    var ACEScg = new RGBColorSpace({
      id: "acescg",
      cssId: "--acescg",
      name: "ACEScg",
      // ACEScg – A scene-referred, linear-light encoding of ACES Data
      // https://docs.acescentral.com/specifications/acescg/
      // uses the AP1 primaries, see section 4.3.1 Color primaries
      coords: {
        r: {
          range: [0, 65504],
          name: "Red"
        },
        g: {
          range: [0, 65504],
          name: "Green"
        },
        b: {
          range: [0, 65504],
          name: "Blue"
        }
      },
      referred: "scene",
      white: WHITES.ACES,
      toXYZ_M,
      fromXYZ_M
    });
    var ε = 2 ** -16;
    var ACES_min_nonzero = -0.35828683;
    var ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52;
    var acescc = new RGBColorSpace({
      id: "acescc",
      cssId: "--acescc",
      name: "ACEScc",
      // see S-2014-003 ACEScc – A Logarithmic Encoding of ACES Data
      // https://docs.acescentral.com/specifications/acescc/
      // uses the AP1 primaries, see section 4.3.1 Color primaries
      // Appendix A: "Very small ACES scene referred values below 7 1/4 stops
      // below 18% middle gray are encoded as negative ACEScc values.
      // These values should be preserved per the encoding in Section 4.4
      // so that all positive ACES values are maintained."
      coords: {
        r: {
          range: [ACES_min_nonzero, ACES_cc_max],
          name: "Red"
        },
        g: {
          range: [ACES_min_nonzero, ACES_cc_max],
          name: "Green"
        },
        b: {
          range: [ACES_min_nonzero, ACES_cc_max],
          name: "Blue"
        }
      },
      referred: "scene",
      base: ACEScg,
      // from section 4.4.2 Decoding Function
      toBase(RGB) {
        const low = (9.72 - 15) / 17.52;
        return RGB.map(function(val) {
          if (val <= low) {
            return (2 ** (val * 17.52 - 9.72) - ε) * 2;
          } else if (val < ACES_cc_max) {
            return 2 ** (val * 17.52 - 9.72);
          } else {
            return 65504;
          }
        });
      },
      // Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function
      fromBase(RGB) {
        return RGB.map(function(val) {
          if (val <= 0) {
            return (Math.log2(ε) + 9.72) / 17.52;
          } else if (val < ε) {
            return (Math.log2(ε + val * 0.5) + 9.72) / 17.52;
          } else {
            return (Math.log2(val) + 9.72) / 17.52;
          }
        });
      }
      // encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]
      // encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]
    });
    var spaces = Object.freeze({
      __proto__: null,
      A98RGB: a98rgb,
      A98RGB_Linear: A98Linear,
      ACEScc: acescc,
      ACEScg,
      CAM16_JMh: cam16,
      HCT: hct,
      HPLuv: hpluv,
      HSL,
      HSLuv: hsluv,
      HSV,
      HWB: hwb,
      ICTCP: ictcp,
      JzCzHz: jzczhz,
      Jzazbz,
      LCH: lch,
      LCHuv,
      Lab: lab,
      Lab_D65: lab_d65,
      Luv,
      OKLCH: oklch,
      OKLab,
      P3,
      P3_Linear: P3Linear,
      ProPhoto: prophoto,
      ProPhoto_Linear: ProPhotoLinear,
      REC_2020: REC2020,
      REC_2020_Linear: REC2020Linear,
      REC_2100_HLG: rec2100Hlg,
      REC_2100_PQ: rec2100Pq,
      XYZ_ABS_D65: XYZ_Abs_D65,
      XYZ_D50,
      XYZ_D65: xyz_d65,
      sRGB,
      sRGB_Linear: sRGBLinear
    });
    var Color = class _Color {
      /**
       * Creates an instance of Color.
       * Signatures:
       * - `new Color(stringToParse)`
       * - `new Color(otherColor)`
       * - `new Color({space, coords, alpha})`
       * - `new Color(space, coords, alpha)`
       * - `new Color(spaceId, coords, alpha)`
       */
      constructor(...args) {
        let color;
        if (args.length === 1) {
          color = getColor(args[0]);
        }
        let space, coords, alpha;
        if (color) {
          space = color.space || color.spaceId;
          coords = color.coords;
          alpha = color.alpha;
        } else {
          [space, coords, alpha] = args;
        }
        Object.defineProperty(this, "space", {
          value: ColorSpace.get(space),
          writable: false,
          enumerable: true,
          configurable: true
          // see note in https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver
        });
        this.coords = coords ? coords.slice() : [0, 0, 0];
        this.alpha = alpha > 1 || alpha === void 0 ? 1 : alpha < 0 ? 0 : alpha;
        for (let i = 0; i < this.coords.length; i++) {
          if (this.coords[i] === "NaN") {
            this.coords[i] = NaN;
          }
        }
        for (let id in this.space.coords) {
          Object.defineProperty(this, id, {
            get: () => this.get(id),
            set: (value) => this.set(id, value)
          });
        }
      }
      get spaceId() {
        return this.space.id;
      }
      clone() {
        return new _Color(this.space, this.coords, this.alpha);
      }
      toJSON() {
        return {
          spaceId: this.spaceId,
          coords: this.coords,
          alpha: this.alpha
        };
      }
      display(...args) {
        let ret = display(this, ...args);
        ret.color = new _Color(ret.color);
        return ret;
      }
      /**
       * Get a color from the argument passed
       * Basically gets us the same result as new Color(color) but doesn't clone an existing color object
       */
      static get(color, ...args) {
        if (color instanceof _Color) {
          return color;
        }
        return new _Color(color, ...args);
      }
      static defineFunction(name, code, o = code) {
        let { instance = true, returns } = o;
        let func = function(...args) {
          let ret = code(...args);
          if (returns === "color") {
            ret = _Color.get(ret);
          } else if (returns === "function<color>") {
            let f = ret;
            ret = function(...args2) {
              let ret2 = f(...args2);
              return _Color.get(ret2);
            };
            Object.assign(ret, f);
          } else if (returns === "array<color>") {
            ret = ret.map((c4) => _Color.get(c4));
          }
          return ret;
        };
        if (!(name in _Color)) {
          _Color[name] = func;
        }
        if (instance) {
          _Color.prototype[name] = function(...args) {
            return func(this, ...args);
          };
        }
      }
      static defineFunctions(o) {
        for (let name in o) {
          _Color.defineFunction(name, o[name], o[name]);
        }
      }
      static extend(exports2) {
        if (exports2.register) {
          exports2.register(_Color);
        } else {
          for (let name in exports2) {
            _Color.defineFunction(name, exports2[name]);
          }
        }
      }
    };
    Color.defineFunctions({
      get: get11,
      getAll,
      set: set3,
      setAll,
      to,
      equals: equals3,
      inGamut,
      toGamut,
      distance,
      toString: serialize
    });
    Object.assign(Color, {
      util,
      hooks,
      WHITES,
      Space: ColorSpace,
      spaces: ColorSpace.registry,
      parse,
      // Global defaults one may want to configure
      defaults
    });
    for (let key of Object.keys(spaces)) {
      ColorSpace.register(spaces[key]);
    }
    for (let id in ColorSpace.registry) {
      addSpaceAccessors(id, ColorSpace.registry[id]);
    }
    hooks.add("colorspace-init-end", (space) => {
      var _a2;
      addSpaceAccessors(space.id, space);
      (_a2 = space.aliases) == null ? void 0 : _a2.forEach((alias) => {
        addSpaceAccessors(alias, space);
      });
    });
    function addSpaceAccessors(id, space) {
      let propId = id.replace(/-/g, "_");
      Object.defineProperty(Color.prototype, propId, {
        // Convert coords to coords in another colorspace and return them
        // Source colorspace: this.spaceId
        // Target colorspace: id
        get() {
          let ret = this.getAll(id);
          if (typeof Proxy === "undefined") {
            return ret;
          }
          return new Proxy(ret, {
            has: (obj, property) => {
              try {
                ColorSpace.resolveCoord([space, property]);
                return true;
              } catch (e) {
              }
              return Reflect.has(obj, property);
            },
            get: (obj, property, receiver) => {
              if (property && typeof property !== "symbol" && !(property in obj)) {
                let { index } = ColorSpace.resolveCoord([space, property]);
                if (index >= 0) {
                  return obj[index];
                }
              }
              return Reflect.get(obj, property, receiver);
            },
            set: (obj, property, value, receiver) => {
              if (property && typeof property !== "symbol" && !(property in obj) || property >= 0) {
                let { index } = ColorSpace.resolveCoord([space, property]);
                if (index >= 0) {
                  obj[index] = value;
                  this.setAll(id, obj);
                  return true;
                }
              }
              return Reflect.set(obj, property, value, receiver);
            }
          });
        },
        // Convert coords in another colorspace to internal coords and set them
        // Target colorspace: this.spaceId
        // Source colorspace: id
        set(coords) {
          this.setAll(id, coords);
        },
        configurable: true,
        enumerable: true
      });
    }
    Color.extend(deltaEMethods);
    Color.extend({ deltaE });
    Object.assign(Color, { deltaEMethods });
    Color.extend(variations);
    Color.extend({ contrast });
    Color.extend(chromaticity);
    Color.extend(luminance);
    Color.extend(interpolation);
    Color.extend(contrastMethods);
    exports.default = Color;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/color.js
var require_color2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/color.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SassColor = void 0;
    var index_1 = require_value();
    var deprecations_1 = require_deprecations2();
    var utils_1 = require_utils();
    var utils_2 = require_utils2();
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var colorjs_io_1 = require_color();
    function getColorSpace(options) {
      if (typeof options.red === "number")
        return "rgb";
      if (typeof options.saturation === "number")
        return "hsl";
      if (typeof options.whiteness === "number")
        return "hwb";
      throw (0, utils_1.valueError)("No color space found");
    }
    function NaNtoNull(val) {
      return Number.isNaN(val) ? null : val;
    }
    function NaNtoZero(val) {
      return Number.isNaN(val) ? 0 : val;
    }
    function coordToRgb(val) {
      return val * 255;
    }
    function normalizeHue(val) {
      return (0, utils_2.positiveMod)(val, 360);
    }
    function encodeSpaceForColorJs(space) {
      switch (space) {
        case "rgb":
          return "srgb";
        case "a98-rgb":
          return "a98rgb";
        case "display-p3":
          return "p3";
        case "prophoto-rgb":
          return "prophoto";
      }
      return space;
    }
    function encodeGamutMapMethodForColorJs(method) {
      return method === "local-minde" ? "css" : method;
    }
    function decodeSpaceFromColorJs(space, isRgb = false) {
      switch (space) {
        case "srgb":
          return isRgb ? "rgb" : space;
        case "xyz-d65":
          return "xyz";
        case "a98rgb":
          return "a98-rgb";
        case "p3":
          return "display-p3";
        case "prophoto":
          return "prophoto-rgb";
      }
      return space;
    }
    function encodeChannelForColorJs(channel) {
      if (channel === "lightness")
        return "l";
      return channel;
    }
    function validateChannelInSpace(channel, space) {
      if (channel === "alpha")
        return;
      let valid = false;
      switch (space) {
        case "rgb":
        case "srgb":
        case "srgb-linear":
        case "display-p3":
        case "a98-rgb":
        case "prophoto-rgb":
        case "rec2020":
          valid = ["red", "green", "blue"].includes(channel);
          break;
        case "hsl":
          valid = ["hue", "saturation", "lightness"].includes(channel);
          break;
        case "hwb":
          valid = ["hue", "whiteness", "blackness"].includes(channel);
          break;
        case "lab":
        case "oklab":
          valid = ["lightness", "a", "b"].includes(channel);
          break;
        case "lch":
        case "oklch":
          valid = ["lightness", "chroma", "hue"].includes(channel);
          break;
        case "xyz":
        case "xyz-d65":
        case "xyz-d50":
          valid = ["x", "y", "z"].includes(channel);
          break;
      }
      if (!valid) {
        throw (0, utils_1.valueError)(`Unknown channel name "${channel}" for color space "${space}".`);
      }
    }
    function isPolarColorSpace(space) {
      switch (space) {
        case "hsl":
        case "hwb":
        case "lch":
        case "oklch":
          return true;
        default:
          return false;
      }
    }
    function decodeCoordsFromColorJs(coords, isRgb = false) {
      let newCoords = coords;
      if (isRgb)
        newCoords = newCoords.map(coordToRgb);
      return newCoords.map(NaNtoNull);
    }
    function isNumberOrNull(val) {
      return val === null || typeof val === "number";
    }
    function checkChangeDeprecations(options, channels) {
      if (options.alpha === null)
        emitNullAlphaDeprecation();
      for (const channel of channels) {
        if (options[channel] === null)
          emitColor4ApiChangeNullDeprecation(channel);
      }
    }
    function emitColor4ApiGetterDeprecation(name) {
      (0, deprecations_1.warnForHostSideDeprecation)(`\`${name}\` is deprecated, use \`channel\` instead.
More info: https://sass-lang.com/d/color-4-api`, deprecations_1.deprecations["color-4-api"]);
    }
    function emitColor4ApiChangeSpaceDeprecation() {
      (0, deprecations_1.warnForHostSideDeprecation)("Changing a channel not in this color's space without explicitly specifying the `space` option is deprecated.\nMore info: https://sass-lang.com/d/color-4-api", deprecations_1.deprecations["color-4-api"]);
    }
    function emitColor4ApiChangeNullDeprecation(channel) {
      (0, deprecations_1.warnForHostSideDeprecation)(`Passing \`${channel}: null\` without setting \`space\` is deprecated.
More info: https://sass-lang.com/d/color-4-api`, deprecations_1.deprecations["color-4-api"]);
    }
    function emitNullAlphaDeprecation() {
      (0, deprecations_1.warnForHostSideDeprecation)("Passing `alpha: null` without setting `space` is deprecated.\nMore info: https://sass-lang.com/d/null-alpha", deprecations_1.deprecations["null-alpha"]);
    }
    function optionsHaveColor(opts) {
      return opts.color instanceof colorjs_io_1.default;
    }
    var SassColor3 = class _SassColor extends index_1.Value {
      constructor(optionsMaybeWithColor) {
        super();
        // ColorJS color object
        __publicField(this, "color");
        // Boolean indicating whether this color is in RGB format
        //
        // ColorJS treats `rgb` as an output format of the `srgb` color space, while
        // Sass treats it as its own color space. By internally tracking whether this
        // color is `rgb` or not, we can use `srgb` consistently for ColorJS while
        // still returning expected `rgb` values for Sass users.
        __publicField(this, "isRgb", false);
        // Names for the channels of this color
        __publicField(this, "channel0Id");
        __publicField(this, "channel1Id");
        __publicField(this, "channel2Id");
        let options;
        if (optionsHaveColor(optionsMaybeWithColor)) {
          const { color, space: space2 } = optionsMaybeWithColor;
          if (space2 === "rgb")
            this.isRgb = true;
          this.setChannelIds(space2);
          this.color = color;
          return;
        } else {
          options = optionsMaybeWithColor;
        }
        const space = options.space ?? getColorSpace(options);
        this.setChannelIds(space);
        if (space === "rgb")
          this.isRgb = true;
        let alpha;
        if (options.alpha === null) {
          if (!options.space)
            emitNullAlphaDeprecation();
          alpha = NaN;
        } else if (options.alpha === void 0) {
          alpha = 1;
        } else {
          alpha = (0, utils_2.fuzzyAssertInRange)(options.alpha, 0, 1, "alpha");
        }
        switch (space) {
          case "rgb":
          case "srgb": {
            const red = options.red ?? NaN;
            const green = options.green ?? NaN;
            const blue = options.blue ?? NaN;
            if (this.isRgb) {
              this.color = new colorjs_io_1.default({
                spaceId: encodeSpaceForColorJs(space),
                // convert from 0-255 to 0-1
                coords: [red / 255, green / 255, blue / 255],
                alpha
              });
            } else {
              this.color = new colorjs_io_1.default({
                spaceId: encodeSpaceForColorJs(space),
                coords: [red, green, blue],
                alpha
              });
            }
            break;
          }
          case "srgb-linear":
          case "display-p3":
          case "a98-rgb":
          case "prophoto-rgb":
          case "rec2020":
            this.color = new colorjs_io_1.default({
              spaceId: encodeSpaceForColorJs(space),
              coords: [
                options.red ?? NaN,
                options.green ?? NaN,
                options.blue ?? NaN
              ],
              alpha
            });
            break;
          case "hsl": {
            let hue = normalizeHue(options.hue ?? NaN);
            let saturation = options.saturation ?? NaN;
            const lightness = options.lightness ?? NaN;
            if (!Number.isNaN(saturation) && (0, utils_2.fuzzyLessThan)(saturation, 0)) {
              saturation = Math.abs(saturation);
              hue = (hue + 180) % 360;
            }
            this.color = new colorjs_io_1.default({
              spaceId: encodeSpaceForColorJs(space),
              coords: [hue, saturation, lightness],
              alpha
            });
            break;
          }
          case "hwb": {
            const hue = normalizeHue(options.hue ?? NaN);
            const whiteness = options.whiteness ?? NaN;
            const blackness = options.blackness ?? NaN;
            this.color = new colorjs_io_1.default({
              spaceId: encodeSpaceForColorJs(space),
              coords: [hue, whiteness, blackness],
              alpha
            });
            break;
          }
          case "lab":
          case "oklab": {
            const lightness = options.lightness ?? NaN;
            const a = options.a ?? NaN;
            const b = options.b ?? NaN;
            this.color = new colorjs_io_1.default({
              spaceId: encodeSpaceForColorJs(space),
              coords: [lightness, a, b],
              alpha
            });
            break;
          }
          case "lch":
          case "oklch": {
            const lightness = options.lightness ?? NaN;
            let chroma = options.chroma ?? NaN;
            let hue = normalizeHue(options.hue ?? NaN);
            if (!Number.isNaN(chroma) && (0, utils_2.fuzzyLessThan)(chroma, 0)) {
              chroma = Math.abs(chroma);
              hue = (hue + 180) % 360;
            }
            this.color = new colorjs_io_1.default({
              spaceId: encodeSpaceForColorJs(space),
              coords: [lightness, chroma, hue],
              alpha
            });
            break;
          }
          case "xyz":
          case "xyz-d65":
          case "xyz-d50":
            this.color = new colorjs_io_1.default({
              spaceId: encodeSpaceForColorJs(space),
              coords: [options.x ?? NaN, options.y ?? NaN, options.z ?? NaN],
              alpha
            });
            break;
        }
        if (Number.isNaN(alpha)) {
          this.color.alpha = NaN;
        }
      }
      // Sets channel names based on this color's color space
      setChannelIds(space) {
        switch (space) {
          case "rgb":
          case "srgb":
          case "srgb-linear":
          case "display-p3":
          case "a98-rgb":
          case "prophoto-rgb":
          case "rec2020":
            this.channel0Id = "red";
            this.channel1Id = "green";
            this.channel2Id = "blue";
            break;
          case "hsl":
            this.channel0Id = "hue";
            this.channel1Id = "saturation";
            this.channel2Id = "lightness";
            break;
          case "hwb":
            this.channel0Id = "hue";
            this.channel1Id = "whiteness";
            this.channel2Id = "blackness";
            break;
          case "lab":
          case "oklab":
            this.channel0Id = "lightness";
            this.channel1Id = "a";
            this.channel2Id = "b";
            break;
          case "lch":
          case "oklch":
            this.channel0Id = "lightness";
            this.channel1Id = "chroma";
            this.channel2Id = "hue";
            break;
          case "xyz":
          case "xyz-d65":
          case "xyz-d50":
            this.channel0Id = "x";
            this.channel1Id = "y";
            this.channel2Id = "z";
            break;
        }
      }
      /** This color's alpha channel, between `0` and `1`. */
      get alpha() {
        return NaNtoZero(this.color.alpha);
      }
      /** The name of this color's color space. */
      get space() {
        return decodeSpaceFromColorJs(this.color.spaceId, this.isRgb);
      }
      /**
       * A boolean indicating whether this color is in a legacy color space (`rgb`,
       * `hsl`, or `hwb`).
       */
      get isLegacy() {
        return ["rgb", "hsl", "hwb"].includes(this.space);
      }
      /**
       * A list of this color's channel values (excluding alpha), with [missing
       * channels] converted to `null`.
       *
       * [missing channels]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#missing_color_components
       */
      get channelsOrNull() {
        let coords = this.color.coords;
        if (this.space === "rgb") {
          coords = coords.map(coordToRgb);
        }
        return (0, immutable_1.List)(coords.map(NaNtoNull));
      }
      /**
       * A list of this color's channel values (excluding alpha), with [missing
       * channels] converted to `0`.
       *
       * [missing channels]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#missing_color_components
       */
      get channels() {
        let coords = this.color.coords;
        if (this.space === "rgb") {
          coords = coords.map(coordToRgb);
        }
        return (0, immutable_1.List)(coords.map(NaNtoZero));
      }
      /**
       * This color's red channel in the RGB color space, between `0` and `255`.
       *
       * @deprecated Use {@link channel} instead.
       */
      get red() {
        emitColor4ApiGetterDeprecation("red");
        const val = NaNtoZero(coordToRgb(this.color.srgb.red));
        return (0, utils_2.fuzzyRound)(val);
      }
      /**
       * This color's green channel in the RGB color space, between `0` and `255`.
       *
       * @deprecated Use {@link channel} instead.
       */
      get green() {
        emitColor4ApiGetterDeprecation("green");
        const val = NaNtoZero(coordToRgb(this.color.srgb.green));
        return (0, utils_2.fuzzyRound)(val);
      }
      /**
       * This color's blue channel in the RGB color space, between `0` and `255`.
       *
       * @deprecated Use {@link channel} instead.
       */
      get blue() {
        emitColor4ApiGetterDeprecation("blue");
        const val = NaNtoZero(coordToRgb(this.color.srgb.blue));
        return (0, utils_2.fuzzyRound)(val);
      }
      /**
       * This color's hue in the HSL color space, between `0` and `360`.
       *
       * @deprecated Use {@link channel} instead.
       */
      get hue() {
        emitColor4ApiGetterDeprecation("hue");
        return NaNtoZero(this.color.hsl.hue);
      }
      /**
       * This color's saturation in the HSL color space, between `0` and `100`.
       *
       * @deprecated Use {@link channel} instead.
       */
      get saturation() {
        emitColor4ApiGetterDeprecation("saturation");
        return NaNtoZero(this.color.hsl.saturation);
      }
      /**
       * This color's lightness in the HSL color space, between `0` and `100`.
       *
       * @deprecated Use {@link channel} instead.
       */
      get lightness() {
        emitColor4ApiGetterDeprecation("lightness");
        return NaNtoZero(this.color.hsl.lightness);
      }
      /**
       * This color's whiteness in the HWB color space, between `0` and `100`.
       *
       * @deprecated Use {@link channel} instead.
       */
      get whiteness() {
        emitColor4ApiGetterDeprecation("whiteness");
        return NaNtoZero(this.color.hwb.whiteness);
      }
      /**
       * This color's blackness in the HWB color space, between `0` and `100`.
       *
       * @deprecated Use {@link channel} instead.
       */
      get blackness() {
        emitColor4ApiGetterDeprecation("blackness");
        return NaNtoZero(this.color.hwb.blackness);
      }
      assertColor() {
        return this;
      }
      /**
       * Returns a new color that's the result of converting this color to the
       * specified `space`.
       */
      toSpace(space) {
        if (space === this.space)
          return this;
        const color = this.color.to(encodeSpaceForColorJs(space));
        return new _SassColor({ color, space });
      }
      /**
       * Returns a boolean indicating whether this color is in-gamut (as opposed to
       * having one or more of its channels out of bounds) for the specified
       * `space`, or its current color space if `space` is not specified.
       */
      isInGamut(space) {
        return this.color.inGamut(encodeSpaceForColorJs(space));
      }
      /**
       * Returns a copy of this color, modified so it is in-gamut for the specified
       * `space`—or the current color space if `space` is not specified—using
       * `method` to map out-of-gamut colors into the desired gamut.
       */
      toGamut({ space, method }) {
        if (this.isInGamut(space))
          return this;
        const color = this.color.clone().toGamut({
          space: encodeSpaceForColorJs(space),
          method: encodeGamutMapMethodForColorJs(method)
        });
        return new _SassColor({ color, space: space ?? this.space });
      }
      channel(channel, options) {
        if (channel === "alpha")
          return this.alpha;
        let val;
        const space = (options == null ? void 0 : options.space) ?? this.space;
        validateChannelInSpace(channel, space);
        if (options == null ? void 0 : options.space) {
          val = this.color.get({
            space: encodeSpaceForColorJs(options.space),
            coordId: encodeChannelForColorJs(channel)
          });
        } else {
          val = this.color.get({
            space: this.color.spaceId,
            coordId: encodeChannelForColorJs(channel)
          });
        }
        if (space === "rgb")
          val = coordToRgb(val);
        return NaNtoZero(val);
      }
      /**
       * Returns a boolean indicating whether a given channel value is a [missing
       * channel].
       *
       * [missing channel]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#missing_color_components
       */
      isChannelMissing(channel) {
        if (channel === "alpha")
          return Number.isNaN(this.color.alpha);
        validateChannelInSpace(channel, this.space);
        return Number.isNaN(this.color.get({
          space: this.color.spaceId,
          coordId: encodeChannelForColorJs(channel)
        }));
      }
      isChannelPowerless(channel, options) {
        if (channel === "alpha")
          return false;
        const color = (options == null ? void 0 : options.space) ? this.toSpace(options.space) : this;
        validateChannelInSpace(channel, color.space);
        const channels = color.channels.toArray();
        switch (channel) {
          case color.channel0Id:
            if (color.space === "hsl")
              return (0, utils_2.fuzzyEquals)(channels[1], 0);
            if (color.space === "hwb") {
              return (0, utils_2.fuzzyGreaterThanOrEquals)(channels[1] + channels[2], 100);
            }
            return false;
          case color.channel2Id:
            switch (color.space) {
              case "lch":
              case "oklch":
                return (0, utils_2.fuzzyEquals)(channels[1], 0);
            }
            return false;
        }
        return false;
      }
      /**
       * Returns a color partway between this color and `color2` according to
       * `method`, as defined by the CSS Color 4 [color interpolation] procedure.
       *
       * [color interpolation]: https://www.w3.org/TR/css-color-4/#interpolation
       *
       * If `method` is missing and this color is in a polar color space (HSL, HWB,
       * LCH, and Oklch spaces), `method` defaults to "shorter".
       *
       * The `weight` is a number between 0 and 1 that indicates how much of this
       * color should be in the resulting color. If omitted, it defaults to 0.5.
       */
      interpolate(color2, options) {
        const hueInterpolationMethod = (options == null ? void 0 : options.method) ?? (isPolarColorSpace(this.space) ? "shorter" : void 0);
        const weight = (options == null ? void 0 : options.weight) ?? 0.5;
        if ((0, utils_2.fuzzyEquals)(weight, 0))
          return color2;
        if ((0, utils_2.fuzzyEquals)(weight, 1))
          return this;
        if (weight < 0 || weight > 1) {
          throw (0, utils_1.valueError)(`Expected \`weight\` between \`0\` and \`1\`, received \`${weight}\`.`);
        }
        const color = this.color.mix(color2.color, 1 - weight, {
          space: encodeSpaceForColorJs(this.space),
          hue: hueInterpolationMethod
        });
        const coords = decodeCoordsFromColorJs(color.coords, this.space === "rgb");
        return new _SassColor({
          space: this.space,
          [this.channel0Id]: coords[0],
          [this.channel1Id]: coords[1],
          [this.channel2Id]: coords[2],
          alpha: NaNtoNull(this.color.alpha)
        });
      }
      /** Legacy determination of color space by option channels. */
      getLegacyChangeSpace(options) {
        let space;
        if (isNumberOrNull(options.whiteness) || isNumberOrNull(options.blackness) || this.space === "hwb" && isNumberOrNull(options.hue)) {
          space = "hwb";
        } else if (isNumberOrNull(options.hue) || isNumberOrNull(options.saturation) || isNumberOrNull(options.lightness)) {
          space = "hsl";
        } else if (isNumberOrNull(options.red) || isNumberOrNull(options.green) || isNumberOrNull(options.blue)) {
          space = "rgb";
        }
        if (space !== this.space)
          emitColor4ApiChangeSpaceDeprecation();
        return space ?? this.space;
      }
      /**
       * Returns a new SassColor in the given `space` that's the result of changing
       * one or more of this color's channels.
       */
      getChangedColor(options, space, spaceSetExplicitly) {
        const color = this.toSpace(space);
        function getChangedValue(channel) {
          if (isNumberOrNull(options[channel]))
            return options[channel];
          return color.channel(channel);
        }
        switch (space) {
          case "hsl":
            if (spaceSetExplicitly) {
              return new _SassColor({
                hue: getChangedValue("hue"),
                saturation: getChangedValue("saturation"),
                lightness: getChangedValue("lightness"),
                alpha: getChangedValue("alpha"),
                space
              });
            } else {
              checkChangeDeprecations(options, ["hue", "saturation", "lightness"]);
              return new _SassColor({
                hue: options.hue ?? color.channel("hue"),
                saturation: options.saturation ?? color.channel("saturation"),
                lightness: options.lightness ?? color.channel("lightness"),
                alpha: options.alpha ?? color.channel("alpha"),
                space
              });
            }
          case "hwb":
            if (spaceSetExplicitly) {
              return new _SassColor({
                hue: getChangedValue("hue"),
                whiteness: getChangedValue("whiteness"),
                blackness: getChangedValue("blackness"),
                alpha: getChangedValue("alpha"),
                space
              });
            } else {
              checkChangeDeprecations(options, ["hue", "whiteness", "blackness"]);
              return new _SassColor({
                hue: options.hue ?? color.channel("hue"),
                whiteness: options.whiteness ?? color.channel("whiteness"),
                blackness: options.blackness ?? color.channel("blackness"),
                alpha: options.alpha ?? color.channel("alpha"),
                space
              });
            }
          case "rgb":
            if (spaceSetExplicitly) {
              return new _SassColor({
                red: getChangedValue("red"),
                green: getChangedValue("green"),
                blue: getChangedValue("blue"),
                alpha: getChangedValue("alpha"),
                space
              });
            } else {
              checkChangeDeprecations(options, ["red", "green", "blue"]);
              return new _SassColor({
                red: options.red ?? color.channel("red"),
                green: options.green ?? color.channel("green"),
                blue: options.blue ?? color.channel("blue"),
                alpha: options.alpha ?? color.channel("alpha"),
                space
              });
            }
          case "lab":
          case "oklab":
            return new _SassColor({
              lightness: getChangedValue("lightness"),
              a: getChangedValue("a"),
              b: getChangedValue("b"),
              alpha: getChangedValue("alpha"),
              space
            });
          case "lch":
          case "oklch":
            return new _SassColor({
              lightness: getChangedValue("lightness"),
              chroma: getChangedValue("chroma"),
              hue: getChangedValue("hue"),
              alpha: getChangedValue("alpha"),
              space
            });
          case "a98-rgb":
          case "display-p3":
          case "prophoto-rgb":
          case "rec2020":
          case "srgb":
          case "srgb-linear":
            return new _SassColor({
              red: getChangedValue("red"),
              green: getChangedValue("green"),
              blue: getChangedValue("blue"),
              alpha: getChangedValue("alpha"),
              space
            });
          case "xyz":
          case "xyz-d50":
          case "xyz-d65":
            return new _SassColor({
              y: getChangedValue("y"),
              x: getChangedValue("x"),
              z: getChangedValue("z"),
              alpha: getChangedValue("alpha"),
              space
            });
        }
      }
      change(options) {
        const spaceSetExplicitly = !!options.space;
        let space = options.space ?? this.space;
        if (this.isLegacy && !spaceSetExplicitly) {
          space = this.getLegacyChangeSpace(options);
        }
        const keys2 = Object.keys(options).filter((key) => key !== "space");
        for (const channel of keys2) {
          validateChannelInSpace(channel, space);
        }
        if (isNumberOrNull(options.alpha) && options.alpha !== null) {
          (0, utils_2.fuzzyAssertInRange)(options.alpha, 0, 1, "alpha");
        }
        return this.getChangedColor(options, space, spaceSetExplicitly).toSpace(this.space);
      }
      equals(other) {
        if (!(other instanceof _SassColor))
          return false;
        let coords = this.color.coords;
        let otherCoords = other.color.coords;
        if (this.isLegacy) {
          if (!other.isLegacy)
            return false;
          if (!(0, utils_2.fuzzyEquals)(this.alpha, other.alpha))
            return false;
          if (!(this.space === "rgb" && other.space === "rgb")) {
            coords = this.color.to("srgb").coords.map(coordToRgb).map(utils_2.fuzzyRound);
            otherCoords = other.color.to("srgb").coords.map(coordToRgb).map(utils_2.fuzzyRound);
          }
          return (0, utils_2.fuzzyEquals)(coords[0], otherCoords[0]) && (0, utils_2.fuzzyEquals)(coords[1], otherCoords[1]) && (0, utils_2.fuzzyEquals)(coords[2], otherCoords[2]);
        }
        return this.space === other.space && (0, utils_2.fuzzyEquals)(coords[0], otherCoords[0]) && (0, utils_2.fuzzyEquals)(coords[1], otherCoords[1]) && (0, utils_2.fuzzyEquals)(coords[2], otherCoords[2]) && (0, utils_2.fuzzyEquals)(this.alpha, other.alpha);
      }
      hashCode() {
        let coords = this.color.coords;
        if (this.isLegacy) {
          coords = this.color.to("srgb").coords.map(coordToRgb).map(utils_2.fuzzyRound);
          return (0, utils_2.fuzzyHashCode)(coords[0]) ^ (0, utils_2.fuzzyHashCode)(coords[1]) ^ (0, utils_2.fuzzyHashCode)(coords[2]) ^ (0, utils_2.fuzzyHashCode)(this.alpha);
        }
        return (0, immutable_1.hash)(this.space) ^ (0, utils_2.fuzzyHashCode)(coords[0]) ^ (0, utils_2.fuzzyHashCode)(coords[1]) ^ (0, utils_2.fuzzyHashCode)(coords[2]) ^ (0, utils_2.fuzzyHashCode)(this.alpha);
      }
      toString() {
        return this.color.toString({ inGamut: false });
      }
    };
    exports.SassColor = SassColor3;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/function.js
var require_function = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SassFunction = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var index_1 = require_value();
    var SassFunction3 = class _SassFunction extends index_1.Value {
      constructor(idOrSignature, callback) {
        super();
        /**
         * If this function is defined in the compiler, this is the unique ID that the
         * compiler uses to determine which function it refers to.
         *
         * This is marked as public so that the protofier can access it, but it's not
         * part of the package's public API and should not be accessed by user code.
         * It may be renamed or removed without warning in the future.
         */
        __publicField(this, "id");
        /**
         * If this function is defined in the host, this is the signature that
         * describes how to pass arguments to it.
         *
         * This is marked as public so that the protofier can access it, but it's not
         * part of the package's public API and should not be accessed by user code.
         * It may be renamed or removed without warning in the future.
         */
        __publicField(this, "signature");
        /**
         * If this function is defined in the host, this is the callback to run when
         * the function is invoked from a stylesheet.
         *
         * This is marked as public so that the protofier can access it, but it's not
         * part of the package's public API and should not be accessed by user code.
         * It may be renamed or removed without warning in the future.
         */
        __publicField(this, "callback");
        if (typeof idOrSignature === "number") {
          this.id = idOrSignature;
        } else {
          this.signature = idOrSignature;
          this.callback = callback;
        }
      }
      equals(other) {
        return this.id === void 0 ? other === this : other instanceof _SassFunction && other.id === this.id;
      }
      hashCode() {
        return this.id === void 0 ? (0, immutable_1.hash)(this.signature) : (0, immutable_1.hash)(this.id);
      }
      toString() {
        return this.signature ? this.signature : `<compiler function ${this.id}>`;
      }
    };
    exports.SassFunction = SassFunction3;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/mixin.js
var require_mixin = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/mixin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SassMixin = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var index_1 = require_value();
    var SassMixin3 = class _SassMixin extends index_1.Value {
      constructor(id) {
        super();
        /**
         * This is the unique ID that the compiler uses to determine which mixin it
         * refers to.
         *
         * This is marked as public so that the protofier can access it, but it's not
         * part of the package's public API and should not be accessed by user code.
         * It may be renamed or removed without warning in the future.
         */
        __publicField(this, "id");
        this.id = id;
      }
      equals(other) {
        return other instanceof _SassMixin && other.id === this.id;
      }
      hashCode() {
        return (0, immutable_1.hash)(this.id);
      }
      toString() {
        return `<compiler mixin ${this.id}>`;
      }
      assertMixin() {
        return this;
      }
    };
    exports.SassMixin = SassMixin3;
  }
});

// node_modules/sass-embedded/dist/lib/src/value/number.js
var require_number = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SassNumber = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var utils_1 = require_utils();
    var index_1 = require_value();
    var utils_2 = require_utils2();
    var conversions = {
      // Length
      in: {
        in: 1,
        cm: 1 / 2.54,
        pc: 1 / 6,
        mm: 1 / 25.4,
        q: 1 / 101.6,
        pt: 1 / 72,
        px: 1 / 96
      },
      cm: {
        in: 2.54,
        cm: 1,
        pc: 2.54 / 6,
        mm: 1 / 10,
        q: 1 / 40,
        pt: 2.54 / 72,
        px: 2.54 / 96
      },
      pc: {
        in: 6,
        cm: 6 / 2.54,
        pc: 1,
        mm: 6 / 25.4,
        q: 6 / 101.6,
        pt: 1 / 12,
        px: 1 / 16
      },
      mm: {
        in: 25.4,
        cm: 10,
        pc: 25.4 / 6,
        mm: 1,
        q: 1 / 4,
        pt: 25.4 / 72,
        px: 25.4 / 96
      },
      q: {
        in: 101.6,
        cm: 40,
        pc: 101.6 / 6,
        mm: 4,
        q: 1,
        pt: 101.6 / 72,
        px: 101.6 / 96
      },
      pt: {
        in: 72,
        cm: 72 / 2.54,
        pc: 12,
        mm: 72 / 25.4,
        q: 72 / 101.6,
        pt: 1,
        px: 3 / 4
      },
      px: {
        in: 96,
        cm: 96 / 2.54,
        pc: 16,
        mm: 96 / 25.4,
        q: 96 / 101.6,
        pt: 4 / 3,
        px: 1
      },
      // Rotation
      deg: {
        deg: 1,
        grad: 9 / 10,
        rad: 180 / Math.PI,
        turn: 360
      },
      grad: {
        deg: 10 / 9,
        grad: 1,
        rad: 200 / Math.PI,
        turn: 400
      },
      rad: {
        deg: Math.PI / 180,
        grad: Math.PI / 200,
        rad: 1,
        turn: 2 * Math.PI
      },
      turn: {
        deg: 1 / 360,
        grad: 1 / 400,
        rad: 1 / (2 * Math.PI),
        turn: 1
      },
      // Time
      s: {
        s: 1,
        ms: 1 / 1e3
      },
      ms: {
        s: 1e3,
        ms: 1
      },
      // Frequency
      Hz: { Hz: 1, kHz: 1e3 },
      kHz: { Hz: 1 / 1e3, kHz: 1 },
      // Pixel density
      dpi: {
        dpi: 1,
        dpcm: 2.54,
        dppx: 96
      },
      dpcm: {
        dpi: 1 / 2.54,
        dpcm: 1,
        dppx: 96 / 2.54
      },
      dppx: {
        dpi: 1 / 96,
        dpcm: 2.54 / 96,
        dppx: 1
      }
    };
    var unitsByType = {
      length: ["in", "cm", "pc", "mm", "q", "pt", "px"],
      angle: ["deg", "grad", "rad", "turn"],
      time: ["s", "ms"],
      frequency: ["Hz", "kHz"],
      "pixel density": ["dpi", "dpcm", "dppx"]
    };
    var typesByUnit = {};
    for (const [type, units] of Object.entries(unitsByType)) {
      for (const unit of units) {
        typesByUnit[unit] = type;
      }
    }
    var SassNumber3 = class _SassNumber extends index_1.Value {
      constructor(value, unitOrOptions) {
        super();
        __publicField(this, "valueInternal");
        __publicField(this, "numeratorUnitsInternal");
        __publicField(this, "denominatorUnitsInternal");
        if (typeof unitOrOptions === "string") {
          this.valueInternal = value;
          this.numeratorUnitsInternal = unitOrOptions === void 0 ? (0, immutable_1.List)([]) : (0, immutable_1.List)([unitOrOptions]);
          this.denominatorUnitsInternal = (0, immutable_1.List)([]);
          return;
        }
        let numerators = (0, utils_1.asImmutableList)((unitOrOptions == null ? void 0 : unitOrOptions.numeratorUnits) ?? []);
        const unsimplifiedDenominators = (unitOrOptions == null ? void 0 : unitOrOptions.denominatorUnits) ?? [];
        const denominators = [];
        for (const denominator of unsimplifiedDenominators) {
          let simplifiedAway = false;
          for (const [i, numerator] of numerators.entries()) {
            const factor = conversionFactor(denominator, numerator);
            if (factor === null)
              continue;
            value /= factor;
            numerators = numerators.delete(i);
            simplifiedAway = true;
            break;
          }
          if (!simplifiedAway)
            denominators.push(denominator);
        }
        this.valueInternal = value;
        this.numeratorUnitsInternal = numerators;
        this.denominatorUnitsInternal = (0, immutable_1.List)(denominators);
      }
      /** `this`'s value. */
      get value() {
        return this.valueInternal;
      }
      /** Whether `value` is an integer. */
      get isInt() {
        return (0, utils_2.fuzzyIsInt)(this.value);
      }
      /**
       * If `value` is an integer according to `isInt`, returns `value` rounded to
       * that integer.
       *
       * Otherwise, returns null.
       */
      get asInt() {
        return (0, utils_2.fuzzyAsInt)(this.value);
      }
      /** `this`'s numerator units. */
      get numeratorUnits() {
        return this.numeratorUnitsInternal;
      }
      /** `this`'s denominator units. */
      get denominatorUnits() {
        return this.denominatorUnitsInternal;
      }
      /** Whether `this` has any units. */
      get hasUnits() {
        return !(this.numeratorUnits.isEmpty() && this.denominatorUnits.isEmpty());
      }
      assertNumber() {
        return this;
      }
      /**
       * If `value` is an integer according to `isInt`, returns it as an integer.
       *
       * Otherwise, throws an error.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertInt(name) {
        const int = (0, utils_2.fuzzyAsInt)(this.value);
        if (int === null) {
          throw (0, utils_1.valueError)(`${this} is not an int`, name);
        }
        return int;
      }
      /**
       * If `value` is within `min` and `max`, returns `value`, or if it
       * `fuzzyEquals` `min` or `max`, returns `value` clamped to that value.
       *
       * Otherwise, throws an error.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertInRange(min2, max2, name) {
        const clamped = (0, utils_2.fuzzyInRange)(this.value, min2, max2);
        if (clamped === null) {
          throw (0, utils_1.valueError)(`${this} must be between ${min2} and ${max2}`, name);
        }
        return clamped;
      }
      /**
       * If `this` has no units, returns `this`.
       *
       * Otherwise, throws an error.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertNoUnits(name) {
        if (this.hasUnits) {
          throw (0, utils_1.valueError)(`Expected ${this} to have no units`, name);
        }
        return this;
      }
      /**
       * If `this` has `unit` as its only unit (and as a numerator), returns `this`.
       *
       * Otherwise, throws an error.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      assertUnit(unit, name) {
        if (!this.hasUnit(unit)) {
          throw (0, utils_1.valueError)(`Expected ${this} to have no unit ${unit}`, name);
        }
        return this;
      }
      /** Whether `this` has `unit` as its only unit (and as a numerator). */
      hasUnit(unit) {
        return this.denominatorUnits.isEmpty() && this.numeratorUnits.size === 1 && this.numeratorUnits.get(0) === unit;
      }
      /** Whether `this` is compatible with `unit`. */
      compatibleWithUnit(unit) {
        if (!this.denominatorUnits.isEmpty())
          return false;
        if (this.numeratorUnits.size > 1)
          return false;
        const numerator = this.numeratorUnits.get(0);
        return typesByUnit[numerator] ? typesByUnit[numerator] === typesByUnit[unit] : numerator === unit;
      }
      /**
       * Returns a copy of `this`, converted to the units represented by
       * `newNumerators` and `newDenominators`.
       *
       * Throws an error if `this`'s units are incompatible with `newNumerators` and
       * `newDenominators`. Also throws an error if `this` is unitless and either
       * `newNumerators` or `newDenominators` are not empty, or vice-versa.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      convert(newNumerators, newDenominators, name) {
        return new _SassNumber(this.convertValue(newNumerators, newDenominators, name), { numeratorUnits: newNumerators, denominatorUnits: newDenominators });
      }
      /**
       * Returns `value`, converted to the units represented by `newNumerators` and
       * `newDenominators`.
       *
       * Throws an error if `this`'s units are incompatible with `newNumerators` and
       * `newDenominators`. Also throws an error if `this` is unitless and either
       * `newNumerators` or `newDenominators` are not empty, or vice-versa.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      convertValue(newNumerators, newDenominators, name) {
        return this.convertOrCoerce({
          coerceUnitless: false,
          newNumeratorUnits: (0, utils_1.asImmutableList)(newNumerators),
          newDenominatorUnits: (0, utils_1.asImmutableList)(newDenominators),
          name
        });
      }
      /**
       * Returns a copy of `this`, converted to the same units as `other`.
       *
       * Throws an error if `this`'s units are incompatible with `other`'s units, or
       * if either number is unitless but the other is not.
       *
       * If `this` came from a function argument, `name` is the argument name
       * and `otherName` is the argument name for `other` (both without the `$`).
       * They are used for error reporting.
       */
      convertToMatch(other, name, otherName) {
        return new _SassNumber(this.convertValueToMatch(other, name, otherName), {
          numeratorUnits: other.numeratorUnits,
          denominatorUnits: other.denominatorUnits
        });
      }
      /**
       * Returns `value`, converted to the same units as `other`.
       *
       * Throws an error if `this`'s units are incompatible with `other`'s units, or
       * if either number is unitless but the other is not.
       *
       * If `this` came from a function argument, `name` is the argument name
       * and `otherName` is the argument name for `other` (both without the `$`).
       * They are used for error reporting.
       */
      convertValueToMatch(other, name, otherName) {
        return this.convertOrCoerce({
          coerceUnitless: false,
          other,
          name,
          otherName
        });
      }
      /**
       * Returns a copy of `this`, converted to the units represented by
       * `newNumerators` and `newDenominators`.
       *
       * Does *not* throw an error if this number is unitless and either
       * `newNumerators` or `newDenominators` are not empty, or vice-versa. Instead,
       * it treats all unitless numbers as convertible to and from all units
       * without changing the value.
       *
       * Throws an error if `this`'s units are incompatible with `newNumerators` and
       * `newDenominators`.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      coerce(newNumerators, newDenominators, name) {
        return new _SassNumber(this.coerceValue(newNumerators, newDenominators, name), { numeratorUnits: newNumerators, denominatorUnits: newDenominators });
      }
      /**
       * Returns `value`, converted to the units represented by `newNumerators` and
       * `newDenominators`.
       *
       * Does *not* throw an error if this number is unitless and either
       * `newNumerators` or `newDenominators` are not empty, or vice-versa. Instead,
       * it treats all unitless numbers as convertible to and from all units
       * without changing the value.
       *
       * Throws an error if `this`'s units are incompatible with `newNumerators` and
       * `newDenominators`.
       *
       * If `this` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      coerceValue(newNumerators, newDenominators, name) {
        return this.convertOrCoerce({
          coerceUnitless: true,
          newNumeratorUnits: (0, utils_1.asImmutableList)(newNumerators),
          newDenominatorUnits: (0, utils_1.asImmutableList)(newDenominators),
          name
        });
      }
      /**
       * Returns a copy of `this`, converted to the same units as `other`.
       *
       * Does *not* throw an error if `this` is unitless and `other` is not, or
       * vice-versa. Instead, it treats all unitless numbers as convertible to and
       * from all units without changing the value.
       *
       * Throws an error if `this`'s units are incompatible with `other`'s units.
       *
       * If `this` came from a function argument, `name` is the argument name
       * and `otherName` is the argument name for `other` (both without the `$`).
       * They are used for error reporting.
       */
      coerceToMatch(other, name, otherName) {
        return new _SassNumber(this.coerceValueToMatch(other, name, otherName), {
          numeratorUnits: other.numeratorUnits,
          denominatorUnits: other.denominatorUnits
        });
      }
      /**
       * Returns `value`, converted to the same units as `other`.
       *
       * Does *not* throw an error if `this` is unitless and `other` is not, or
       * vice-versa. Instead, it treats all unitless numbers as convertible to and
       * from all units without changing the value.
       *
       * Throws an error if `this`'s units are incompatible with `other`'s units.
       *
       * If `this` came from a function argument, `name` is the argument name
       * and `otherName` is the argument name for `other` (both without the `$`).
       * They are used for error reporting.
       */
      coerceValueToMatch(other, name, otherName) {
        return this.convertOrCoerce({
          coerceUnitless: true,
          other,
          name,
          otherName
        });
      }
      equals(other) {
        if (!(other instanceof _SassNumber))
          return false;
        try {
          return (0, utils_2.fuzzyEquals)(this.value, other.convertValueToMatch(this));
        } catch {
          return false;
        }
      }
      hashCode() {
        const canonicalNumerators = canonicalizeUnits(this.numeratorUnits);
        const canonicalDenominators = canonicalizeUnits(this.denominatorUnits);
        const canonicalValue = this.convertValue(canonicalNumerators, canonicalDenominators);
        return (0, utils_2.fuzzyHashCode)(canonicalValue) ^ (0, immutable_1.hash)(canonicalNumerators) ^ (0, immutable_1.hash)(canonicalDenominators);
      }
      toString() {
        return `${this.value}${unitString(this.numeratorUnits, this.denominatorUnits)}`;
      }
      // Returns the value of converting `number` to new units.
      //
      // The units may be specified as lists of units (`newNumeratorUnits` and
      // `newDenominatorUnits`), or by providng a SassNumber `other` that contains the
      // desired units.
      //
      // Throws an error if `number` is not compatible with the new units. Coercing a
      // unitful number to unitless (or vice-versa) throws an error unless
      // specifically enabled with `coerceUnitless`.
      convertOrCoerce(params) {
        const newNumerators = "other" in params ? params.other.numeratorUnits : params.newNumeratorUnits;
        const newDenominators = "other" in params ? params.other.denominatorUnits : params.newDenominatorUnits;
        const compatibilityError = () => {
          if ("other" in params) {
            let message = `${this} and`;
            if (params.otherName) {
              message += ` $${params.otherName}:`;
            }
            message += ` ${params.other} have incompatible units`;
            if (!this.hasUnits || !otherHasUnits) {
              message += " (one has units and the other doesn't)";
            }
            return (0, utils_1.valueError)(message, params.name);
          }
          if (!otherHasUnits) {
            return (0, utils_1.valueError)(`Expected ${this} to have no units.`, params.name);
          }
          if (newNumerators.size === 1 && newDenominators.isEmpty()) {
            const type = typesByUnit[newNumerators.get(0)];
            if (type) {
              return (0, utils_1.valueError)(`Expected ${this} to have a single ${type} unit (${unitsByType[type].join(", ")}).`, params.name);
            }
          }
          const unitSize = newNumerators.size + newDenominators.size;
          return (0, utils_1.valueError)(`Expected $this to have ${unitSize === 0 ? "no units" : `unit${unitSize > 1 ? "s" : ""} ${unitString(newNumerators, newDenominators)}`}.`, params.name);
        };
        const otherHasUnits = !newNumerators.isEmpty() || !newDenominators.isEmpty();
        if (this.hasUnits && !otherHasUnits || !this.hasUnits && otherHasUnits) {
          if (params.coerceUnitless)
            return this.value;
          throw compatibilityError();
        }
        if (this.numeratorUnits.equals(newNumerators) && this.denominatorUnits.equals(newDenominators)) {
          return this.value;
        }
        let value = this.value;
        let oldNumerators = this.numeratorUnits;
        for (const newNumerator of newNumerators) {
          const idx = oldNumerators.findIndex((oldNumerator) => {
            const factor = conversionFactor(oldNumerator, newNumerator);
            if (factor === null)
              return false;
            value *= factor;
            return true;
          });
          if (idx < 0)
            throw compatibilityError();
          oldNumerators = oldNumerators.delete(idx);
        }
        let oldDenominators = this.denominatorUnits;
        for (const newDenominator of newDenominators) {
          const idx = oldDenominators.findIndex((oldDenominator) => {
            const factor = conversionFactor(oldDenominator, newDenominator);
            if (factor === null)
              return false;
            value /= factor;
            return true;
          });
          if (idx < 0)
            throw compatibilityError();
          oldDenominators = oldDenominators.delete(idx);
        }
        if (!oldNumerators.isEmpty() || !oldDenominators.isEmpty()) {
          throw compatibilityError();
        }
        return value;
      }
    };
    exports.SassNumber = SassNumber3;
    function conversionFactor(fromUnit, toUnit) {
      if (fromUnit === toUnit)
        return 1;
      const factors = conversions[toUnit];
      if (!factors)
        return null;
      return factors[fromUnit] ?? null;
    }
    function unitString(numerators, denominators) {
      if (numerators.isEmpty() && denominators.isEmpty()) {
        return "";
      }
      if (denominators.isEmpty()) {
        return numerators.join("*");
      }
      if (numerators.isEmpty()) {
        return denominators.size === 1 ? `${denominators.get(0)}^-1` : `(${denominators.join("*")})^-1`;
      }
      return `${numerators.join("*")}/${denominators.join("*")}`;
    }
    function canonicalizeUnits(units) {
      return units.map((unit) => {
        const type = typesByUnit[unit];
        return type ? unitsByType[type][0] : unit;
      }).sort();
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/value/string.js
var require_string = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SassString = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var index_1 = require_value();
    var utils_1 = require_utils();
    var SassString3 = class _SassString extends index_1.Value {
      constructor(textOrOptions, options) {
        super();
        __publicField(this, "textInternal");
        __publicField(this, "hasQuotesInternal");
        if (typeof textOrOptions === "string") {
          this.textInternal = textOrOptions;
          this.hasQuotesInternal = (options == null ? void 0 : options.quotes) ?? true;
        } else {
          this.textInternal = "";
          this.hasQuotesInternal = (textOrOptions == null ? void 0 : textOrOptions.quotes) ?? true;
        }
      }
      /** Creates an empty string, optionally with quotes. */
      static empty(options) {
        return options === void 0 || (options == null ? void 0 : options.quotes) ? emptyQuoted : emptyUnquoted;
      }
      /** `this`'s text. */
      get text() {
        return this.textInternal;
      }
      /** Whether `this` has quotes. */
      get hasQuotes() {
        return this.hasQuotesInternal;
      }
      assertString() {
        return this;
      }
      /**
       * Sass's notion of `this`'s length.
       *
       * Sass treats strings as a series of Unicode code points while JS treats them
       * as a series of UTF-16 code units. For example, the character U+1F60A,
       * Smiling Face With Smiling Eyes, is a single Unicode code point but is
       * represented in UTF-16 as two code units (`0xD83D` and `0xDE0A`). So in
       * JS, `"n😊b".length` returns `4`, whereas in Sass `string.length("n😊b")`
       * returns `3`.
       */
      get sassLength() {
        let length = 0;
        for (const codepoint of this.text) {
          length++;
        }
        return length;
      }
      /**
       * Converts `sassIndex` to a JS index into `text`.
       *
       * Sass indices are one-based, while JS indices are zero-based. Sass
       * indices may also be negative in order to index from the end of the string.
       *
       * In addition, Sass indices refer to Unicode code points while JS string
       * indices refer to UTF-16 code units. For example, the character U+1F60A,
       * Smiling Face With Smiling Eyes, is a single Unicode code point but is
       * represented in UTF-16 as two code units (`0xD83D` and `0xDE0A`). So in
       * JS, `"n😊b".charAt(1)` returns `0xD83D`, whereas in Sass
       * `string.slice("n😊b", 1, 1)` returns `"😊"`.
       *
       * This function converts Sass's code point indices to JS's code unit
       * indices. This means it's O(n) in the length of `text`.
       *
       * Throws an error `sassIndex` isn't a number, if that number isn't an
       * integer, or if that integer isn't a valid index for this string.
       *
       * If `sassIndex` came from a function argument, `name` is the argument name
       * (without the `$`) and is used for error reporting.
       */
      sassIndexToStringIndex(sassIndex, name) {
        let sassIdx = sassIndex.assertNumber().assertInt();
        if (sassIdx === 0) {
          throw (0, utils_1.valueError)("String index may not be 0", name);
        }
        const sassLength = this.sassLength;
        if (Math.abs(sassIdx) > sassLength) {
          throw (0, utils_1.valueError)(`Invalid index ${sassIdx} for a string with ${sassLength} characters`, name);
        }
        if (sassIdx < 0)
          sassIdx += sassLength + 1;
        let pointer = 1;
        let idx = 0;
        for (const codePoint of this.text) {
          if (pointer === sassIdx)
            break;
          idx += codePoint.length;
          pointer++;
        }
        return idx;
      }
      equals(other) {
        return other instanceof _SassString && this.text === other.text;
      }
      hashCode() {
        return (0, immutable_1.hash)(this.text);
      }
      toString() {
        return this.hasQuotes ? `"${this.text}"` : this.text;
      }
    };
    exports.SassString = SassString3;
    var emptyQuoted = new SassString3("", { quotes: true });
    var emptyUnquoted = new SassString3("", { quotes: false });
  }
});

// node_modules/sass-embedded/dist/lib/src/value/calculations.js
var require_calculations = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/value/calculations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CalculationInterpolation = exports.CalculationOperation = exports.SassCalculation = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var index_1 = require_value();
    var string_1 = require_string();
    function assertCalculationValue(value) {
      if (value instanceof string_1.SassString && value.hasQuotes) {
        throw new Error(`Expected ${value} to be an unquoted string.`);
      }
    }
    function isValidClampArg(value) {
      return value instanceof CalculationInterpolation3 || value instanceof string_1.SassString && !value.hasQuotes;
    }
    var SassCalculation3 = class _SassCalculation extends index_1.Value {
      constructor(name, args) {
        super();
        __publicField(this, "name");
        __publicField(this, "arguments");
        this.name = name;
        this.arguments = (0, immutable_1.List)(args);
      }
      static calc(argument) {
        assertCalculationValue(argument);
        return new _SassCalculation("calc", [argument]);
      }
      static min(args) {
        args.forEach(assertCalculationValue);
        return new _SassCalculation("min", args);
      }
      static max(args) {
        args.forEach(assertCalculationValue);
        return new _SassCalculation("max", args);
      }
      static clamp(min2, value, max2) {
        if (value === void 0 && !isValidClampArg(min2) || max2 === void 0 && ![min2, value].some((x) => x && isValidClampArg(x))) {
          throw new Error("Argument must be an unquoted SassString or CalculationInterpolation.");
        }
        const args = [min2];
        if (value !== void 0)
          args.push(value);
        if (max2 !== void 0)
          args.push(max2);
        args.forEach(assertCalculationValue);
        return new _SassCalculation("clamp", args);
      }
      assertCalculation() {
        return this;
      }
      equals(other) {
        return other instanceof _SassCalculation && this.name === other.name && this.arguments.equals(other.arguments);
      }
      hashCode() {
        return (0, immutable_1.hash)(this.name) ^ this.arguments.hashCode();
      }
      toString() {
        return `${this.name}(${this.arguments.join(", ")})`;
      }
    };
    exports.SassCalculation = SassCalculation3;
    var operators = ["+", "-", "*", "/"];
    var CalculationOperation3 = class _CalculationOperation {
      constructor(operator, left, right) {
        __publicField(this, "operator");
        __publicField(this, "left");
        __publicField(this, "right");
        this.operator = operator;
        this.left = left;
        this.right = right;
        if (!operators.includes(operator)) {
          throw new Error(`Invalid operator: ${operator}`);
        }
        assertCalculationValue(left);
        assertCalculationValue(right);
      }
      equals(other) {
        return other instanceof _CalculationOperation && this.operator === other.operator && this.left === other.left && this.right === other.right;
      }
      hashCode() {
        return (0, immutable_1.hash)(this.operator) ^ (0, immutable_1.hash)(this.left) ^ (0, immutable_1.hash)(this.right);
      }
    };
    exports.CalculationOperation = CalculationOperation3;
    var CalculationInterpolation3 = class _CalculationInterpolation {
      constructor(value) {
        __publicField(this, "value");
        this.value = value;
      }
      equals(other) {
        return other instanceof _CalculationInterpolation && this.value === other.value;
      }
      hashCode() {
        return (0, immutable_1.hash)(this.value);
      }
    };
    exports.CalculationInterpolation = CalculationInterpolation3;
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/value/base.js
var require_base = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/value/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyValueBase = void 0;
    var LegacyValueBase = class {
      constructor(inner) {
        __publicField(this, "inner");
        this.inner = inner;
      }
    };
    exports.LegacyValueBase = LegacyValueBase;
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/value/color.js
var require_color3 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/value/color.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyColor = void 0;
    var utils_1 = require_utils();
    var color_1 = require_color2();
    var base_1 = require_base();
    var LegacyColor = class extends base_1.LegacyValueBase {
      constructor(redOrArgb, green, blue, alpha) {
        if (redOrArgb instanceof color_1.SassColor) {
          super(redOrArgb);
          return;
        }
        let red;
        if ((0, utils_1.isNullOrUndefined)(green) || (0, utils_1.isNullOrUndefined)(blue)) {
          const argb = redOrArgb;
          alpha = (argb >> 24) / 255;
          red = (argb >> 16) % 256;
          green = (argb >> 8) % 256;
          blue = argb % 256;
        } else {
          red = redOrArgb;
        }
        super(new color_1.SassColor({
          red: clamp(red, 0, 255),
          green: clamp(green, 0, 255),
          blue: clamp(blue, 0, 255),
          alpha: alpha ? clamp(alpha, 0, 1) : 1
        }));
      }
      getR() {
        return this.inner.red;
      }
      setR(value) {
        this.inner = this.inner.change({ red: clamp(value, 0, 255) });
      }
      getG() {
        return this.inner.green;
      }
      setG(value) {
        this.inner = this.inner.change({ green: clamp(value, 0, 255) });
      }
      getB() {
        return this.inner.blue;
      }
      setB(value) {
        this.inner = this.inner.change({ blue: clamp(value, 0, 255) });
      }
      getA() {
        return this.inner.alpha;
      }
      setA(value) {
        this.inner = this.inner.change({ alpha: clamp(value, 0, 1) });
      }
    };
    exports.LegacyColor = LegacyColor;
    Object.defineProperty(LegacyColor, "name", { value: "sass.types.Color" });
    function clamp(num, min2, max2) {
      return Math.min(Math.max(num, min2), max2);
    }
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/value/map.js
var require_map2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/value/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyMap = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var base_1 = require_base();
    var map_1 = require_map();
    var number_1 = require_number();
    var null_1 = require_null();
    var wrap_1 = require_wrap();
    var LegacyMap = class extends base_1.LegacyValueBase {
      constructor(lengthOrInner) {
        if (lengthOrInner instanceof map_1.SassMap) {
          super(lengthOrInner);
          return;
        }
        super(new map_1.SassMap((0, immutable_1.OrderedMap)(Array.from({ length: lengthOrInner }, (_, i) => [
          new number_1.SassNumber(i),
          null_1.sassNull
        ]))));
      }
      getValue(index) {
        const value = this.inner.contents.valueSeq().get(index);
        if (index < 0 || !value) {
          throw new Error(`Invalid index ${index}, must be between 0 and ` + this.inner.contents.size);
        }
        return (0, wrap_1.wrapValue)(value);
      }
      setValue(index, value) {
        this.inner = new map_1.SassMap(this.inner.contents.set(this.getUnwrappedKey(index), (0, wrap_1.unwrapValue)(value)));
      }
      getKey(index) {
        return (0, wrap_1.wrapValue)(this.getUnwrappedKey(index));
      }
      // Like `getKey()`, but returns the unwrapped non-legacy value.
      getUnwrappedKey(index) {
        const key = this.inner.contents.keySeq().get(index);
        if (index >= 0 && key)
          return key;
        throw new Error(`Invalid index ${index}, must be between 0 and ` + this.inner.contents.size);
      }
      setKey(index, key) {
        const oldMap = this.inner.contents;
        if (index < 0 || index >= oldMap.size) {
          throw new Error(`Invalid index ${index}, must be between 0 and ${oldMap.size}`);
        }
        const newKey = (0, wrap_1.unwrapValue)(key);
        const newMap = (0, immutable_1.OrderedMap)().asMutable();
        let i = 0;
        for (const [oldKey, oldValue] of oldMap.entries()) {
          if (i === index) {
            newMap.set(newKey, oldValue);
          } else {
            if (newKey.equals(oldKey)) {
              throw new Error(`${key} is already in the map`);
            }
            newMap.set(oldKey, oldValue);
          }
          i++;
        }
        this.inner = new map_1.SassMap(newMap.asImmutable());
      }
      getLength() {
        return this.inner.contents.size;
      }
    };
    exports.LegacyMap = LegacyMap;
    Object.defineProperty(LegacyMap, "name", { value: "sass.types.Map" });
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/value/number.js
var require_number2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/value/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyNumber = void 0;
    var number_1 = require_number();
    var base_1 = require_base();
    var LegacyNumber = class extends base_1.LegacyValueBase {
      constructor(valueOrInner, unit) {
        super(valueOrInner instanceof number_1.SassNumber ? valueOrInner : parseNumber(valueOrInner, unit));
      }
      getValue() {
        return this.inner.value;
      }
      setValue(value) {
        this.inner = new number_1.SassNumber(value, {
          numeratorUnits: this.inner.numeratorUnits,
          denominatorUnits: this.inner.denominatorUnits
        });
      }
      getUnit() {
        return this.inner.numeratorUnits.join("*") + (this.inner.denominatorUnits.size === 0 ? "" : "/") + this.inner.denominatorUnits.join("*");
      }
      setUnit(unit) {
        this.inner = parseNumber(this.inner.value, unit);
      }
    };
    exports.LegacyNumber = LegacyNumber;
    Object.defineProperty(LegacyNumber, "name", { value: "sass.types.Number" });
    function parseNumber(value, unit) {
      if (!unit)
        return new number_1.SassNumber(value);
      if (!unit.includes("*") && !unit.includes("/")) {
        return new number_1.SassNumber(value, unit);
      }
      const invalidUnit = new Error(`Unit ${unit} is invalid`);
      const operands = unit.split("/");
      if (operands.length > 2)
        throw invalidUnit;
      const numerator = operands[0];
      const denominator = operands.length === 1 ? null : operands[1];
      const numeratorUnits = numerator.length === 0 ? [] : numerator.split("*");
      if (numeratorUnits.some((unit2) => unit2.length === 0))
        throw invalidUnit;
      const denominatorUnits = denominator === null ? [] : denominator.split("*");
      if (denominatorUnits.some((unit2) => unit2.length === 0))
        throw invalidUnit;
      return new number_1.SassNumber(value, {
        numeratorUnits,
        denominatorUnits
      });
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/value/string.js
var require_string2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/value/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyString = void 0;
    var string_1 = require_string();
    var base_1 = require_base();
    var LegacyString = class extends base_1.LegacyValueBase {
      constructor(valueOrInner) {
        if (valueOrInner instanceof string_1.SassString) {
          super(valueOrInner);
        } else {
          super(new string_1.SassString(valueOrInner, { quotes: false }));
        }
      }
      getValue() {
        return this.inner.text;
      }
      setValue(value) {
        this.inner = new string_1.SassString(value, { quotes: false });
      }
    };
    exports.LegacyString = LegacyString;
    Object.defineProperty(LegacyString, "name", { value: "sass.types.String" });
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/value/wrap.js
var require_wrap = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/value/wrap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapFunction = wrapFunction;
    exports.unwrapValue = unwrapValue;
    exports.wrapValue = wrapValue;
    var util = require_util();
    var base_1 = require_base();
    var color_1 = require_color3();
    var list_1 = require_list2();
    var map_1 = require_map2();
    var number_1 = require_number2();
    var string_1 = require_string2();
    var value_1 = require_value();
    var color_2 = require_color2();
    var list_2 = require_list();
    var map_2 = require_map();
    var number_2 = require_number();
    var string_2 = require_string();
    function wrapFunction(thisArg, callback, sync) {
      if (sync) {
        return (args) => unwrapTypedValue(callback.apply(thisArg, args.map(wrapValue)));
      } else {
        return (args) => new Promise((resolve, reject) => {
          function done(result) {
            try {
              if (result instanceof Error) {
                reject(result);
              } else {
                resolve(unwrapTypedValue(result));
              }
            } catch (error) {
              reject(error);
            }
          }
          const syncResult = callback.apply(thisArg, [...args.map(wrapValue), done]);
          if (syncResult !== void 0)
            resolve(unwrapTypedValue(syncResult));
        });
      }
    }
    function unwrapTypedValue(value) {
      return unwrapValue(value);
    }
    function unwrapValue(value) {
      if (value instanceof Error)
        throw value;
      if (value instanceof value_1.Value)
        return value;
      if (value instanceof base_1.LegacyValueBase)
        return value.inner;
      throw new Error(`Expected legacy Sass value, got ${util.inspect(value)}.`);
    }
    function wrapValue(value) {
      if (value instanceof color_2.SassColor)
        return new color_1.LegacyColor(value);
      if (value instanceof list_2.SassList)
        return new list_1.LegacyList(value);
      if (value instanceof map_2.SassMap)
        return new map_1.LegacyMap(value);
      if (value instanceof number_2.SassNumber)
        return new number_1.LegacyNumber(value);
      if (value instanceof string_2.SassString)
        return new string_1.LegacyString(value);
      if (value instanceof value_1.Value)
        return value;
      throw new Error(`Expected Sass value, got ${util.inspect(value)}.`);
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/value/list.js
var require_list2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/value/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyList = void 0;
    var base_1 = require_base();
    var list_1 = require_list();
    var null_1 = require_null();
    var wrap_1 = require_wrap();
    var LegacyList = class extends base_1.LegacyValueBase {
      constructor(lengthOrInner, commaSeparator) {
        if (lengthOrInner instanceof list_1.SassList) {
          super(lengthOrInner);
          return;
        }
        super(new list_1.SassList(new Array(lengthOrInner).fill(null_1.sassNull), {
          separator: commaSeparator === false ? " " : ","
        }));
      }
      getValue(index) {
        const length = this.inner.asList.size;
        if (index < 0 || index >= length) {
          throw new Error(`Invalid index ${index}, must be between 0 and ${length}`);
        }
        const value = this.inner.get(index);
        return value ? (0, wrap_1.wrapValue)(value) : void 0;
      }
      setValue(index, value) {
        this.inner = new list_1.SassList(this.inner.asList.set(index, (0, wrap_1.unwrapValue)(value)), {
          separator: this.inner.separator,
          brackets: this.inner.hasBrackets
        });
      }
      getSeparator() {
        return this.inner.separator === ",";
      }
      setSeparator(isComma) {
        this.inner = new list_1.SassList(this.inner.asList, {
          separator: isComma ? "," : " ",
          brackets: this.inner.hasBrackets
        });
      }
      getLength() {
        return this.inner.asList.size;
      }
    };
    exports.LegacyList = LegacyList;
    Object.defineProperty(LegacyList, "name", { value: "sass.types.List" });
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/value/index.js
var require_value2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/value/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Error = exports.String = exports.Number = exports.Null = exports.Map = exports.List = exports.Color = exports.Boolean = void 0;
    var boolean_1 = require_boolean();
    var null_1 = require_null();
    var color_1 = require_color3();
    var list_1 = require_list2();
    var map_1 = require_map2();
    var number_1 = require_number2();
    var string_1 = require_string2();
    exports.Boolean = boolean_1.SassBooleanInternal;
    exports.Color = color_1.LegacyColor;
    exports.List = list_1.LegacyList;
    exports.Map = map_1.LegacyMap;
    exports.Null = null_1.SassNull;
    exports.Number = number_1.LegacyNumber;
    exports.String = string_1.LegacyString;
    exports.Error = global.Error;
  }
});

// node_modules/sass-embedded/dist/lib/src/deprotofy-span.js
var require_deprotofy_span = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/deprotofy-span.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deprotofySourceSpan = deprotofySourceSpan;
    var url_1 = require_url();
    var utils_1 = require_utils();
    function deprotofySourceSpan(buffer) {
      const text = buffer.text;
      if (buffer.start === void 0) {
        throw (0, utils_1.compilerError)("Expected SourceSpan to have start.");
      }
      let end;
      if (buffer.end === void 0) {
        if (text !== "") {
          throw (0, utils_1.compilerError)("Expected SourceSpan text to be empty.");
        } else {
          end = buffer.start;
        }
      } else {
        end = buffer.end;
        if (end.offset < buffer.start.offset) {
          throw (0, utils_1.compilerError)("Expected SourceSpan end to be after start.");
        }
      }
      const url = buffer.url === "" ? void 0 : new url_1.URL(buffer.url);
      const context = buffer.context === "" ? void 0 : buffer.context;
      return {
        text,
        start: buffer.start,
        end,
        url,
        context
      };
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/exception.js
var require_exception = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/exception.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Exception = void 0;
    var deprotofy_span_1 = require_deprotofy_span();
    var Exception3 = class extends Error {
      constructor(failure) {
        super(failure.formatted);
        __publicField(this, "sassMessage");
        __publicField(this, "sassStack");
        __publicField(this, "span");
        this.sassMessage = failure.message;
        this.sassStack = failure.stackTrace;
        this.span = (0, deprotofy_span_1.deprotofySourceSpan)(failure.span);
      }
      toString() {
        return this.message;
      }
    };
    exports.Exception = Exception3;
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFunction = void 0;
    function isFunction(value) {
      return typeof value === "function";
    }
    exports.isFunction = isFunction;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createErrorClass = void 0;
    function createErrorClass(createImpl) {
      var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    exports.createErrorClass = createErrorClass;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsubscriptionError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrRemove = void 0;
    function arrRemove(arr, item) {
      if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }
    exports.arrRemove = arrRemove;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports) {
    "use strict";
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = void 0;
    var isFunction_1 = require_isFunction();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var arrRemove_1 = require_arrRemove();
    var Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values2(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                } finally {
                  if (e_1) throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction_1.isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values2(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove_1.arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty = new Subscription2();
        empty.closed = true;
        return empty;
      }();
      return Subscription2;
    }();
    exports.Subscription = Subscription;
    exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
      return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
    }
    exports.isSubscription = isSubscription;
    function execFinalizer(finalizer) {
      if (isFunction_1.isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.config = void 0;
    exports.config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeoutProvider = void 0;
    exports.timeoutProvider = {
      setTimeout: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
      },
      clearTimeout: function(handle) {
        var delegate = exports.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportUnhandledError = void 0;
    var config_1 = require_config();
    var timeoutProvider_1 = require_timeoutProvider();
    function reportUnhandledError(err) {
      timeoutProvider_1.timeoutProvider.setTimeout(function() {
        var onUnhandledError = config_1.config.onUnhandledError;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }
    exports.reportUnhandledError = reportUnhandledError;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noop = void 0;
    function noop() {
    }
    exports.noop = noop;
  }
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = void 0;
    exports.COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
    function errorNotification(error) {
      return createNotification("E", void 0, error);
    }
    exports.errorNotification = errorNotification;
    function nextNotification(value) {
      return createNotification("N", value, void 0);
    }
    exports.nextNotification = nextNotification;
    function createNotification(kind, value, error) {
      return {
        kind,
        value,
        error
      };
    }
    exports.createNotification = createNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.captureError = exports.errorContext = void 0;
    var config_1 = require_config();
    var context = null;
    function errorContext(cb) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
          context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
          var _a = context, errorThrown = _a.errorThrown, error = _a.error;
          context = null;
          if (errorThrown) {
            throw error;
          }
        }
      } else {
        cb();
      }
    }
    exports.errorContext = errorContext;
    function captureError(err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
      }
    }
    exports.captureError = captureError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
    var isFunction_1 = require_isFunction();
    var Subscription_1 = require_Subscription();
    var config_1 = require_config();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var noop_1 = require_noop();
    var NotificationFactories_1 = require_NotificationFactories();
    var timeoutProvider_1 = require_timeoutProvider();
    var errorContext_1 = require_errorContext();
    var Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports.Subscriber = Subscriber;
    var _bind = Function.prototype.bind;
    function bind(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    exports.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error);
      } else {
        reportUnhandledError_1.reportUnhandledError(error);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observable = void 0;
    exports.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.identity = void 0;
    function identity(x) {
      return x;
    }
    exports.identity = identity;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pipeFromArray = exports.pipe = void 0;
    var identity_1 = require_identity();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports.pipe = pipe;
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports.pipeFromArray = pipeFromArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Observable = void 0;
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var isFunction_1 = require_isFunction();
    var errorContext_1 = require_errorContext();
    var Observable = function() {
      function Observable2(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable = new Observable2();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
        errorContext_1.errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable2.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
    exports.Observable = Observable;
    function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
      return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
    }
    function isSubscriber(value) {
      return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.operate = exports.hasLift = void 0;
    var isFunction_1 = require_isFunction();
    function hasLift(source) {
      return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    exports.hasLift = hasLift;
    function operate(init) {
      return function(source) {
        if (hasLift(source)) {
          return source.lift(function(liftedSource) {
            try {
              return init(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError("Unable to lift unknown Observable type");
      };
    }
    exports.operate = operate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperatorSubscriber = exports.createOperatorSubscriber = void 0;
    var Subscriber_1 = require_Subscriber();
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    exports.createOperatorSubscriber = createOperatorSubscriber;
    var OperatorSubscriber = function(_super) {
      __extends(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.OperatorSubscriber = OperatorSubscriber;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.refCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function refCount() {
      return lift_1.operate(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
          if (!source || source._refCount <= 0 || 0 < --source._refCount) {
            connection = null;
            return;
          }
          var sharedConnection = source._connection;
          var conn = connection;
          connection = null;
          if (sharedConnection && (!conn || sharedConnection === conn)) {
            sharedConnection.unsubscribe();
          }
          subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
          connection = source.connect();
        }
      });
    }
    exports.refCount = refCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectableObservable = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    var ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (lift_1.hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription_1.Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable_1.Observable);
    exports.ConnectableObservable = ConnectableObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.performanceTimestampProvider = void 0;
    exports.performanceTimestampProvider = {
      now: function() {
        return (exports.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrameProvider = void 0;
    var Subscription_1 = require_Subscription();
    exports.animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports.animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp) {
          cancel = void 0;
          callback(timestamp);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrames = void 0;
    var Observable_1 = require_Observable();
    var performanceTimestampProvider_1 = require_performanceTimestampProvider();
    var animationFrameProvider_1 = require_animationFrameProvider();
    function animationFrames(timestampProvider) {
      return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    exports.animationFrames = animationFrames;
    function animationFramesFactory(timestampProvider) {
      return new Observable_1.Observable(function(subscriber) {
        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
        var start = provider.now();
        var id = 0;
        var run = function() {
          if (!subscriber.closed) {
            id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
              id = 0;
              var now = provider.now();
              subscriber.next({
                timestamp: timestampProvider ? now : timestamp,
                elapsed: now - start
              });
              run();
            });
          }
        };
        run();
        return function() {
          if (id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          }
        };
      });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectUnsubscribedError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousSubject = exports.Subject = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var arrRemove_1 = require_arrRemove();
    var errorContext_1 = require_errorContext();
    var Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext_1.errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values2(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return Subscription_1.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription_1.Subscription(function() {
          _this.currentObservers = null;
          arrRemove_1.arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable_1.Observable);
    exports.Subject = Subject;
    var AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
    exports.AnonymousSubject = AnonymousSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BehaviorSubject = void 0;
    var Subject_1 = require_Subject();
    var BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject_1.Subject);
    exports.BehaviorSubject = BehaviorSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dateTimestampProvider = void 0;
    exports.dateTimestampProvider = {
      now: function() {
        return (exports.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReplaySubject = void 0;
    var Subject_1 = require_Subject();
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last3 = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last3 = i;
          }
          last3 && _buffer.splice(0, last3 + 1);
        }
      };
      return ReplaySubject2;
    }(Subject_1.Subject);
    exports.ReplaySubject = ReplaySubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncSubject = void 0;
    var Subject_1 = require_Subject();
    var AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject_1.Subject);
    exports.AsyncSubject = AsyncSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Action = void 0;
    var Subscription_1 = require_Subscription();
    var Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription_1.Subscription);
    exports.Action = Action;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intervalProvider = void 0;
    exports.intervalProvider = {
      setInterval: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
      },
      clearInterval: function(handle) {
        var delegate = exports.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncAction = void 0;
    var Action_1 = require_Action();
    var intervalProvider_1 = require_intervalProvider();
    var arrRemove_1 = require_arrRemove();
    var AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && this.delay === delay && this.pending === false) {
          return id;
        }
        if (id != null) {
          intervalProvider_1.intervalProvider.clearInterval(id);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id = _a.id, scheduler = _a.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove_1.arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action_1.Action);
    exports.AsyncAction = AsyncAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestTools = exports.Immediate = void 0;
    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    function findAndClearHandle(handle) {
      if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
      }
      return false;
    }
    exports.Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
    exports.TestTools = {
      pending: function() {
        return Object.keys(activeHandles).length;
      }
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.immediateProvider = void 0;
    var Immediate_1 = require_Immediate();
    var setImmediate = Immediate_1.Immediate.setImmediate;
    var clearImmediate = Immediate_1.Immediate.clearImmediate;
    exports.immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
      },
      clearImmediate: function(handle) {
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsapAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var immediateProvider_1 = require_immediateProvider();
    var AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          immediateProvider_1.immediateProvider.clearImmediate(id);
          if (scheduler._scheduled === id) {
            scheduler._scheduled = void 0;
          }
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction_1.AsyncAction);
    exports.AsapAction = AsapAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Scheduler = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) {
          delay = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      };
      Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
      return Scheduler2;
    }();
    exports.Scheduler = Scheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncScheduler = void 0;
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler_1.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler_1.Scheduler);
    exports.AsyncScheduler = AsyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsapScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AsapScheduler = AsapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asap = exports.asapScheduler = void 0;
    var AsapAction_1 = require_AsapAction();
    var AsapScheduler_1 = require_AsapScheduler();
    exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports.asap = exports.asapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.async = exports.asyncScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports.async = exports.asyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay > 0) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && delay > 0 || delay == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.flush(this);
        return 0;
      };
      return QueueAction2;
    }(AsyncAction_1.AsyncAction);
    exports.QueueAction = QueueAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.QueueScheduler = QueueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queue = exports.queueScheduler = void 0;
    var QueueAction_1 = require_QueueAction();
    var QueueScheduler_1 = require_QueueScheduler();
    exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports.queue = exports.queueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnimationFrameAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var animationFrameProvider_1 = require_animationFrameProvider();
    var AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction_1.AsyncAction);
    exports.AnimationFrameAction = AnimationFrameAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnimationFrameScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AnimationFrameScheduler = AnimationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrame = exports.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = require_AnimationFrameAction();
    var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
    exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports.animationFrame = exports.animationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VirtualAction = exports.VirtualTimeScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var Subscription_1 = require_Subscription();
    var AsyncScheduler_1 = require_AsyncScheduler();
    var VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.VirtualTimeScheduler = VirtualTimeScheduler;
    var VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (Number.isFinite(delay)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return 1;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay);
        }
      };
      VirtualAction2.sortActions = function(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction_1.AsyncAction);
    exports.VirtualAction = VirtualAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.empty = exports.EMPTY = void 0;
    var Observable_1 = require_Observable();
    exports.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
    }
    exports.empty = empty;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isScheduler = void 0;
    var isFunction_1 = require_isFunction();
    function isScheduler(value) {
      return value && isFunction_1.isFunction(value.schedule);
    }
    exports.isScheduler = isScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/args.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.popNumber = exports.popScheduler = exports.popResultSelector = void 0;
    var isFunction_1 = require_isFunction();
    var isScheduler_1 = require_isScheduler();
    function last3(arr) {
      return arr[arr.length - 1];
    }
    function popResultSelector(args) {
      return isFunction_1.isFunction(last3(args)) ? args.pop() : void 0;
    }
    exports.popResultSelector = popResultSelector;
    function popScheduler(args) {
      return isScheduler_1.isScheduler(last3(args)) ? args.pop() : void 0;
    }
    exports.popScheduler = popScheduler;
    function popNumber(args, defaultValue) {
      return typeof last3(args) === "number" ? args.pop() : defaultValue;
    }
    exports.popNumber = popNumber;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArrayLike = void 0;
    exports.isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromise = void 0;
    var isFunction_1 = require_isFunction();
    function isPromise(value) {
      return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    exports.isPromise = isPromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInteropObservable = void 0;
    var observable_1 = require_observable();
    var isFunction_1 = require_isFunction();
    function isInteropObservable(input) {
      return isFunction_1.isFunction(input[observable_1.observable]);
    }
    exports.isInteropObservable = isInteropObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsyncIterable = void 0;
    var isFunction_1 = require_isFunction();
    function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    exports.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInvalidObservableTypeError = void 0;
    function createInvalidObservableTypeError(input) {
      return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iterator = exports.getSymbolIterator = void 0;
    function getSymbolIterator() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports.getSymbolIterator = getSymbolIterator;
    exports.iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isIterable = void 0;
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    function isIterable(input) {
      return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
    }
    exports.isIterable = isIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports) {
    "use strict";
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n]) i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = void 0;
    var isFunction_1 = require_isFunction();
    function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              reader = readableStream.getReader();
              _b.label = 1;
            case 1:
              _b.trys.push([1, , 9, 10]);
              _b.label = 2;
            case 2:
              if (false) return [3, 8];
              return [4, __await(reader.read())];
            case 3:
              _a = _b.sent(), value = _a.value, done = _a.done;
              if (!done) return [3, 5];
              return [4, __await(void 0)];
            case 4:
              return [2, _b.sent()];
            case 5:
              return [4, __await(value)];
            case 6:
              return [4, _b.sent()];
            case 7:
              _b.sent();
              return [3, 2];
            case 8:
              return [3, 10];
            case 9:
              reader.releaseLock();
              return [7];
            case 10:
              return [2];
          }
        });
      });
    }
    exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
    function isReadableStreamLike(obj) {
      return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    exports.isReadableStreamLike = isReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var Observable_1 = require_Observable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isIterable_1 = require_isIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var isFunction_1 = require_isFunction();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var observable_1 = require_observable();
    function innerFrom(input) {
      if (input instanceof Observable_1.Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return fromInteropObservable(input);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return fromArrayLike(input);
        }
        if (isPromise_1.isPromise(input)) {
          return fromPromise(input);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return fromAsyncIterable(input);
        }
        if (isIterable_1.isIterable(input)) {
          return fromIterable(input);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return fromReadableStreamLike(input);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.innerFrom = innerFrom;
    function fromInteropObservable(obj) {
      return new Observable_1.Observable(function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (isFunction_1.isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      });
    }
    exports.fromInteropObservable = fromInteropObservable;
    function fromArrayLike(array) {
      return new Observable_1.Observable(function(subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      });
    }
    exports.fromArrayLike = fromArrayLike;
    function fromPromise(promise) {
      return new Observable_1.Observable(function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, reportUnhandledError_1.reportUnhandledError);
      });
    }
    exports.fromPromise = fromPromise;
    function fromIterable(iterable) {
      return new Observable_1.Observable(function(subscriber) {
        var e_1, _a;
        try {
          for (var iterable_1 = __values2(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
            var value = iterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }
    exports.fromIterable = fromIterable;
    function fromAsyncIterable(asyncIterable) {
      return new Observable_1.Observable(function(subscriber) {
        process2(asyncIterable, subscriber).catch(function(err) {
          return subscriber.error(err);
        });
      });
    }
    exports.fromAsyncIterable = fromAsyncIterable;
    function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
    }
    exports.fromReadableStreamLike = fromReadableStreamLike;
    function process2(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a;
      return __awaiter(this, void 0, void 0, function() {
        var value, e_2_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 5, 6, 11]);
              asyncIterable_1 = __asyncValues(asyncIterable);
              _b.label = 1;
            case 1:
              return [4, asyncIterable_1.next()];
            case 2:
              if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
              value = asyncIterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return [2];
              }
              _b.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [3, 11];
            case 5:
              e_2_1 = _b.sent();
              e_2 = { error: e_2_1 };
              return [3, 11];
            case 6:
              _b.trys.push([6, , 9, 10]);
              if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
              return [4, _a.call(asyncIterable_1)];
            case 7:
              _b.sent();
              _b.label = 8;
            case 8:
              return [3, 10];
            case 9:
              if (e_2) throw e_2.error;
              return [7];
            case 10:
              return [7];
            case 11:
              subscriber.complete();
              return [2];
          }
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeSchedule = void 0;
    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
      if (delay === void 0) {
        delay = 0;
      }
      if (repeat === void 0) {
        repeat = false;
      }
      var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat) {
          parentSubscription.add(this.schedule(null, delay));
        } else {
          this.unsubscribe();
        }
      }, delay);
      parentSubscription.add(scheduleSubscription);
      if (!repeat) {
        return scheduleSubscription;
      }
    }
    exports.executeSchedule = executeSchedule;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observeOn = void 0;
    var executeSchedule_1 = require_executeSchedule();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function observeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.next(value);
          }, delay);
        }, function() {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.complete();
          }, delay);
        }, function(err) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.error(err);
          }, delay);
        }));
      });
    }
    exports.observeOn = observeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subscribeOn = void 0;
    var lift_1 = require_lift();
    function subscribeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
          return source.subscribe(subscriber);
        }, delay));
      });
    }
    exports.subscribeOn = subscribeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleObservable = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function scheduleObservable(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.scheduleObservable = scheduleObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schedulePromise = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function schedulePromise(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.schedulePromise = schedulePromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleArray = void 0;
    var Observable_1 = require_Observable();
    function scheduleArray(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
          if (i === input.length) {
            subscriber.complete();
          } else {
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
              this.schedule();
            }
          }
        });
      });
    }
    exports.scheduleArray = scheduleArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleIterable = void 0;
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleIterable(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var iterator;
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator = input[iterator_1.iterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var _a;
            var value;
            var done;
            try {
              _a = iterator.next(), value = _a.value, done = _a.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
            }
          }, 0, true);
        });
        return function() {
          return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
      });
    }
    exports.scheduleIterable = scheduleIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleAsyncIterable = void 0;
    var Observable_1 = require_Observable();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleAsyncIterable(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var iterator = input[Symbol.asyncIterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator.next().then(function(result) {
              if (result.done) {
                subscriber.complete();
              } else {
                subscriber.next(result.value);
              }
            });
          }, 0, true);
        });
      });
    }
    exports.scheduleAsyncIterable = scheduleAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleReadableStreamLike = void 0;
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    function scheduleReadableStreamLike(input, scheduler) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduled = void 0;
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
    function scheduled(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        }
        if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable_1.isIterable(input)) {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.scheduled = scheduled;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.from = void 0;
    var scheduled_1 = require_scheduled();
    var innerFrom_1 = require_innerFrom();
    function from(input, scheduler) {
      return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
    }
    exports.from = from;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.of = void 0;
    var args_1 = require_args();
    var from_1 = require_from();
    function of() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return from_1.from(args, scheduler);
    }
    exports.of = of;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwError = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function throwError(errorOrErrorFactory, scheduler) {
      var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
      };
      var init = function(subscriber) {
        return subscriber.error(errorFactory());
      };
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        return scheduler.schedule(init, 0, subscriber);
      } : init);
    }
    exports.throwError = throwError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Notification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
    var empty_1 = require_empty();
    var of_1 = require_of();
    var throwError_1 = require_throwError();
    var isFunction_1 = require_isFunction();
    var NotificationKind;
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
    var Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
    exports.Notification = Notification;
    function observeNotification(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports.observeNotification = observeNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObservable = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function isObservable(obj) {
      return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
    }
    exports.isObservable = isObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptyError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lastValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    function lastValueFrom(source, config) {
      var hasConfig = typeof config === "object";
      return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
          next: function(value) {
            _value = value;
            _hasValue = true;
          },
          error: reject,
          complete: function() {
            if (_hasValue) {
              resolve(_value);
            } else if (hasConfig) {
              resolve(config.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
      });
    }
    exports.lastValueFrom = lastValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.firstValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    var Subscriber_1 = require_Subscriber();
    function firstValueFrom(source, config) {
      var hasConfig = typeof config === "object";
      return new Promise(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            resolve(value);
            subscriber.unsubscribe();
          },
          error: reject,
          complete: function() {
            if (hasConfig) {
              resolve(config.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
        source.subscribe(subscriber);
      });
    }
    exports.firstValueFrom = firstValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArgumentOutOfRangeError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotFoundError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SequenceError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidDate = void 0;
    function isValidDate(value) {
      return value instanceof Date && !isNaN(value);
    }
    exports.isValidDate = isValidDate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeout = exports.TimeoutError = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var createErrorClass_1 = require_createErrorClass();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info3) {
        if (info3 === void 0) {
          info3 = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info3;
      };
    });
    function timeout(config, schedulerArg) {
      var _a = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first3 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first3 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first3 != null ? typeof first3 === "number" ? first3 : +first3 - scheduler.now() : each);
      });
    }
    exports.timeout = timeout;
    function timeoutErrorFactory(info3) {
      throw new exports.TimeoutError(info3);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map3 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.map = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function map2(project, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(project.call(thisArg, value, index++));
        }));
      });
    }
    exports.map = map2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapOneOrManyArgs = void 0;
    var map_1 = require_map3();
    var isArray = Array.isArray;
    function callOrApply(fn, args) {
      return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
      return map_1.map(function(args) {
        return callOrApply(fn, args);
      });
    }
    exports.mapOneOrManyArgs = mapOneOrManyArgs;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindCallbackInternals = void 0;
    var isScheduler_1 = require_isScheduler();
    var Observable_1 = require_Observable();
    var subscribeOn_1 = require_subscribeOn();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var observeOn_1 = require_observeOn();
    var AsyncSubject_1 = require_AsyncSubject();
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
          };
        }
      }
      if (scheduler) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
        };
      }
      return function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var subject = new AsyncSubject_1.AsyncSubject();
        var uninitialized = true;
        return new Observable_1.Observable(function(subscriber) {
          var subs = subject.subscribe(subscriber);
          if (uninitialized) {
            uninitialized = false;
            var isAsync_1 = false;
            var isComplete_1 = false;
            callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
              function() {
                var results = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  results[_i2] = arguments[_i2];
                }
                if (isNodeStyle) {
                  var err = results.shift();
                  if (err != null) {
                    subject.error(err);
                    return;
                  }
                }
                subject.next(1 < results.length ? results : results[0]);
                isComplete_1 = true;
                if (isAsync_1) {
                  subject.complete();
                }
              }
            ]));
            if (isComplete_1) {
              subject.complete();
            }
            isAsync_1 = true;
          }
          return subs;
        });
      };
    }
    exports.bindCallbackInternals = bindCallbackInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }
    exports.bindCallback = bindCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindNodeCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }
    exports.bindNodeCallback = bindNodeCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsArgArrayOrObject = void 0;
    var isArray = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectProto = Object.prototype;
    var getKeys = Object.keys;
    function argsArgArrayOrObject(args) {
      if (args.length === 1) {
        var first_1 = args[0];
        if (isArray(first_1)) {
          return { args: first_1, keys: null };
        }
        if (isPOJO(first_1)) {
          var keys2 = getKeys(first_1);
          return {
            args: keys2.map(function(key) {
              return first_1[key];
            }),
            keys: keys2
          };
        }
      }
      return { args, keys: null };
    }
    exports.argsArgArrayOrObject = argsArgArrayOrObject;
    function isPOJO(obj) {
      return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createObject = void 0;
    function createObject(keys2, values2) {
      return keys2.reduce(function(result, key, i) {
        return result[key] = values2[i], result;
      }, {});
    }
    exports.createObject = createObject;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestInit = exports.combineLatest = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var from_1 = require_from();
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var args_1 = require_args();
    var createObject_1 = require_createObject();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys2 = _a.keys;
      if (observables.length === 0) {
        return from_1.from([], scheduler);
      }
      var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys2 ? function(values2) {
        return createObject_1.createObject(keys2, values2);
      } : identity_1.identity));
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports.combineLatest = combineLatest;
    function combineLatestInit(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) {
        valueTransform = identity_1.identity;
      }
      return function(subscriber) {
        maybeSchedule(scheduler, function() {
          var length = observables.length;
          var values2 = new Array(length);
          var active = length;
          var remainingFirstValues = length;
          var _loop_1 = function(i2) {
            maybeSchedule(scheduler, function() {
              var source = from_1.from(observables[i2], scheduler);
              var hasFirstValue = false;
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                values2[i2] = value;
                if (!hasFirstValue) {
                  hasFirstValue = true;
                  remainingFirstValues--;
                }
                if (!remainingFirstValues) {
                  subscriber.next(valueTransform(values2.slice()));
                }
              }, function() {
                if (!--active) {
                  subscriber.complete();
                }
              }));
            }, subscriber);
          };
          for (var i = 0; i < length; i++) {
            _loop_1(i);
          }
        }, subscriber);
      };
    }
    exports.combineLatestInit = combineLatestInit;
    function maybeSchedule(scheduler, execute, subscription) {
      if (scheduler) {
        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
      } else {
        execute();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeInternals = void 0;
    var innerFrom_1 = require_innerFrom();
    var executeSchedule_1 = require_executeSchedule();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
      var buffer = [];
      var active = 0;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        if (isComplete && !buffer.length && !active) {
          subscriber.complete();
        }
      };
      var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
      };
      var doInnerSub = function(value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
          if (expand) {
            outerNext(innerValue);
          } else {
            subscriber.next(innerValue);
          }
        }, function() {
          innerComplete = true;
        }, void 0, function() {
          if (innerComplete) {
            try {
              active--;
              var _loop_1 = function() {
                var bufferedValue = buffer.shift();
                if (innerSubScheduler) {
                  executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                    return doInnerSub(bufferedValue);
                  });
                } else {
                  doInnerSub(bufferedValue);
                }
              };
              while (buffer.length && active < concurrent) {
                _loop_1();
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }));
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
      }));
      return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
      };
    }
    exports.mergeInternals = mergeInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMap = void 0;
    var map_1 = require_map3();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    var isFunction_1 = require_isFunction();
    function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap(function(a, i) {
          return map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          })(innerFrom_1.innerFrom(project(a, i)));
        }, concurrent);
      } else if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
      });
    }
    exports.mergeMap = mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeAll = void 0;
    var mergeMap_1 = require_mergeMap();
    var identity_1 = require_identity();
    function mergeAll(concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }
    exports.mergeAll = mergeAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatAll = void 0;
    var mergeAll_1 = require_mergeAll();
    function concatAll() {
      return mergeAll_1.mergeAll(1);
    }
    exports.concatAll = concatAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
    }
    exports.concat = concat2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defer = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    function defer(observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
      });
    }
    exports.defer = defer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connectable = void 0;
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var defer_1 = require_defer();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      },
      resetOnDisconnect: true
    };
    function connectable(source, config) {
      if (config === void 0) {
        config = DEFAULT_CONFIG;
      }
      var connection = null;
      var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
      var subject = connector();
      var result = new Observable_1.Observable(function(subscriber) {
        return subject.subscribe(subscriber);
      });
      result.connect = function() {
        if (!connection || connection.closed) {
          connection = defer_1.defer(function() {
            return source;
          }).subscribe(subject);
          if (resetOnDisconnect) {
            connection.add(function() {
              return subject = connector();
            });
          }
        }
        return connection;
      };
      return result;
    }
    exports.connectable = connectable;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forkJoin = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var innerFrom_1 = require_innerFrom();
    var args_1 = require_args();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var createObject_1 = require_createObject();
    function forkJoin() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys2 = _a.keys;
      var result = new Observable_1.Observable(function(subscriber) {
        var length = sources.length;
        if (!length) {
          subscriber.complete();
          return;
        }
        var values2 = new Array(length);
        var remainingCompletions = length;
        var remainingEmissions = length;
        var _loop_1 = function(sourceIndex2) {
          var hasValue = false;
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!hasValue) {
              hasValue = true;
              remainingEmissions--;
            }
            values2[sourceIndex2] = value;
          }, function() {
            return remainingCompletions--;
          }, void 0, function() {
            if (!remainingCompletions || !hasValue) {
              if (!remainingEmissions) {
                subscriber.next(keys2 ? createObject_1.createObject(keys2, values2) : values2);
              }
              subscriber.complete();
            }
          }));
        };
        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
      });
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports.forkJoin = forkJoin;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEvent = void 0;
    var innerFrom_1 = require_innerFrom();
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap();
    var isArrayLike_1 = require_isArrayLike();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var nodeEventEmitterMethods = ["addListener", "removeListener"];
    var eventTargetMethods = ["addEventListener", "removeEventListener"];
    var jqueryMethods = ["on", "off"];
    function fromEvent(target, eventName, options, resultSelector) {
      if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = void 0;
      }
      if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove3 = _a[1];
      if (!add) {
        if (isArrayLike_1.isArrayLike(target)) {
          return mergeMap_1.mergeMap(function(subTarget) {
            return fromEvent(subTarget, eventName, options);
          })(innerFrom_1.innerFrom(target));
        }
      }
      if (!add) {
        throw new TypeError("Invalid event target");
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return subscriber.next(1 < args.length ? args : args[0]);
        };
        add(handler);
        return function() {
          return remove3(handler);
        };
      });
    }
    exports.fromEvent = fromEvent;
    function toCommonHandlerRegistry(target, eventName) {
      return function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler);
        };
      };
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEventPattern = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            e[_i] = arguments[_i];
          }
          return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue = addHandler(handler);
        return isFunction_1.isFunction(removeHandler) ? function() {
          return removeHandler(handler, retValue);
        } : void 0;
      });
    }
    exports.fromEventPattern = fromEventPattern;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports) {
    "use strict";
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = void 0;
    var identity_1 = require_identity();
    var isScheduler_1 = require_isScheduler();
    var defer_1 = require_defer();
    var scheduleIterable_1 = require_scheduleIterable();
    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
      var _a, _b;
      var resultSelector;
      var initialState;
      if (arguments.length === 1) {
        _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
      } else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
          resultSelector = identity_1.identity;
          scheduler = resultSelectorOrScheduler;
        } else {
          resultSelector = resultSelectorOrScheduler;
        }
      }
      function gen() {
        var state;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              state = initialState;
              _a2.label = 1;
            case 1:
              if (!(!condition || condition(state))) return [3, 4];
              return [4, resultSelector(state)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              state = iterate(state);
              return [3, 1];
            case 4:
              return [2];
          }
        });
      }
      return defer_1.defer(scheduler ? function() {
        return scheduleIterable_1.scheduleIterable(gen(), scheduler);
      } : gen);
    }
    exports.generate = generate;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iif = void 0;
    var defer_1 = require_defer();
    function iif(condition, trueResult, falseResult) {
      return defer_1.defer(function() {
        return condition() ? trueResult : falseResult;
      });
    }
    exports.iif = iif;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timer = void 0;
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var isScheduler_1 = require_isScheduler();
    var isDate_1 = require_isDate();
    function timer(dueTime, intervalOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable_1.Observable(function(subscriber) {
        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        var n = 0;
        return scheduler.schedule(function() {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(void 0, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }
    exports.timer = timer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = void 0;
    var async_1 = require_async();
    var timer_1 = require_timer();
    function interval(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (period < 0) {
        period = 0;
      }
      return timer_1.timer(period, period, scheduler);
    }
    exports.interval = interval;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var mergeAll_1 = require_mergeAll();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      var sources = args;
      return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
    }
    exports.merge = merge2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.never = exports.NEVER = void 0;
    var Observable_1 = require_Observable();
    var noop_1 = require_noop();
    exports.NEVER = new Observable_1.Observable(noop_1.noop);
    function never() {
      return exports.NEVER;
    }
    exports.never = never;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsOrArgArray = void 0;
    var isArray = Array.isArray;
    function argsOrArgArray(args) {
      return args.length === 1 && isArray(args[0]) ? args[0] : args;
    }
    exports.argsOrArgArray = argsOrArgArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onErrorResumeNext = void 0;
    var Observable_1 = require_Observable();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function onErrorResumeNext() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return new Observable_1.Observable(function(subscriber) {
        var sourceIndex = 0;
        var subscribeNext = function() {
          if (sourceIndex < nextSources.length) {
            var nextSource = void 0;
            try {
              nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
            } catch (err) {
              subscribeNext();
              return;
            }
            var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
            nextSource.subscribe(innerSubscriber);
            innerSubscriber.add(subscribeNext);
          } else {
            subscriber.complete();
          }
        };
        subscribeNext();
      });
    }
    exports.onErrorResumeNext = onErrorResumeNext;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pairs = void 0;
    var from_1 = require_from();
    function pairs(obj, scheduler) {
      return from_1.from(Object.entries(obj), scheduler);
    }
    exports.pairs = pairs;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.not = void 0;
    function not2(pred, thisArg) {
      return function(value, index) {
        return !pred.call(thisArg, value, index);
      };
    }
    exports.not = not2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filter = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function filter3(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
      });
    }
    exports.filter = filter3;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    var innerFrom_1 = require_innerFrom();
    function partition2(source, predicate, thisArg) {
      return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
    }
    exports.partition = partition2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.raceInit = exports.race = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function race() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      sources = argsOrArgArray_1.argsOrArgArray(sources);
      return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
    }
    exports.race = race;
    function raceInit(sources) {
      return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i2) {
          subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (subscriptions) {
              for (var s = 0; s < subscriptions.length; s++) {
                s !== i2 && subscriptions[s].unsubscribe();
              }
              subscriptions = null;
            }
            subscriber.next(value);
          })));
        };
        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
          _loop_1(i);
        }
      };
    }
    exports.raceInit = raceInit;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.range = void 0;
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    function range(start, count2, scheduler) {
      if (count2 == null) {
        count2 = start;
        start = 0;
      }
      if (count2 <= 0) {
        return empty_1.EMPTY;
      }
      var end = count2 + start;
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
          if (n < end) {
            subscriber.next(n++);
            this.schedule();
          } else {
            subscriber.complete();
          }
        });
      } : function(subscriber) {
        var n = start;
        while (n < end && !subscriber.closed) {
          subscriber.next(n++);
        }
        subscriber.complete();
      });
    }
    exports.range = range;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.using = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    function using(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        var resource = resourceFactory();
        var result = observableFactory(resource);
        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
        source.subscribe(subscriber);
        return function() {
          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }
    exports.using = using;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zip = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var empty_1 = require_empty();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var args_1 = require_args();
    function zip2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var sources = argsOrArgArray_1.argsOrArgArray(args);
      return sources.length ? new Observable_1.Observable(function(subscriber) {
        var buffers = sources.map(function() {
          return [];
        });
        var completed = sources.map(function() {
          return false;
        });
        subscriber.add(function() {
          buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex2) {
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffers[sourceIndex2].push(value);
            if (buffers.every(function(buffer) {
              return buffer.length;
            })) {
              var result = buffers.map(function(buffer) {
                return buffer.shift();
              });
              subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
              if (buffers.some(function(buffer, i) {
                return !buffer.length && completed[i];
              })) {
                subscriber.complete();
              }
            }
          }, function() {
            completed[sourceIndex2] = true;
            !buffers[sourceIndex2].length && subscriber.complete();
          }));
        };
        for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
        return function() {
          buffers = completed = null;
        };
      }) : empty_1.EMPTY;
    }
    exports.zip = zip2;
  }
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.audit = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function audit(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
          isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
          durationSubscriber = null;
          isComplete && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
          if (!durationSubscriber) {
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
          }
        }, function() {
          isComplete = true;
          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
      });
    }
    exports.audit = audit;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auditTime = void 0;
    var async_1 = require_async();
    var audit_1 = require_audit();
    var timer_1 = require_timer();
    function auditTime(duration, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return audit_1.audit(function() {
        return timer_1.timer(duration, scheduler);
      });
    }
    exports.auditTime = auditTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buffer = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function buffer(closingNotifier) {
      return lift_1.operate(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return currentBuffer.push(value);
        }, function() {
          subscriber.next(currentBuffer);
          subscriber.complete();
        }));
        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          var b = currentBuffer;
          currentBuffer = [];
          subscriber.next(b);
        }, noop_1.noop));
        return function() {
          currentBuffer = null;
        };
      });
    }
    exports.buffer = buffer;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports) {
    "use strict";
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    function bufferCount(bufferSize, startBufferEvery) {
      if (startBufferEvery === void 0) {
        startBufferEvery = null;
      }
      startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        var count2 = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a, e_2, _b;
          var toEmit = null;
          if (count2++ % startBufferEvery === 0) {
            buffers.push([]);
          }
          try {
            for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
              if (bufferSize <= buffer.length) {
                toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                toEmit.push(buffer);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (toEmit) {
            try {
              for (var toEmit_1 = __values2(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                var buffer = toEmit_1_1.value;
                arrRemove_1.arrRemove(buffers, buffer);
                subscriber.next(buffer);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          }
        }, function() {
          var e_3, _a;
          try {
            for (var buffers_2 = __values2(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
              var buffer = buffers_2_1.value;
              subscriber.next(buffer);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffers = null;
        }));
      });
    }
    exports.bufferCount = bufferCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports) {
    "use strict";
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferTime = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var async_1 = require_async();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function bufferTime(bufferTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxBufferSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
          var buffer = record.buffer, subs = record.subs;
          subs.unsubscribe();
          arrRemove_1.arrRemove(bufferRecords, record);
          subscriber.next(buffer);
          restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
          if (bufferRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var buffer = [];
            var record_1 = {
              buffer,
              subs
            };
            bufferRecords.push(record_1);
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return emit(record_1);
            }, bufferTimeSpan);
          }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        } else {
          restartOnEmit = true;
        }
        startBuffer();
        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          var recordsCopy = bufferRecords.slice();
          try {
            for (var recordsCopy_1 = __values2(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
              var record = recordsCopy_1_1.value;
              var buffer = record.buffer;
              buffer.push(value);
              maxBufferSize <= buffer.length && emit(record);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return)) _a2.call(recordsCopy_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
            subscriber.next(bufferRecords.shift().buffer);
          }
          bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
          subscriber.complete();
          subscriber.unsubscribe();
        }, void 0, function() {
          return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
      });
    }
    exports.bufferTime = bufferTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports) {
    "use strict";
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferToggle = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function bufferToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var buffer = [];
          buffers.push(buffer);
          var closingSubscription = new Subscription_1.Subscription();
          var emitBuffer = function() {
            arrRemove_1.arrRemove(buffers, buffer);
            subscriber.next(buffer);
            closingSubscription.unsubscribe();
          };
          closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (buffers.length > 0) {
            subscriber.next(buffers.shift());
          }
          subscriber.complete();
        }));
      });
    }
    exports.bufferToggle = bufferToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferWhen = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function bufferWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffer = null;
        var closingSubscriber = null;
        var openBuffer = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          var b = buffer;
          buffer = [];
          b && subscriber.next(b);
          innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
        };
        openBuffer();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
        }, function() {
          buffer && subscriber.next(buffer);
          subscriber.complete();
        }, void 0, function() {
          return buffer = closingSubscriber = null;
        }));
      });
    }
    exports.bufferWhen = bufferWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.catchError = void 0;
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    function catchError(selector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
          if (innerSub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          } else {
            syncUnsub = true;
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        }
      });
    }
    exports.catchError = catchError;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scanInternals = void 0;
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
      return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          state = hasState ? accumulator(state, value, i) : (hasState = true, value);
          emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
          hasState && subscriber.next(state);
          subscriber.complete();
        }));
      };
    }
    exports.scanInternals = scanInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reduce = void 0;
    var scanInternals_1 = require_scanInternals();
    var lift_1 = require_lift();
    function reduce2(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }
    exports.reduce = reduce2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toArray = void 0;
    var reduce_1 = require_reduce();
    var lift_1 = require_lift();
    var arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
    function toArray2() {
      return lift_1.operate(function(source, subscriber) {
        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
      });
    }
    exports.toArray = toArray2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinAllInternals = void 0;
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var mergeMap_1 = require_mergeMap();
    var toArray_1 = require_toArray();
    function joinAllInternals(joinFn, project) {
      return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
        return joinFn(sources);
      }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
    }
    exports.joinAllInternals = joinAllInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestAll = void 0;
    var combineLatest_1 = require_combineLatest();
    var joinAllInternals_1 = require_joinAllInternals();
    function combineLatestAll(project) {
      return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
    }
    exports.combineLatestAll = combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineAll = void 0;
    var combineLatestAll_1 = require_combineLatestAll();
    exports.combineAll = combineLatestAll_1.combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatest = void 0;
    var combineLatest_1 = require_combineLatest();
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var args_1 = require_args();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
        combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
      });
    }
    exports.combineLatest = combineLatest;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestWith = void 0;
    var combineLatest_1 = require_combineLatest2();
    function combineLatestWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports.combineLatestWith = combineLatestWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function concatMap(project, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
    }
    exports.concatMap = concatMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatMapTo = void 0;
    var concatMap_1 = require_concatMap();
    var isFunction_1 = require_isFunction();
    function concatMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
        return innerObservable;
      }, resultSelector) : concatMap_1.concatMap(function() {
        return innerObservable;
      });
    }
    exports.concatMapTo = concatMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var lift_1 = require_lift();
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return lift_1.operate(function(source, subscriber) {
        concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.concat = concat2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatWith = void 0;
    var concat_1 = require_concat2();
    function concatWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return concat_1.concat.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports.concatWith = concatWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromSubscribable = void 0;
    var Observable_1 = require_Observable();
    function fromSubscribable(subscribable) {
      return new Observable_1.Observable(function(subscriber) {
        return subscribable.subscribe(subscriber);
      });
    }
    exports.fromSubscribable = fromSubscribable;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connect = void 0;
    var Subject_1 = require_Subject();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var fromSubscribable_1 = require_fromSubscribable();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      }
    };
    function connect(selector, config) {
      if (config === void 0) {
        config = DEFAULT_CONFIG;
      }
      var connector = config.connector;
      return lift_1.operate(function(source, subscriber) {
        var subject = connector();
        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
      });
    }
    exports.connect = connect;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.count = void 0;
    var reduce_1 = require_reduce();
    function count2(predicate) {
      return reduce_1.reduce(function(total, value, i) {
        return !predicate || predicate(value, i) ? total + 1 : total;
      }, 0);
    }
    exports.count = count2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debounce = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function debounce(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          hasValue = true;
          lastValue = value;
          durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = durationSubscriber = null;
        }));
      });
    }
    exports.debounce = debounce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debounceTime = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function debounceTime(dueTime, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
          if (activeTask) {
            activeTask.unsubscribe();
            activeTask = null;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        function emitWhenIdle() {
          var targetTime = lastTime + dueTime;
          var now = scheduler.now();
          if (now < targetTime) {
            activeTask = this.schedule(void 0, targetTime - now);
            subscriber.add(activeTask);
            return;
          }
          emit();
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          lastValue = value;
          lastTime = scheduler.now();
          if (!activeTask) {
            activeTask = scheduler.schedule(emitWhenIdle, dueTime);
            subscriber.add(activeTask);
          }
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = activeTask = null;
        }));
      });
    }
    exports.debounceTime = debounceTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultIfEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function defaultIfEmpty(defaultValue) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          if (!hasValue) {
            subscriber.next(defaultValue);
          }
          subscriber.complete();
        }));
      });
    }
    exports.defaultIfEmpty = defaultIfEmpty;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.take = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function take2(count2) {
      return count2 <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (++seen <= count2) {
            subscriber.next(value);
            if (count2 <= seen) {
              subscriber.complete();
            }
          }
        }));
      });
    }
    exports.take = take2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ignoreElements = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function ignoreElements() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
      });
    }
    exports.ignoreElements = ignoreElements;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapTo = void 0;
    var map_1 = require_map3();
    function mapTo(value) {
      return map_1.map(function() {
        return value;
      });
    }
    exports.mapTo = mapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delayWhen = void 0;
    var concat_1 = require_concat();
    var take_1 = require_take();
    var ignoreElements_1 = require_ignoreElements();
    var mapTo_1 = require_mapTo();
    var mergeMap_1 = require_mergeMap();
    var innerFrom_1 = require_innerFrom();
    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function(source) {
          return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
        };
      }
      return mergeMap_1.mergeMap(function(value, index) {
        return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
      });
    }
    exports.delayWhen = delayWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    var async_1 = require_async();
    var delayWhen_1 = require_delayWhen();
    var timer_1 = require_timer();
    function delay(due, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration = timer_1.timer(due, scheduler);
      return delayWhen_1.delayWhen(function() {
        return duration;
      });
    }
    exports.delay = delay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dematerialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function dematerialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
          return Notification_1.observeNotification(notification, subscriber);
        }));
      });
    }
    exports.dematerialize = dematerialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinct = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function distinct(keySelector, flushes) {
      return lift_1.operate(function(source, subscriber) {
        var distinctKeys = /* @__PURE__ */ new Set();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var key = keySelector ? keySelector(value) : value;
          if (!distinctKeys.has(key)) {
            distinctKeys.add(key);
            subscriber.next(value);
          }
        }));
        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return distinctKeys.clear();
        }, noop_1.noop));
      });
    }
    exports.distinct = distinct;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinctUntilChanged = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function distinctUntilChanged(comparator, keySelector) {
      if (keySelector === void 0) {
        keySelector = identity_1.identity;
      }
      comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
      return lift_1.operate(function(source, subscriber) {
        var previousKey;
        var first3 = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var currentKey = keySelector(value);
          if (first3 || !comparator(previousKey, currentKey)) {
            first3 = false;
            previousKey = currentKey;
            subscriber.next(value);
          }
        }));
      });
    }
    exports.distinctUntilChanged = distinctUntilChanged;
    function defaultCompare(a, b) {
      return a === b;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinctUntilKeyChanged = void 0;
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
      });
    }
    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwIfEmpty = void 0;
    var EmptyError_1 = require_EmptyError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function throwIfEmpty(errorFactory) {
      if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
      }
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
      });
    }
    exports.throwIfEmpty = throwIfEmpty;
    function defaultErrorFactory() {
      return new EmptyError_1.EmptyError();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.elementAt = void 0;
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var filter_1 = require_filter();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var take_1 = require_take();
    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(filter_1.filter(function(v, i) {
          return i === index;
        }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }));
      };
    }
    exports.elementAt = elementAt;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endWith = void 0;
    var concat_1 = require_concat();
    var of_1 = require_of();
    function endWith() {
      var values2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values2[_i] = arguments[_i];
      }
      return function(source) {
        return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray([], __read(values2))));
      };
    }
    exports.endWith = endWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.every = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function every2(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!predicate.call(thisArg, value, index++, source)) {
            subscriber.next(false);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.every = every2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaustMap = void 0;
    var map_1 = require_map3();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return function(source) {
          return source.pipe(exhaustMap(function(a, i) {
            return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
          if (!innerSub) {
            innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              innerSub = null;
              isComplete && subscriber.complete();
            });
            innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
          }
        }, function() {
          isComplete = true;
          !innerSub && subscriber.complete();
        }));
      });
    }
    exports.exhaustMap = exhaustMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaustAll = void 0;
    var exhaustMap_1 = require_exhaustMap();
    var identity_1 = require_identity();
    function exhaustAll() {
      return exhaustMap_1.exhaustMap(identity_1.identity);
    }
    exports.exhaustAll = exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaust = void 0;
    var exhaustAll_1 = require_exhaustAll();
    exports.exhaust = exhaustAll_1.exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function expand(project, concurrent, scheduler) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
      });
    }
    exports.expand = expand;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.finalize = void 0;
    var lift_1 = require_lift();
    function finalize(callback) {
      return lift_1.operate(function(source, subscriber) {
        try {
          source.subscribe(subscriber);
        } finally {
          subscriber.add(callback);
        }
      });
    }
    exports.finalize = finalize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFind = exports.find = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function find2(predicate, thisArg) {
      return lift_1.operate(createFind(predicate, thisArg, "value"));
    }
    exports.find = find2;
    function createFind(predicate, thisArg, emit) {
      var findIndex2 = emit === "index";
      return function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          if (predicate.call(thisArg, value, i, source)) {
            subscriber.next(findIndex2 ? i : value);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(findIndex2 ? -1 : void 0);
          subscriber.complete();
        }));
      };
    }
    exports.createFind = createFind;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findIndex = void 0;
    var lift_1 = require_lift();
    var find_1 = require_find();
    function findIndex2(predicate, thisArg) {
      return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
    }
    exports.findIndex = findIndex2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.first = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var take_1 = require_take();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var identity_1 = require_identity();
    function first3(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.first = first3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupBy = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function groupBy2(keySelector, elementOrOptions, duration, connector) {
      return lift_1.operate(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") {
          element = elementOrOptions;
        } else {
          duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        }
        var groups = /* @__PURE__ */ new Map();
        var notify = function(cb) {
          groups.forEach(cb);
          cb(subscriber);
        };
        var handleError = function(err) {
          return notify(function(consumer) {
            return consumer.error(err);
          });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
          try {
            var key_1 = keySelector(value);
            var group_1 = groups.get(key_1);
            if (!group_1) {
              groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
              var grouped = createGroupedObservable(key_1, group_1);
              subscriber.next(grouped);
              if (duration) {
                var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                  group_1.complete();
                  durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                }, void 0, void 0, function() {
                  return groups.delete(key_1);
                });
                groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
              }
            }
            group_1.next(element ? element(value) : value);
          } catch (err) {
            handleError(err);
          }
        }, function() {
          return notify(function(consumer) {
            return consumer.complete();
          });
        }, handleError, function() {
          return groups.clear();
        }, function() {
          teardownAttempted = true;
          return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
          var result = new Observable_1.Observable(function(groupSubscriber) {
            activeGroups++;
            var innerSub = groupSubject.subscribe(groupSubscriber);
            return function() {
              innerSub.unsubscribe();
              --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
            };
          });
          result.key = key;
          return result;
        }
      });
    }
    exports.groupBy = groupBy2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function isEmpty2() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          subscriber.next(false);
          subscriber.complete();
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.isEmpty = isEmpty2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports) {
    "use strict";
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeLast = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeLast2(count2) {
      return count2 <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var buffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffer.push(value);
          count2 < buffer.length && buffer.shift();
        }, function() {
          var e_1, _a;
          try {
            for (var buffer_1 = __values2(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
              var value = buffer_1_1.value;
              subscriber.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffer = null;
        }));
      });
    }
    exports.takeLast = takeLast2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.last = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var takeLast_1 = require_takeLast();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var identity_1 = require_identity();
    function last3(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.last = last3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.materialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function materialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(Notification_1.Notification.createNext(value));
        }, function() {
          subscriber.next(Notification_1.Notification.createComplete());
          subscriber.complete();
        }, function(err) {
          subscriber.next(Notification_1.Notification.createError(err));
          subscriber.complete();
        }));
      });
    }
    exports.materialize = materialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.max = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function max2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) > 0 ? x : y;
      } : function(x, y) {
        return x > y ? x : y;
      });
    }
    exports.max = max2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    exports.flatMap = mergeMap_1.mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMapTo = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, resultSelector, concurrent);
      }
      if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, concurrent);
    }
    exports.mergeMapTo = mergeMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeScan = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function mergeScan(accumulator, seed, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
          return accumulator(state, value, index);
        }, concurrent, function(value) {
          state = value;
        }, false, void 0, function() {
          return state = null;
        });
      });
    }
    exports.mergeScan = mergeScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mergeAll_1 = require_mergeAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      args = argsOrArgArray_1.argsOrArgArray(args);
      return lift_1.operate(function(source, subscriber) {
        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.merge = merge2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeWith = void 0;
    var merge_1 = require_merge2();
    function mergeWith2() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return merge_1.merge.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports.mergeWith = mergeWith2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.min = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function min2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) < 0 ? x : y;
      } : function(x, y) {
        return x < y ? x : y;
      });
    }
    exports.min = min2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multicast = void 0;
    var ConnectableObservable_1 = require_ConnectableObservable();
    var isFunction_1 = require_isFunction();
    var connect_1 = require_connect();
    function multicast(subjectOrSubjectFactory, selector) {
      var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
      };
      if (isFunction_1.isFunction(selector)) {
        return connect_1.connect(selector, {
          connector: subjectFactory
        });
      }
      return function(source) {
        return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
      };
    }
    exports.multicast = multicast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onErrorResumeNext = exports.onErrorResumeNextWith = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    function onErrorResumeNextWith() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return function(source) {
        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources)));
      };
    }
    exports.onErrorResumeNextWith = onErrorResumeNextWith;
    exports.onErrorResumeNext = onErrorResumeNextWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pairwise = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function pairwise() {
      return lift_1.operate(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var p = prev;
          prev = value;
          hasPrev && subscriber.next([p, value]);
          hasPrev = true;
        }));
      });
    }
    exports.pairwise = pairwise;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pluck = void 0;
    var map_1 = require_map3();
    function pluck() {
      var properties = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
      }
      var length = properties.length;
      if (length === 0) {
        throw new Error("list of properties cannot be empty.");
      }
      return map_1.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
          var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
          if (typeof p !== "undefined") {
            currentProp = p;
          } else {
            return void 0;
          }
        }
        return currentProp;
      });
    }
    exports.pluck = pluck;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publish = void 0;
    var Subject_1 = require_Subject();
    var multicast_1 = require_multicast();
    var connect_1 = require_connect();
    function publish(selector) {
      return selector ? function(source) {
        return connect_1.connect(selector)(source);
      } : function(source) {
        return multicast_1.multicast(new Subject_1.Subject())(source);
      };
    }
    exports.publish = publish;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishBehavior = void 0;
    var BehaviorSubject_1 = require_BehaviorSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishBehavior(initialValue) {
      return function(source) {
        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishBehavior = publishBehavior;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishLast = void 0;
    var AsyncSubject_1 = require_AsyncSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishLast() {
      return function(source) {
        var subject = new AsyncSubject_1.AsyncSubject();
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishLast = publishLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var multicast_1 = require_multicast();
    var isFunction_1 = require_isFunction();
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
      if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
        timestampProvider = selectorOrScheduler;
      }
      var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
      return function(source) {
        return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
      };
    }
    exports.publishReplay = publishReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.raceWith = void 0;
    var race_1 = require_race();
    var lift_1 = require_lift();
    var identity_1 = require_identity();
    function raceWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
      });
    }
    exports.raceWith = raceWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.repeat = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var timer_1 = require_timer();
    function repeat(countOrConfig) {
      var _a;
      var count2 = Infinity;
      var delay;
      if (countOrConfig != null) {
        if (typeof countOrConfig === "object") {
          _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
        } else {
          count2 = countOrConfig;
        }
      }
      return count2 <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
          sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
          sourceSub = null;
          if (delay != null) {
            var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              subscribeToSource();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            subscribeToSource();
          }
        };
        var subscribeToSource = function() {
          var syncUnsub = false;
          sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            if (++soFar < count2) {
              if (sourceSub) {
                resubscribe();
              } else {
                syncUnsub = true;
              }
            } else {
              subscriber.complete();
            }
          }));
          if (syncUnsub) {
            resubscribe();
          }
        };
        subscribeToSource();
      });
    }
    exports.repeat = repeat;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.repeatWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function repeatWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
          return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
          if (!completions$) {
            completions$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              if (innerSub) {
                subscribeForRepeatWhen();
              } else {
                syncResub = true;
              }
            }, function() {
              isNotifierComplete = true;
              checkComplete();
            }));
          }
          return completions$;
        };
        var subscribeForRepeatWhen = function() {
          isMainComplete = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            isMainComplete = true;
            !checkComplete() && getCompletionSubject().next();
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRepeatWhen();
          }
        };
        subscribeForRepeatWhen();
      });
    }
    exports.repeatWhen = repeatWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retry = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    var timer_1 = require_timer();
    var innerFrom_1 = require_innerFrom();
    function retry(configOrCount) {
      if (configOrCount === void 0) {
        configOrCount = Infinity;
      }
      var config;
      if (configOrCount && typeof configOrCount === "object") {
        config = configOrCount;
      } else {
        config = {
          count: configOrCount
        };
      }
      var _a = config.count, count2 = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
      return count2 <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
          var syncUnsub = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (resetOnSuccess) {
              soFar = 0;
            }
            subscriber.next(value);
          }, void 0, function(err) {
            if (soFar++ < count2) {
              var resub_1 = function() {
                if (innerSub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  subscribeForRetry();
                } else {
                  syncUnsub = true;
                }
              };
              if (delay != null) {
                var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
                var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  notifierSubscriber_1.unsubscribe();
                  resub_1();
                }, function() {
                  subscriber.complete();
                });
                notifier.subscribe(notifierSubscriber_1);
              } else {
                resub_1();
              }
            } else {
              subscriber.error(err);
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            subscribeForRetry();
          }
        };
        subscribeForRetry();
      });
    }
    exports.retry = retry;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function retryWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            if (!errors$) {
              errors$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                return innerSub ? subscribeForRetryWhen() : syncResub = true;
              }));
            }
            if (errors$) {
              errors$.next(err);
            }
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRetryWhen();
          }
        };
        subscribeForRetryWhen();
      });
    }
    exports.retryWhen = retryWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sample = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sample(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
        }));
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        }, noop_1.noop));
      });
    }
    exports.sample = sample;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sampleTime = void 0;
    var async_1 = require_async();
    var sample_1 = require_sample();
    var interval_1 = require_interval();
    function sampleTime(period, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return sample_1.sample(interval_1.interval(period, scheduler));
    }
    exports.sampleTime = sampleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scan = void 0;
    var lift_1 = require_lift();
    var scanInternals_1 = require_scanInternals();
    function scan(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
    }
    exports.scan = scan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceEqual = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function sequenceEqual(compareTo, comparator) {
      if (comparator === void 0) {
        comparator = function(a, b) {
          return a === b;
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var aState = createState();
        var bState = createState();
        var emit = function(isEqual) {
          subscriber.next(isEqual);
          subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
          var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
            var buffer = otherState.buffer, complete = otherState.complete;
            if (buffer.length === 0) {
              complete ? emit(false) : selfState.buffer.push(a);
            } else {
              !comparator(a, buffer.shift()) && emit(false);
            }
          }, function() {
            selfState.complete = true;
            var complete = otherState.complete, buffer = otherState.buffer;
            complete && emit(buffer.length === 0);
            sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
          });
          return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
      });
    }
    exports.sequenceEqual = sequenceEqual;
    function createState() {
      return {
        buffer: [],
        complete: false
      };
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.share = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var Subscriber_1 = require_Subscriber();
    var lift_1 = require_lift();
    function share(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.connector, connector = _a === void 0 ? function() {
        return new Subject_1.Subject();
      } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
      return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
          resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
          resetConnection = void 0;
        };
        var reset = function() {
          cancelReset();
          connection = subject = void 0;
          hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
          var conn = connection;
          reset();
          conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return lift_1.operate(function(source, subscriber) {
          refCount++;
          if (!hasErrored && !hasCompleted) {
            cancelReset();
          }
          var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
          subscriber.add(function() {
            refCount--;
            if (refCount === 0 && !hasErrored && !hasCompleted) {
              resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
            }
          });
          dest.subscribe(subscriber);
          if (!connection && refCount > 0) {
            connection = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                return dest.next(value);
              },
              error: function(err) {
                hasErrored = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnError, err);
                dest.error(err);
              },
              complete: function() {
                hasCompleted = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnComplete);
                dest.complete();
              }
            });
            innerFrom_1.innerFrom(source).subscribe(connection);
          }
        })(wrapperSource);
      };
    }
    exports.share = share;
    function handleReset(reset, on) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (on === true) {
        reset();
        return;
      }
      if (on === false) {
        return;
      }
      var onSubscriber = new Subscriber_1.SafeSubscriber({
        next: function() {
          onSubscriber.unsubscribe();
          reset();
        }
      });
      return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shareReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var share_1 = require_share();
    function shareReplay(configOrBufferSize, windowTime, scheduler) {
      var _a, _b, _c;
      var bufferSize;
      var refCount = false;
      if (configOrBufferSize && typeof configOrBufferSize === "object") {
        _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
      } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
      }
      return share_1.share({
        connector: function() {
          return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount
      });
    }
    exports.shareReplay = shareReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.single = void 0;
    var EmptyError_1 = require_EmptyError();
    var SequenceError_1 = require_SequenceError();
    var NotFoundError_1 = require_NotFoundError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function single(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          seenValue = true;
          if (!predicate || predicate(value, index++, source)) {
            hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
            hasValue = true;
            singleValue = value;
          }
        }, function() {
          if (hasValue) {
            subscriber.next(singleValue);
            subscriber.complete();
          } else {
            subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
          }
        }));
      });
    }
    exports.single = single;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skip = void 0;
    var filter_1 = require_filter();
    function skip2(count2) {
      return filter_1.filter(function(_, index) {
        return count2 <= index;
      });
    }
    exports.skip = skip2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipLast = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipLast2(skipCount) {
      return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var valueIndex = seen++;
          if (valueIndex < skipCount) {
            ring[valueIndex] = value;
          } else {
            var index = valueIndex % skipCount;
            var oldValue = ring[index];
            ring[index] = value;
            subscriber.next(oldValue);
          }
        }));
        return function() {
          ring = null;
        };
      });
    }
    exports.skipLast = skipLast2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function skipUntil2(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
          taking = true;
        }, noop_1.noop);
        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return taking && subscriber.next(value);
        }));
      });
    }
    exports.skipUntil = skipUntil2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipWhile3(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
      });
    }
    exports.skipWhile = skipWhile3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.startWith = void 0;
    var concat_1 = require_concat();
    var args_1 = require_args();
    var lift_1 = require_lift();
    function startWith() {
      var values2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values2[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(values2);
      return lift_1.operate(function(source, subscriber) {
        (scheduler ? concat_1.concat(values2, source, scheduler) : concat_1.concat(values2, source)).subscribe(subscriber);
      });
    }
    exports.startWith = startWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchMap = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function switchMap(project, resultSelector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
          var innerIndex = 0;
          var outerIndex = index++;
          innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
          }, function() {
            innerSubscriber = null;
            checkComplete();
          }));
        }, function() {
          isComplete = true;
          checkComplete();
        }));
      });
    }
    exports.switchMap = switchMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchAll = void 0;
    var switchMap_1 = require_switchMap();
    var identity_1 = require_identity();
    function switchAll() {
      return switchMap_1.switchMap(identity_1.identity);
    }
    exports.switchAll = switchAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchMapTo = void 0;
    var switchMap_1 = require_switchMap();
    var isFunction_1 = require_isFunction();
    function switchMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
        return innerObservable;
      }, resultSelector) : switchMap_1.switchMap(function() {
        return innerObservable;
      });
    }
    exports.switchMapTo = switchMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchScan = void 0;
    var switchMap_1 = require_switchMap();
    var lift_1 = require_lift();
    function switchScan(accumulator, seed) {
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        switchMap_1.switchMap(function(value, index) {
          return accumulator(state, value, index);
        }, function(_, innerValue) {
          return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
          state = null;
        };
      });
    }
    exports.switchScan = switchScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function takeUntil2(notifier) {
      return lift_1.operate(function(source, subscriber) {
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return subscriber.complete();
        }, noop_1.noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }
    exports.takeUntil = takeUntil2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeWhile2(predicate, inclusive) {
      if (inclusive === void 0) {
        inclusive = false;
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var result = predicate(value, index++);
          (result || inclusive) && subscriber.next(value);
          !result && subscriber.complete();
        }));
      });
    }
    exports.takeWhile = takeWhile2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tap = void 0;
    var isFunction_1 = require_isFunction();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    function tap(observerOrNext, error, complete) {
      var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
      return tapObserver ? lift_1.operate(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var _a2;
          (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
          subscriber.next(value);
        }, function() {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          subscriber.complete();
        }, function(err) {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
          subscriber.error(err);
        }, function() {
          var _a2, _b;
          if (isUnsub) {
            (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          }
          (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
        }));
      }) : identity_1.identity;
    }
    exports.tap = tap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttle = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function throttle(durationSelector, config) {
      return lift_1.operate(function(source, subscriber) {
        var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
          throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
          throttled = null;
          if (trailing) {
            send();
            isComplete && subscriber.complete();
          }
        };
        var cleanupThrottling = function() {
          throttled = null;
          isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
          return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
          if (hasValue) {
            hasValue = false;
            var value = sendValue;
            sendValue = null;
            subscriber.next(value);
            !isComplete && startThrottle(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          sendValue = value;
          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
          isComplete = true;
          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
      });
    }
    exports.throttle = throttle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttleTime = void 0;
    var async_1 = require_async();
    var throttle_1 = require_throttle();
    var timer_1 = require_timer();
    function throttleTime(duration, scheduler, config) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration$ = timer_1.timer(duration, scheduler);
      return throttle_1.throttle(function() {
        return duration$;
      }, config);
    }
    exports.throttleTime = throttleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeInterval = exports.timeInterval = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function timeInterval(scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var last3 = scheduler.now();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var now = scheduler.now();
          var interval = now - last3;
          last3 = now;
          subscriber.next(new TimeInterval(value, interval));
        }));
      });
    }
    exports.timeInterval = timeInterval;
    var TimeInterval = /* @__PURE__ */ function() {
      function TimeInterval2(value, interval) {
        this.value = value;
        this.interval = interval;
      }
      return TimeInterval2;
    }();
    exports.TimeInterval = TimeInterval;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeoutWith = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var timeout_1 = require_timeout();
    function timeoutWith(due, withObservable, scheduler) {
      var first3;
      var each;
      var _with;
      scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
      if (isDate_1.isValidDate(due)) {
        first3 = due;
      } else if (typeof due === "number") {
        each = due;
      }
      if (withObservable) {
        _with = function() {
          return withObservable;
        };
      } else {
        throw new TypeError("No observable provided to switch to");
      }
      if (first3 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return timeout_1.timeout({
        first: first3,
        each,
        scheduler,
        with: _with
      });
    }
    exports.timeoutWith = timeoutWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestamp = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var map_1 = require_map3();
    function timestamp(timestampProvider) {
      if (timestampProvider === void 0) {
        timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      return map_1.map(function(value) {
        return { value, timestamp: timestampProvider.now() };
      });
    }
    exports.timestamp = timestamp;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.window = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function window(windowBoundaries) {
      return lift_1.operate(function(source, subscriber) {
        var windowSubject = new Subject_1.Subject();
        subscriber.next(windowSubject.asObservable());
        var errorHandler = function(err) {
          windowSubject.error(err);
          subscriber.error(err);
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
          windowSubject.complete();
          subscriber.complete();
        }, errorHandler));
        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          windowSubject.complete();
          subscriber.next(windowSubject = new Subject_1.Subject());
        }, noop_1.noop, errorHandler));
        return function() {
          windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
          windowSubject = null;
        };
      });
    }
    exports.window = window;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports) {
    "use strict";
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowCount = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function windowCount(windowSize, startWindowEvery) {
      if (startWindowEvery === void 0) {
        startWindowEvery = 0;
      }
      var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
      return lift_1.operate(function(source, subscriber) {
        var windows = [new Subject_1.Subject()];
        var starts = [];
        var count2 = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var windows_1 = __values2(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
              var window_1 = windows_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          var c = count2 - windowSize + 1;
          if (c >= 0 && c % startEvery === 0) {
            windows.shift().complete();
          }
          if (++count2 % startEvery === 0) {
            var window_2 = new Subject_1.Subject();
            windows.push(window_2);
            subscriber.next(window_2.asObservable());
          }
        }, function() {
          while (windows.length > 0) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, function(err) {
          while (windows.length > 0) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        }, function() {
          starts = null;
          windows = null;
        }));
      });
    }
    exports.windowCount = windowCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowTime = void 0;
    var Subject_1 = require_Subject();
    var async_1 = require_async();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function windowTime(windowTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxWindowSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
          var window = record.window, subs = record.subs;
          window.complete();
          subs.unsubscribe();
          arrRemove_1.arrRemove(windowRecords, record);
          restartOnClose && startWindow();
        };
        var startWindow = function() {
          if (windowRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var window_1 = new Subject_1.Subject();
            var record_1 = {
              window: window_1,
              subs,
              seen: 0
            };
            windowRecords.push(record_1);
            subscriber.next(window_1.asObservable());
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return closeWindow(record_1);
            }, windowTimeSpan);
          }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        } else {
          restartOnClose = true;
        }
        startWindow();
        var loop = function(cb) {
          return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
          loop(function(_a2) {
            var window = _a2.window;
            return cb(window);
          });
          cb(subscriber);
          subscriber.unsubscribe();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          loop(function(record) {
            record.window.next(value);
            maxWindowSize <= ++record.seen && closeWindow(record);
          });
        }, function() {
          return terminate(function(consumer) {
            return consumer.complete();
          });
        }, function(err) {
          return terminate(function(consumer) {
            return consumer.error(err);
          });
        }));
        return function() {
          windowRecords = null;
        };
      });
    }
    exports.windowTime = windowTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports) {
    "use strict";
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowToggle = void 0;
    var Subject_1 = require_Subject();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function windowToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var windows = [];
        var handleError = function(err) {
          while (0 < windows.length) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        };
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var window = new Subject_1.Subject();
          windows.push(window);
          var closingSubscription = new Subscription_1.Subscription();
          var closeWindow = function() {
            arrRemove_1.arrRemove(windows, window);
            window.complete();
            closingSubscription.unsubscribe();
          };
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
          } catch (err) {
            handleError(err);
            return;
          }
          subscriber.next(window.asObservable());
          closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          var windowsCopy = windows.slice();
          try {
            for (var windowsCopy_1 = __values2(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
              var window_1 = windowsCopy_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (0 < windows.length) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, handleError, function() {
          while (0 < windows.length) {
            windows.shift().unsubscribe();
          }
        }));
      });
    }
    exports.windowToggle = windowToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function windowWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var window;
        var closingSubscriber;
        var handleError = function(err) {
          window.error(err);
          subscriber.error(err);
        };
        var openWindow = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window === null || window === void 0 ? void 0 : window.complete();
          window = new Subject_1.Subject();
          subscriber.next(window.asObservable());
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector());
          } catch (err) {
            handleError(err);
            return;
          }
          closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
        };
        openWindow();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return window.next(value);
        }, function() {
          window.complete();
          subscriber.complete();
        }, handleError, function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window = null;
        }));
      });
    }
    exports.windowWhen = windowWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withLatestFrom = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var identity_1 = require_identity();
    var noop_1 = require_noop();
    var args_1 = require_args();
    function withLatestFrom() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      var project = args_1.popResultSelector(inputs);
      return lift_1.operate(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
          return false;
        });
        var ready = false;
        var _loop_1 = function(i2) {
          innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            otherValues[i2] = value;
            if (!ready && !hasValue[i2]) {
              hasValue[i2] = true;
              (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
            }
          }, noop_1.noop));
        };
        for (var i = 0; i < len; i++) {
          _loop_1(i);
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (ready) {
            var values2 = __spreadArray([value], __read(otherValues));
            subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values2))) : values2);
          }
        }));
      });
    }
    exports.withLatestFrom = withLatestFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipAll = void 0;
    var zip_1 = require_zip();
    var joinAllInternals_1 = require_joinAllInternals();
    function zipAll2(project) {
      return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
    }
    exports.zipAll = zipAll2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zip = void 0;
    var zip_1 = require_zip();
    var lift_1 = require_lift();
    function zip2() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return lift_1.operate(function(source, subscriber) {
        zip_1.zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
      });
    }
    exports.zip = zip2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipWith = void 0;
    var zip_1 = require_zip2();
    function zipWith2() {
      var otherInputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherInputs[_i] = arguments[_i];
      }
      return zip_1.zip.apply(void 0, __spreadArray([], __read(otherInputs)));
    }
    exports.zipWith = zipWith2;
  }
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/rxjs/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
    exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
    exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
    exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
    var Observable_1 = require_Observable();
    Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = require_ConnectableObservable();
    Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = require_observable();
    Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = require_animationFrames();
    Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = require_Subject();
    Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = require_BehaviorSubject();
    Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = require_ReplaySubject();
    Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = require_AsyncSubject();
    Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = require_asap();
    Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_1 = require_async();
    Object.defineProperty(exports, "async", { enumerable: true, get: function() {
      return async_1.async;
    } });
    Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
      return async_1.asyncScheduler;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = require_animationFrame();
    Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
    Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = require_Scheduler();
    Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = require_Subscriber();
    Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = require_Notification();
    Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = require_pipe();
    Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = require_noop();
    Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = require_identity();
    Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = require_isObservable();
    Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = require_lastValueFrom();
    Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = require_firstValueFrom();
    Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = require_EmptyError();
    Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = require_NotFoundError();
    Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = require_SequenceError();
    Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = require_bindCallback();
    Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = require_bindNodeCallback();
    Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = require_combineLatest();
    Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = require_connectable();
    Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_1 = require_defer();
    Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
      return defer_1.defer;
    } });
    var empty_1 = require_empty();
    Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = require_forkJoin();
    Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = require_from();
    Object.defineProperty(exports, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = require_fromEvent();
    Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = require_fromEventPattern();
    Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = require_generate();
    Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = require_iif();
    Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = require_interval();
    Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = require_never();
    Object.defineProperty(exports, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = require_of();
    Object.defineProperty(exports, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = require_pairs();
    Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = require_partition();
    Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = require_race();
    Object.defineProperty(exports, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = require_range();
    Object.defineProperty(exports, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = require_throwError();
    Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = require_using();
    Object.defineProperty(exports, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = require_zip();
    Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = require_scheduled();
    Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = require_empty();
    Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = require_never();
    Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar(require_types2(), exports);
    var config_1 = require_config();
    Object.defineProperty(exports, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = require_audit();
    Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map3();
    Object.defineProperty(exports, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = require_timeout();
    Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/partition.js
var require_partition2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    function partition2(predicate, thisArg) {
      return function(source) {
        return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
      };
    }
    exports.partition = partition2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/race.js
var require_race2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/race.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.race = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var raceWith_1 = require_raceWith();
    function race() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return raceWith_1.raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray_1.argsOrArgArray(args))));
    }
    exports.race = race;
  }
});

// node_modules/rxjs/dist/cjs/operators/index.js
var require_operators = __commonJS({
  "node_modules/rxjs/dist/cjs/operators/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeAll = exports.merge = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.concat = exports.combineLatestWith = exports.combineLatest = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = void 0;
    exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.race = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.partition = exports.pairwise = exports.onErrorResumeNext = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = void 0;
    exports.zipWith = exports.zipAll = exports.zip = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = void 0;
    var audit_1 = require_audit();
    Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatest_1 = require_combineLatest2();
    Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concat_1 = require_concat2();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map3();
    Object.defineProperty(exports, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var merge_1 = require_merge2();
    Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNext;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var partition_1 = require_partition2();
    Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var race_1 = require_race2();
    Object.defineProperty(exports, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zip_1 = require_zip2();
    Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// node_modules/sass-embedded/node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/sass-embedded/node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    function getChromeVersion() {
      const matches = /(Chrome|Chromium)\/(?<chromeVersion>\d+)\./.exec(navigator.userAgent);
      if (!matches) {
        return;
      }
      return Number.parseInt(matches.groups.chromeVersion, 10);
    }
    var colorSupport = getChromeVersion() >= 69 ? {
      level: 1,
      hasBasic: true,
      has256: false,
      has16m: false
    } : false;
    module.exports = {
      stdout: colorSupport,
      stderr: colorSupport
    };
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/types.js
var require_types3 = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/timestamp_pb.js
var require_timestamp_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/timestamp_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimestampSchema = exports.file_google_protobuf_timestamp = void 0;
    var file_js_1 = require_file();
    var message_js_1 = require_message();
    exports.file_google_protobuf_timestamp = (0, file_js_1.fileDesc)("Ch9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvEg9nb29nbGUucHJvdG9idWYiKwoJVGltZXN0YW1wEg8KB3NlY29uZHMYASABKAMSDQoFbmFub3MYAiABKAVChQEKE2NvbS5nb29nbGUucHJvdG9idWZCDlRpbWVzdGFtcFByb3RvUAFaMmdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3RpbWVzdGFtcHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM");
    exports.TimestampSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_timestamp, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestampNow = timestampNow;
    exports.timestampFromDate = timestampFromDate;
    exports.timestampDate = timestampDate;
    exports.timestampFromMs = timestampFromMs;
    exports.timestampMs = timestampMs;
    var timestamp_pb_js_1 = require_timestamp_pb();
    var create_js_1 = require_create();
    var proto_int64_js_1 = require_proto_int64();
    function timestampNow() {
      return timestampFromDate(/* @__PURE__ */ new Date());
    }
    function timestampFromDate(date) {
      return timestampFromMs(date.getTime());
    }
    function timestampDate(timestamp) {
      return new Date(timestampMs(timestamp));
    }
    function timestampFromMs(timestampMs2) {
      return (0, create_js_1.create)(timestamp_pb_js_1.TimestampSchema, {
        seconds: proto_int64_js_1.protoInt64.parse(Math.floor(timestampMs2 / 1e3)),
        nanos: timestampMs2 % 1e3 * 1e6
      });
    }
    function timestampMs(timestamp) {
      return Number(timestamp.seconds) * 1e3 + Math.ceil(timestamp.nanos / 1e6);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/any_pb.js
var require_any_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/any_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnySchema = exports.file_google_protobuf_any = void 0;
    var file_js_1 = require_file();
    var message_js_1 = require_message();
    exports.file_google_protobuf_any = (0, file_js_1.fileDesc)("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM");
    exports.AnySchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_any, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/any.js
var require_any = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/any.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.anyPack = anyPack;
    exports.anyIs = anyIs;
    exports.anyUnpack = anyUnpack;
    exports.anyUnpackTo = anyUnpackTo;
    var any_pb_js_1 = require_any_pb();
    var create_js_1 = require_create();
    var to_binary_js_1 = require_to_binary();
    var from_binary_js_1 = require_from_binary();
    function anyPack(schema, message, into) {
      let ret = false;
      if (!into) {
        into = (0, create_js_1.create)(any_pb_js_1.AnySchema);
        ret = true;
      }
      into.value = (0, to_binary_js_1.toBinary)(schema, message);
      into.typeUrl = typeNameToUrl(message.$typeName);
      return ret ? into : void 0;
    }
    function anyIs(any, descOrTypeName) {
      if (any.typeUrl === "") {
        return false;
      }
      const want = typeof descOrTypeName == "string" ? descOrTypeName : descOrTypeName.typeName;
      const got = typeUrlToName(any.typeUrl);
      return want === got;
    }
    function anyUnpack(any, registryOrMessageDesc) {
      if (any.typeUrl === "") {
        return void 0;
      }
      const desc = registryOrMessageDesc.kind == "message" ? registryOrMessageDesc : registryOrMessageDesc.getMessage(typeUrlToName(any.typeUrl));
      if (!desc || !anyIs(any, desc)) {
        return void 0;
      }
      return (0, from_binary_js_1.fromBinary)(desc, any.value);
    }
    function anyUnpackTo(any, schema, message) {
      if (!anyIs(any, schema)) {
        return void 0;
      }
      return (0, from_binary_js_1.mergeFromBinary)(schema, message, any.value);
    }
    function typeNameToUrl(name) {
      return `type.googleapis.com/${name}`;
    }
    function typeUrlToName(url) {
      const slash = url.lastIndexOf("/");
      const name = slash >= 0 ? url.substring(slash + 1) : url;
      if (!name.length) {
        throw new Error(`invalid type url: ${url}`);
      }
      return name;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/source_context_pb.js
var require_source_context_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/source_context_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SourceContextSchema = exports.file_google_protobuf_source_context = void 0;
    var file_js_1 = require_file();
    var message_js_1 = require_message();
    exports.file_google_protobuf_source_context = (0, file_js_1.fileDesc)("CiRnb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQucHJvdG8SD2dvb2dsZS5wcm90b2J1ZiIiCg1Tb3VyY2VDb250ZXh0EhEKCWZpbGVfbmFtZRgBIAEoCUKKAQoTY29tLmdvb2dsZS5wcm90b2J1ZkISU291cmNlQ29udGV4dFByb3RvUAFaNmdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3NvdXJjZWNvbnRleHRwYqICA0dQQqoCHkdvb2dsZS5Qcm90b2J1Zi5XZWxsS25vd25UeXBlc2IGcHJvdG8z");
    exports.SourceContextSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_source_context, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/type_pb.js
var require_type_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/type_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SyntaxSchema = exports.Syntax = exports.OptionSchema = exports.EnumValueSchema = exports.EnumSchema = exports.Field_CardinalitySchema = exports.Field_Cardinality = exports.Field_KindSchema = exports.Field_Kind = exports.FieldSchema = exports.TypeSchema = exports.file_google_protobuf_type = void 0;
    var file_js_1 = require_file();
    var any_pb_js_1 = require_any_pb();
    var source_context_pb_js_1 = require_source_context_pb();
    var message_js_1 = require_message();
    var enum_js_1 = require_enum();
    exports.file_google_protobuf_type = (0, file_js_1.fileDesc)("Chpnb29nbGUvcHJvdG9idWYvdHlwZS5wcm90bxIPZ29vZ2xlLnByb3RvYnVmIugBCgRUeXBlEgwKBG5hbWUYASABKAkSJgoGZmllbGRzGAIgAygLMhYuZ29vZ2xlLnByb3RvYnVmLkZpZWxkEg4KBm9uZW9mcxgDIAMoCRIoCgdvcHRpb25zGAQgAygLMhcuZ29vZ2xlLnByb3RvYnVmLk9wdGlvbhI2Cg5zb3VyY2VfY29udGV4dBgFIAEoCzIeLmdvb2dsZS5wcm90b2J1Zi5Tb3VyY2VDb250ZXh0EicKBnN5bnRheBgGIAEoDjIXLmdvb2dsZS5wcm90b2J1Zi5TeW50YXgSDwoHZWRpdGlvbhgHIAEoCSLVBQoFRmllbGQSKQoEa2luZBgBIAEoDjIbLmdvb2dsZS5wcm90b2J1Zi5GaWVsZC5LaW5kEjcKC2NhcmRpbmFsaXR5GAIgASgOMiIuZ29vZ2xlLnByb3RvYnVmLkZpZWxkLkNhcmRpbmFsaXR5Eg4KBm51bWJlchgDIAEoBRIMCgRuYW1lGAQgASgJEhAKCHR5cGVfdXJsGAYgASgJEhMKC29uZW9mX2luZGV4GAcgASgFEg4KBnBhY2tlZBgIIAEoCBIoCgdvcHRpb25zGAkgAygLMhcuZ29vZ2xlLnByb3RvYnVmLk9wdGlvbhIRCglqc29uX25hbWUYCiABKAkSFQoNZGVmYXVsdF92YWx1ZRgLIAEoCSLIAgoES2luZBIQCgxUWVBFX1VOS05PV04QABIPCgtUWVBFX0RPVUJMRRABEg4KClRZUEVfRkxPQVQQAhIOCgpUWVBFX0lOVDY0EAMSDwoLVFlQRV9VSU5UNjQQBBIOCgpUWVBFX0lOVDMyEAUSEAoMVFlQRV9GSVhFRDY0EAYSEAoMVFlQRV9GSVhFRDMyEAcSDQoJVFlQRV9CT09MEAgSDwoLVFlQRV9TVFJJTkcQCRIOCgpUWVBFX0dST1VQEAoSEAoMVFlQRV9NRVNTQUdFEAsSDgoKVFlQRV9CWVRFUxAMEg8KC1RZUEVfVUlOVDMyEA0SDQoJVFlQRV9FTlVNEA4SEQoNVFlQRV9TRklYRUQzMhAPEhEKDVRZUEVfU0ZJWEVENjQQEBIPCgtUWVBFX1NJTlQzMhAREg8KC1RZUEVfU0lOVDY0EBIidAoLQ2FyZGluYWxpdHkSFwoTQ0FSRElOQUxJVFlfVU5LTk9XThAAEhgKFENBUkRJTkFMSVRZX09QVElPTkFMEAESGAoUQ0FSRElOQUxJVFlfUkVRVUlSRUQQAhIYChRDQVJESU5BTElUWV9SRVBFQVRFRBADIt8BCgRFbnVtEgwKBG5hbWUYASABKAkSLQoJZW51bXZhbHVlGAIgAygLMhouZ29vZ2xlLnByb3RvYnVmLkVudW1WYWx1ZRIoCgdvcHRpb25zGAMgAygLMhcuZ29vZ2xlLnByb3RvYnVmLk9wdGlvbhI2Cg5zb3VyY2VfY29udGV4dBgEIAEoCzIeLmdvb2dsZS5wcm90b2J1Zi5Tb3VyY2VDb250ZXh0EicKBnN5bnRheBgFIAEoDjIXLmdvb2dsZS5wcm90b2J1Zi5TeW50YXgSDwoHZWRpdGlvbhgGIAEoCSJTCglFbnVtVmFsdWUSDAoEbmFtZRgBIAEoCRIOCgZudW1iZXIYAiABKAUSKAoHb3B0aW9ucxgDIAMoCzIXLmdvb2dsZS5wcm90b2J1Zi5PcHRpb24iOwoGT3B0aW9uEgwKBG5hbWUYASABKAkSIwoFdmFsdWUYAiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55KkMKBlN5bnRheBIRCg1TWU5UQVhfUFJPVE8yEAASEQoNU1lOVEFYX1BST1RPMxABEhMKD1NZTlRBWF9FRElUSU9OUxACQnsKE2NvbS5nb29nbGUucHJvdG9idWZCCVR5cGVQcm90b1ABWi1nb29nbGUuZ29sYW5nLm9yZy9wcm90b2J1Zi90eXBlcy9rbm93bi90eXBlcGL4AQGiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw", [any_pb_js_1.file_google_protobuf_any, source_context_pb_js_1.file_google_protobuf_source_context]);
    exports.TypeSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_type, 0);
    exports.FieldSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_type, 1);
    var Field_Kind;
    (function(Field_Kind2) {
      Field_Kind2[Field_Kind2["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
      Field_Kind2[Field_Kind2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
      Field_Kind2[Field_Kind2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
      Field_Kind2[Field_Kind2["TYPE_INT64"] = 3] = "TYPE_INT64";
      Field_Kind2[Field_Kind2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
      Field_Kind2[Field_Kind2["TYPE_INT32"] = 5] = "TYPE_INT32";
      Field_Kind2[Field_Kind2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
      Field_Kind2[Field_Kind2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
      Field_Kind2[Field_Kind2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
      Field_Kind2[Field_Kind2["TYPE_STRING"] = 9] = "TYPE_STRING";
      Field_Kind2[Field_Kind2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
      Field_Kind2[Field_Kind2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
      Field_Kind2[Field_Kind2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
      Field_Kind2[Field_Kind2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
      Field_Kind2[Field_Kind2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
      Field_Kind2[Field_Kind2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
      Field_Kind2[Field_Kind2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
      Field_Kind2[Field_Kind2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
      Field_Kind2[Field_Kind2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
    })(Field_Kind || (exports.Field_Kind = Field_Kind = {}));
    exports.Field_KindSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_type, 1, 0);
    var Field_Cardinality;
    (function(Field_Cardinality2) {
      Field_Cardinality2[Field_Cardinality2["UNKNOWN"] = 0] = "UNKNOWN";
      Field_Cardinality2[Field_Cardinality2["OPTIONAL"] = 1] = "OPTIONAL";
      Field_Cardinality2[Field_Cardinality2["REQUIRED"] = 2] = "REQUIRED";
      Field_Cardinality2[Field_Cardinality2["REPEATED"] = 3] = "REPEATED";
    })(Field_Cardinality || (exports.Field_Cardinality = Field_Cardinality = {}));
    exports.Field_CardinalitySchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_type, 1, 1);
    exports.EnumSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_type, 2);
    exports.EnumValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_type, 3);
    exports.OptionSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_type, 4);
    var Syntax;
    (function(Syntax2) {
      Syntax2[Syntax2["PROTO2"] = 0] = "PROTO2";
      Syntax2[Syntax2["PROTO3"] = 1] = "PROTO3";
      Syntax2[Syntax2["EDITIONS"] = 2] = "EDITIONS";
    })(Syntax || (exports.Syntax = Syntax = {}));
    exports.SyntaxSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_type, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/api_pb.js
var require_api_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/api_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MixinSchema = exports.MethodSchema = exports.ApiSchema = exports.file_google_protobuf_api = void 0;
    var file_js_1 = require_file();
    var source_context_pb_js_1 = require_source_context_pb();
    var type_pb_js_1 = require_type_pb();
    var message_js_1 = require_message();
    exports.file_google_protobuf_api = (0, file_js_1.fileDesc)("Chlnb29nbGUvcHJvdG9idWYvYXBpLnByb3RvEg9nb29nbGUucHJvdG9idWYigQIKA0FwaRIMCgRuYW1lGAEgASgJEigKB21ldGhvZHMYAiADKAsyFy5nb29nbGUucHJvdG9idWYuTWV0aG9kEigKB29wdGlvbnMYAyADKAsyFy5nb29nbGUucHJvdG9idWYuT3B0aW9uEg8KB3ZlcnNpb24YBCABKAkSNgoOc291cmNlX2NvbnRleHQYBSABKAsyHi5nb29nbGUucHJvdG9idWYuU291cmNlQ29udGV4dBImCgZtaXhpbnMYBiADKAsyFi5nb29nbGUucHJvdG9idWYuTWl4aW4SJwoGc3ludGF4GAcgASgOMhcuZ29vZ2xlLnByb3RvYnVmLlN5bnRheCLVAQoGTWV0aG9kEgwKBG5hbWUYASABKAkSGAoQcmVxdWVzdF90eXBlX3VybBgCIAEoCRIZChFyZXF1ZXN0X3N0cmVhbWluZxgDIAEoCBIZChFyZXNwb25zZV90eXBlX3VybBgEIAEoCRIaChJyZXNwb25zZV9zdHJlYW1pbmcYBSABKAgSKAoHb3B0aW9ucxgGIAMoCzIXLmdvb2dsZS5wcm90b2J1Zi5PcHRpb24SJwoGc3ludGF4GAcgASgOMhcuZ29vZ2xlLnByb3RvYnVmLlN5bnRheCIjCgVNaXhpbhIMCgRuYW1lGAEgASgJEgwKBHJvb3QYAiABKAlCdgoTY29tLmdvb2dsZS5wcm90b2J1ZkIIQXBpUHJvdG9QAVosZ29vZ2xlLmdvbGFuZy5vcmcvcHJvdG9idWYvdHlwZXMva25vd24vYXBpcGKiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw", [source_context_pb_js_1.file_google_protobuf_source_context, type_pb_js_1.file_google_protobuf_type]);
    exports.ApiSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_api, 0);
    exports.MethodSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_api, 1);
    exports.MixinSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_api, 2);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/duration_pb.js
var require_duration_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/duration_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DurationSchema = exports.file_google_protobuf_duration = void 0;
    var file_js_1 = require_file();
    var message_js_1 = require_message();
    exports.file_google_protobuf_duration = (0, file_js_1.fileDesc)("Ch5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8SD2dvb2dsZS5wcm90b2J1ZiIqCghEdXJhdGlvbhIPCgdzZWNvbmRzGAEgASgDEg0KBW5hbm9zGAIgASgFQoMBChNjb20uZ29vZ2xlLnByb3RvYnVmQg1EdXJhdGlvblByb3RvUAFaMWdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2R1cmF0aW9ucGL4AQGiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw");
    exports.DurationSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_duration, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/empty_pb.js
var require_empty_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/empty_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptySchema = exports.file_google_protobuf_empty = void 0;
    var file_js_1 = require_file();
    var message_js_1 = require_message();
    exports.file_google_protobuf_empty = (0, file_js_1.fileDesc)("Chtnb29nbGUvcHJvdG9idWYvZW1wdHkucHJvdG8SD2dvb2dsZS5wcm90b2J1ZiIHCgVFbXB0eUJ9ChNjb20uZ29vZ2xlLnByb3RvYnVmQgpFbXB0eVByb3RvUAFaLmdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2VtcHR5cGL4AQGiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw");
    exports.EmptySchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_empty, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/field_mask_pb.js
var require_field_mask_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/field_mask_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FieldMaskSchema = exports.file_google_protobuf_field_mask = void 0;
    var file_js_1 = require_file();
    var message_js_1 = require_message();
    exports.file_google_protobuf_field_mask = (0, file_js_1.fileDesc)("CiBnb29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90bxIPZ29vZ2xlLnByb3RvYnVmIhoKCUZpZWxkTWFzaxINCgVwYXRocxgBIAMoCUKFAQoTY29tLmdvb2dsZS5wcm90b2J1ZkIORmllbGRNYXNrUHJvdG9QAVoyZ29vZ2xlLmdvbGFuZy5vcmcvcHJvdG9idWYvdHlwZXMva25vd24vZmllbGRtYXNrcGL4AQGiAgNHUEKqAh5Hb29nbGUuUHJvdG9idWYuV2VsbEtub3duVHlwZXNiBnByb3RvMw");
    exports.FieldMaskSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_field_mask, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/struct_pb.js
var require_struct_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/struct_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullValueSchema = exports.NullValue = exports.ListValueSchema = exports.ValueSchema = exports.StructSchema = exports.file_google_protobuf_struct = void 0;
    var file_js_1 = require_file();
    var message_js_1 = require_message();
    var enum_js_1 = require_enum();
    exports.file_google_protobuf_struct = (0, file_js_1.fileDesc)("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM");
    exports.StructSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_struct, 0);
    exports.ValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_struct, 1);
    exports.ListValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_struct, 2);
    var NullValue;
    (function(NullValue2) {
      NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
    })(NullValue || (exports.NullValue = NullValue = {}));
    exports.NullValueSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_struct, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/wrappers_pb.js
var require_wrappers_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/wrappers_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesValueSchema = exports.StringValueSchema = exports.BoolValueSchema = exports.UInt32ValueSchema = exports.Int32ValueSchema = exports.UInt64ValueSchema = exports.Int64ValueSchema = exports.FloatValueSchema = exports.DoubleValueSchema = exports.file_google_protobuf_wrappers = void 0;
    var file_js_1 = require_file();
    var message_js_1 = require_message();
    exports.file_google_protobuf_wrappers = (0, file_js_1.fileDesc)("Ch5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8SD2dvb2dsZS5wcm90b2J1ZiIcCgtEb3VibGVWYWx1ZRINCgV2YWx1ZRgBIAEoASIbCgpGbG9hdFZhbHVlEg0KBXZhbHVlGAEgASgCIhsKCkludDY0VmFsdWUSDQoFdmFsdWUYASABKAMiHAoLVUludDY0VmFsdWUSDQoFdmFsdWUYASABKAQiGwoKSW50MzJWYWx1ZRINCgV2YWx1ZRgBIAEoBSIcCgtVSW50MzJWYWx1ZRINCgV2YWx1ZRgBIAEoDSIaCglCb29sVmFsdWUSDQoFdmFsdWUYASABKAgiHAoLU3RyaW5nVmFsdWUSDQoFdmFsdWUYASABKAkiGwoKQnl0ZXNWYWx1ZRINCgV2YWx1ZRgBIAEoDEKDAQoTY29tLmdvb2dsZS5wcm90b2J1ZkINV3JhcHBlcnNQcm90b1ABWjFnb29nbGUuZ29sYW5nLm9yZy9wcm90b2J1Zi90eXBlcy9rbm93bi93cmFwcGVyc3Bi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM");
    exports.DoubleValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 0);
    exports.FloatValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 1);
    exports.Int64ValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 2);
    exports.UInt64ValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 3);
    exports.Int32ValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 4);
    exports.UInt32ValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 5);
    exports.BoolValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 6);
    exports.StringValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 7);
    exports.BytesValueSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_wrappers, 8);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/compiler/plugin_pb.js
var require_plugin_pb = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/gen/google/protobuf/compiler/plugin_pb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGeneratorResponse_FeatureSchema = exports.CodeGeneratorResponse_Feature = exports.CodeGeneratorResponse_FileSchema = exports.CodeGeneratorResponseSchema = exports.CodeGeneratorRequestSchema = exports.VersionSchema = exports.file_google_protobuf_compiler_plugin = void 0;
    var file_js_1 = require_file();
    var descriptor_pb_js_1 = require_descriptor_pb();
    var message_js_1 = require_message();
    var enum_js_1 = require_enum();
    exports.file_google_protobuf_compiler_plugin = (0, file_js_1.fileDesc)("CiVnb29nbGUvcHJvdG9idWYvY29tcGlsZXIvcGx1Z2luLnByb3RvEhhnb29nbGUucHJvdG9idWYuY29tcGlsZXIiRgoHVmVyc2lvbhINCgVtYWpvchgBIAEoBRINCgVtaW5vchgCIAEoBRINCgVwYXRjaBgDIAEoBRIOCgZzdWZmaXgYBCABKAkigQIKFENvZGVHZW5lcmF0b3JSZXF1ZXN0EhgKEGZpbGVfdG9fZ2VuZXJhdGUYASADKAkSEQoJcGFyYW1ldGVyGAIgASgJEjgKCnByb3RvX2ZpbGUYDyADKAsyJC5nb29nbGUucHJvdG9idWYuRmlsZURlc2NyaXB0b3JQcm90bxJFChdzb3VyY2VfZmlsZV9kZXNjcmlwdG9ycxgRIAMoCzIkLmdvb2dsZS5wcm90b2J1Zi5GaWxlRGVzY3JpcHRvclByb3RvEjsKEGNvbXBpbGVyX3ZlcnNpb24YAyABKAsyIS5nb29nbGUucHJvdG9idWYuY29tcGlsZXIuVmVyc2lvbiKSAwoVQ29kZUdlbmVyYXRvclJlc3BvbnNlEg0KBWVycm9yGAEgASgJEhoKEnN1cHBvcnRlZF9mZWF0dXJlcxgCIAEoBBIXCg9taW5pbXVtX2VkaXRpb24YAyABKAUSFwoPbWF4aW11bV9lZGl0aW9uGAQgASgFEkIKBGZpbGUYDyADKAsyNC5nb29nbGUucHJvdG9idWYuY29tcGlsZXIuQ29kZUdlbmVyYXRvclJlc3BvbnNlLkZpbGUafwoERmlsZRIMCgRuYW1lGAEgASgJEhcKD2luc2VydGlvbl9wb2ludBgCIAEoCRIPCgdjb250ZW50GA8gASgJEj8KE2dlbmVyYXRlZF9jb2RlX2luZm8YECABKAsyIi5nb29nbGUucHJvdG9idWYuR2VuZXJhdGVkQ29kZUluZm8iVwoHRmVhdHVyZRIQCgxGRUFUVVJFX05PTkUQABIbChdGRUFUVVJFX1BST1RPM19PUFRJT05BTBABEh0KGUZFQVRVUkVfU1VQUE9SVFNfRURJVElPTlMQAkJyChxjb20uZ29vZ2xlLnByb3RvYnVmLmNvbXBpbGVyQgxQbHVnaW5Qcm90b3NaKWdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL3BsdWdpbnBiqgIYR29vZ2xlLlByb3RvYnVmLkNvbXBpbGVy", [descriptor_pb_js_1.file_google_protobuf_descriptor]);
    exports.VersionSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_compiler_plugin, 0);
    exports.CodeGeneratorRequestSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_compiler_plugin, 1);
    exports.CodeGeneratorResponseSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_compiler_plugin, 2);
    exports.CodeGeneratorResponse_FileSchema = (0, message_js_1.messageDesc)(exports.file_google_protobuf_compiler_plugin, 2, 0);
    var CodeGeneratorResponse_Feature;
    (function(CodeGeneratorResponse_Feature2) {
      CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["NONE"] = 0] = "NONE";
      CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["PROTO3_OPTIONAL"] = 1] = "PROTO3_OPTIONAL";
      CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["SUPPORTS_EDITIONS"] = 2] = "SUPPORTS_EDITIONS";
    })(CodeGeneratorResponse_Feature || (exports.CodeGeneratorResponse_Feature = CodeGeneratorResponse_Feature = {}));
    exports.CodeGeneratorResponse_FeatureSchema = (0, enum_js_1.enumDesc)(exports.file_google_protobuf_compiler_plugin, 2, 0);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/index.js
var require_wkt = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_timestamp2(), exports);
    __exportStar(require_any(), exports);
    __exportStar(require_wrappers(), exports);
    __exportStar(require_api_pb(), exports);
    __exportStar(require_any_pb(), exports);
    __exportStar(require_descriptor_pb(), exports);
    __exportStar(require_duration_pb(), exports);
    __exportStar(require_empty_pb(), exports);
    __exportStar(require_field_mask_pb(), exports);
    __exportStar(require_source_context_pb(), exports);
    __exportStar(require_struct_pb(), exports);
    __exportStar(require_timestamp_pb(), exports);
    __exportStar(require_type_pb(), exports);
    __exportStar(require_wrappers_pb(), exports);
    __exportStar(require_plugin_pb(), exports);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/extensions.js
var require_extensions = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/extensions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getExtension = getExtension;
    exports.setExtension = setExtension;
    exports.clearExtension = clearExtension;
    exports.hasExtension = hasExtension;
    exports.hasOption = hasOption;
    exports.getOption = getOption;
    exports.createExtensionContainer = createExtensionContainer;
    var create_js_1 = require_create();
    var from_binary_js_1 = require_from_binary();
    var reflect_js_1 = require_reflect();
    var scalar_js_1 = require_scalar();
    var to_binary_js_1 = require_to_binary();
    var binary_encoding_js_1 = require_binary_encoding();
    var wrappers_js_1 = require_wrappers();
    function getExtension(message, extension) {
      assertExtendee(extension, message);
      const ufs = filterUnknownFields(message.$unknown, extension);
      const [container, field, get11] = createExtensionContainer(extension);
      for (const uf of ufs) {
        (0, from_binary_js_1.readField)(container, new binary_encoding_js_1.BinaryReader(uf.data), field, uf.wireType, {
          readUnknownFields: false
        });
      }
      return get11();
    }
    function setExtension(message, extension, value) {
      var _a;
      assertExtendee(extension, message);
      const ufs = ((_a = message.$unknown) !== null && _a !== void 0 ? _a : []).filter((uf) => uf.no !== extension.number);
      const [container, field] = createExtensionContainer(extension, value);
      const writer = new binary_encoding_js_1.BinaryWriter();
      (0, to_binary_js_1.writeField)(writer, { writeUnknownFields: false }, container, field);
      const reader = new binary_encoding_js_1.BinaryReader(writer.finish());
      while (reader.pos < reader.len) {
        const [no, wireType] = reader.tag();
        const data = reader.skip(wireType, no);
        ufs.push({ no, wireType, data });
      }
      message.$unknown = ufs;
    }
    function clearExtension(message, extension) {
      assertExtendee(extension, message);
      if (message.$unknown === void 0) {
        return;
      }
      message.$unknown = message.$unknown.filter((uf) => uf.no !== extension.number);
    }
    function hasExtension(message, extension) {
      var _a;
      return extension.extendee.typeName === message.$typeName && !!((_a = message.$unknown) === null || _a === void 0 ? void 0 : _a.find((uf) => uf.no === extension.number));
    }
    function hasOption(element, option) {
      const message = element.proto.options;
      if (!message) {
        return false;
      }
      return hasExtension(message, option);
    }
    function getOption(element, option) {
      const message = element.proto.options;
      if (!message) {
        const [, , get11] = createExtensionContainer(option);
        return get11();
      }
      return getExtension(message, option);
    }
    function filterUnknownFields(unknownFields, extension) {
      if (unknownFields === void 0)
        return [];
      if (extension.fieldKind === "enum" || extension.fieldKind === "scalar") {
        for (let i = unknownFields.length - 1; i >= 0; --i) {
          if (unknownFields[i].no == extension.number) {
            return [unknownFields[i]];
          }
        }
        return [];
      }
      return unknownFields.filter((uf) => uf.no === extension.number);
    }
    function createExtensionContainer(extension, value) {
      const localName = extension.typeName;
      const field = Object.assign(Object.assign({}, extension), { kind: "field", parent: extension.extendee, localName });
      const desc = Object.assign(Object.assign({}, extension.extendee), { fields: [field], members: [field], oneofs: [] });
      const container = (0, create_js_1.create)(desc, value !== void 0 ? { [localName]: value } : void 0);
      return [
        (0, reflect_js_1.reflect)(desc, container),
        field,
        () => {
          const value2 = container[localName];
          if (value2 === void 0) {
            const desc2 = extension.message;
            if ((0, wrappers_js_1.isWrapperDesc)(desc2)) {
              return (0, scalar_js_1.scalarZeroValue)(desc2.fields[0].scalar, desc2.fields[0].longAsString);
            }
            return (0, create_js_1.create)(desc2);
          }
          return value2;
        }
      ];
    }
    function assertExtendee(extension, message) {
      if (extension.extendee.typeName != message.$typeName) {
        throw new Error(`extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/equals.js
var require_equals = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/equals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.equals = equals3;
    var scalar_js_1 = require_scalar();
    var reflect_js_1 = require_reflect();
    var descriptors_js_1 = require_descriptors();
    var index_js_1 = require_wkt();
    var extensions_js_1 = require_extensions();
    function equals3(schema, a, b, options) {
      if (a.$typeName != schema.typeName || b.$typeName != schema.typeName) {
        return false;
      }
      if (a === b) {
        return true;
      }
      return reflectEquals((0, reflect_js_1.reflect)(schema, a), (0, reflect_js_1.reflect)(schema, b), options);
    }
    function reflectEquals(a, b, opts) {
      if (a.desc.typeName === "google.protobuf.Any" && (opts === null || opts === void 0 ? void 0 : opts.unpackAny) == true) {
        return anyUnpackedEquals(a.message, b.message, opts);
      }
      for (const f of a.fields) {
        if (!fieldEquals(f, a, b, opts)) {
          return false;
        }
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.unknown) == true && !unknownEquals(a, b, opts.registry)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.extensions) == true && !extensionsEquals(a, b, opts)) {
        return false;
      }
      return true;
    }
    function fieldEquals(f, a, b, opts) {
      if (!a.isSet(f) && !b.isSet(f)) {
        return true;
      }
      if (!a.isSet(f) || !b.isSet(f)) {
        return false;
      }
      switch (f.fieldKind) {
        case "scalar":
          return (0, scalar_js_1.scalarEquals)(f.scalar, a.get(f), b.get(f));
        case "enum":
          return a.get(f) === b.get(f);
        case "message":
          return reflectEquals(a.get(f), b.get(f), opts);
        case "map": {
          const mapA = a.get(f);
          const mapB = b.get(f);
          const keys2 = [];
          for (const k of mapA.keys()) {
            if (!mapB.has(k)) {
              return false;
            }
            keys2.push(k);
          }
          for (const k of mapB.keys()) {
            if (!mapA.has(k)) {
              return false;
            }
          }
          for (const key of keys2) {
            const va = mapA.get(key);
            const vb = mapB.get(key);
            if (va === vb) {
              continue;
            }
            switch (f.mapKind) {
              case "enum":
                return false;
              case "message":
                if (!reflectEquals(va, vb, opts)) {
                  return false;
                }
                break;
              case "scalar":
                if (!(0, scalar_js_1.scalarEquals)(f.scalar, va, vb)) {
                  return false;
                }
                break;
            }
          }
          break;
        }
        case "list": {
          const listA = a.get(f);
          const listB = b.get(f);
          if (listA.size != listB.size) {
            return false;
          }
          for (let i = 0; i < listA.size; i++) {
            const va = listA.get(i);
            const vb = listB.get(i);
            if (va === vb) {
              continue;
            }
            switch (f.listKind) {
              case "enum":
                return false;
              case "message":
                if (!reflectEquals(va, vb, opts)) {
                  return false;
                }
                break;
              case "scalar":
                if (!(0, scalar_js_1.scalarEquals)(f.scalar, va, vb)) {
                  return false;
                }
                break;
            }
          }
          break;
        }
      }
      return true;
    }
    function anyUnpackedEquals(a, b, opts) {
      if (a.typeUrl !== b.typeUrl) {
        return false;
      }
      const unpackedA = (0, index_js_1.anyUnpack)(a, opts.registry);
      const unpackedB = (0, index_js_1.anyUnpack)(b, opts.registry);
      if (unpackedA && unpackedB) {
        const schema = opts.registry.getMessage(unpackedA.$typeName);
        if (schema) {
          return equals3(schema, unpackedA, unpackedB, opts);
        }
      }
      return (0, scalar_js_1.scalarEquals)(descriptors_js_1.ScalarType.BYTES, a.value, b.value);
    }
    function unknownEquals(a, b, registry) {
      function getTrulyUnknown(msg, registry2) {
        var _a;
        const u = (_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : [];
        return registry2 ? u.filter((uf) => !registry2.getExtensionFor(msg.desc, uf.no)) : u;
      }
      const unknownA = getTrulyUnknown(a, registry);
      const unknownB = getTrulyUnknown(b, registry);
      if (unknownA.length != unknownB.length) {
        return false;
      }
      for (let i = 0; i < unknownA.length; i++) {
        const a2 = unknownA[i], b2 = unknownB[i];
        if (a2.no != b2.no) {
          return false;
        }
        if (a2.wireType != b2.wireType) {
          return false;
        }
        if (!(0, scalar_js_1.scalarEquals)(descriptors_js_1.ScalarType.BYTES, a2.data, b2.data)) {
          return false;
        }
      }
      return true;
    }
    function extensionsEquals(a, b, opts) {
      function getSetExtensions(msg, registry) {
        var _a;
        return ((_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : []).map((uf) => registry.getExtensionFor(msg.desc, uf.no)).filter((e) => e != void 0).filter((e, index, arr) => arr.indexOf(e) === index);
      }
      const extensionsA = getSetExtensions(a, opts.registry);
      const extensionsB = getSetExtensions(b, opts.registry);
      if (extensionsA.length != extensionsB.length || extensionsA.some((e) => !extensionsB.includes(e))) {
        return false;
      }
      for (const extension of extensionsA) {
        const [containerA, field] = (0, extensions_js_1.createExtensionContainer)(extension, (0, extensions_js_1.getExtension)(a.message, extension));
        const [containerB] = (0, extensions_js_1.createExtensionContainer)(extension, (0, extensions_js_1.getExtension)(b.message, extension));
        if (!fieldEquals(field, containerA, containerB, opts)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/size-delimited.js
var require_size_delimited = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/size-delimited.js"(exports) {
    "use strict";
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f) i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sizeDelimitedEncode = sizeDelimitedEncode;
    exports.sizeDelimitedDecodeStream = sizeDelimitedDecodeStream;
    exports.sizeDelimitedPeek = sizeDelimitedPeek;
    var to_binary_js_1 = require_to_binary();
    var binary_encoding_js_1 = require_binary_encoding();
    var from_binary_js_1 = require_from_binary();
    function sizeDelimitedEncode(messageDesc, message, options) {
      const writer = new binary_encoding_js_1.BinaryWriter();
      writer.bytes((0, to_binary_js_1.toBinary)(messageDesc, message, options));
      return writer.finish();
    }
    function sizeDelimitedDecodeStream(messageDesc, iterable, options) {
      return __asyncGenerator(this, arguments, function* sizeDelimitedDecodeStream_1() {
        var _a, e_1, _b, _c;
        function append(buffer2, chunk) {
          const n = new Uint8Array(buffer2.byteLength + chunk.byteLength);
          n.set(buffer2);
          n.set(chunk, buffer2.length);
          return n;
        }
        let buffer = new Uint8Array(0);
        try {
          for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {
            _c = iterable_1_1.value;
            _d = false;
            const chunk = _c;
            buffer = append(buffer, chunk);
            for (; ; ) {
              const size = sizeDelimitedPeek(buffer);
              if (size.eof) {
                break;
              }
              if (size.offset + size.size > buffer.byteLength) {
                break;
              }
              yield yield __await((0, from_binary_js_1.fromBinary)(messageDesc, buffer.subarray(size.offset, size.offset + size.size), options));
              buffer = buffer.subarray(size.offset + size.size);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = iterable_1.return)) yield __await(_b.call(iterable_1));
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (buffer.byteLength > 0) {
          throw new Error("incomplete data");
        }
      });
    }
    function sizeDelimitedPeek(data) {
      const sizeEof = { eof: true, size: null, offset: null };
      for (let i = 0; i < 10; i++) {
        if (i > data.byteLength) {
          return sizeEof;
        }
        if ((data[i] & 128) == 0) {
          const reader = new binary_encoding_js_1.BinaryReader(data);
          let size;
          try {
            size = reader.uint32();
          } catch (e) {
            if (e instanceof RangeError) {
              return sizeEof;
            }
            throw e;
          }
          return {
            eof: false,
            size,
            offset: reader.pos
          };
        }
      }
      throw new Error("invalid varint");
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/index.js
var require_wire = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_binary_encoding(), exports);
    __exportStar(require_base64_encoding(), exports);
    __exportStar(require_text_encoding(), exports);
    __exportStar(require_text_format(), exports);
    __exportStar(require_size_delimited(), exports);
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/to-json.js
var require_to_json = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/to-json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJson = toJson;
    exports.toJsonString = toJsonString;
    exports.enumToJson = enumToJson;
    var descriptors_js_1 = require_descriptors();
    var names_js_1 = require_names();
    var reflect_js_1 = require_reflect();
    var index_js_1 = require_wkt();
    var wrappers_js_1 = require_wrappers();
    var index_js_2 = require_wire();
    var extensions_js_1 = require_extensions();
    var reflect_check_js_1 = require_reflect_check();
    var LEGACY_REQUIRED = 3;
    var IMPLICIT = 2;
    var jsonWriteDefaults = {
      alwaysEmitImplicit: false,
      enumAsInteger: false,
      useProtoFieldName: false
    };
    function makeWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
    }
    function toJson(schema, message, options) {
      return reflectToJson((0, reflect_js_1.reflect)(schema, message), makeWriteOptions(options));
    }
    function toJsonString(schema, message, options) {
      var _a;
      const jsonValue = toJson(schema, message, options);
      return JSON.stringify(jsonValue, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    function enumToJson(descEnum, value) {
      var _a;
      if (descEnum.typeName == "google.protobuf.NullValue") {
        return null;
      }
      const name = (_a = descEnum.value[value]) === null || _a === void 0 ? void 0 : _a.name;
      if (name === void 0) {
        throw new Error(`${String(value)} is not a value in ${descEnum.toString()}`);
      }
      return name;
    }
    function reflectToJson(msg, opts) {
      var _a;
      const wktJson = tryWktToJson(msg, opts);
      if (wktJson !== void 0)
        return wktJson;
      const json = {};
      for (const f of msg.sortedFields) {
        if (!msg.isSet(f)) {
          if (f.presence == LEGACY_REQUIRED) {
            throw new Error(`cannot encode field ${msg.desc.typeName}.${f.name} to JSON: required field not set`);
          }
          if (!opts.alwaysEmitImplicit || f.presence !== IMPLICIT) {
            continue;
          }
        }
        const jsonValue = fieldToJson(f, msg.get(f), opts);
        if (jsonValue !== void 0) {
          json[jsonName(f, opts)] = jsonValue;
        }
      }
      if (opts.registry) {
        const tagSeen = /* @__PURE__ */ new Set();
        for (const uf of (_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : []) {
          if (tagSeen.has(uf.no)) {
            continue;
          }
          const extension = opts.registry.getExtensionFor(msg.desc, uf.no);
          if (!extension) {
            continue;
          }
          const value = (0, extensions_js_1.getExtension)(msg.message, extension);
          const [container, field] = (0, extensions_js_1.createExtensionContainer)(extension, value);
          const jsonValue = fieldToJson(field, container.get(field), opts);
          if (jsonValue !== void 0) {
            json[extension.jsonName] = jsonValue;
          }
        }
      }
      return json;
    }
    function fieldToJson(f, val, opts) {
      switch (f.fieldKind) {
        case "scalar":
          return scalarToJson(f, val);
        case "message":
          return reflectToJson(val, opts);
        case "enum":
          return enumToJsonInternal(f.enum, val, opts.enumAsInteger);
        case "list":
          return listToJson(val, opts);
        case "map":
          return mapToJson(val, opts);
      }
    }
    function mapToJson(map2, opts) {
      const f = map2.field();
      const jsonObj = {};
      switch (f.mapKind) {
        case "scalar":
          for (const [entryKey, entryValue] of map2) {
            jsonObj[entryKey] = scalarToJson(f, entryValue);
          }
          break;
        case "message":
          for (const [entryKey, entryValue] of map2) {
            jsonObj[entryKey] = reflectToJson(entryValue, opts);
          }
          break;
        case "enum":
          for (const [entryKey, entryValue] of map2) {
            jsonObj[entryKey] = enumToJsonInternal(f.enum, entryValue, opts.enumAsInteger);
          }
          break;
      }
      return opts.alwaysEmitImplicit || map2.size > 0 ? jsonObj : void 0;
    }
    function listToJson(list, opts) {
      const f = list.field();
      const jsonArr = [];
      switch (f.listKind) {
        case "scalar":
          for (const item of list) {
            jsonArr.push(scalarToJson(f, item));
          }
          break;
        case "enum":
          for (const item of list) {
            jsonArr.push(enumToJsonInternal(f.enum, item, opts.enumAsInteger));
          }
          break;
        case "message":
          for (const item of list) {
            jsonArr.push(reflectToJson(item, opts));
          }
          break;
      }
      return opts.alwaysEmitImplicit || jsonArr.length > 0 ? jsonArr : void 0;
    }
    function enumToJsonInternal(desc, value, enumAsInteger) {
      var _a;
      if (typeof value != "number") {
        throw new Error(`cannot encode ${desc} to JSON: expected number, got ${(0, reflect_check_js_1.formatVal)(value)}`);
      }
      if (desc.typeName == "google.protobuf.NullValue") {
        return null;
      }
      if (enumAsInteger) {
        return value;
      }
      const val = desc.value[value];
      return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
    }
    function scalarToJson(field, value) {
      var _a, _b, _c, _d, _e, _f;
      switch (field.scalar) {
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
          if (typeof value != "number") {
            throw new Error(`cannot encode ${field} to JSON: ${(_a = (0, reflect_check_js_1.checkField)(field, value)) === null || _a === void 0 ? void 0 : _a.message}`);
          }
          return value;
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case descriptors_js_1.ScalarType.FLOAT:
        case descriptors_js_1.ScalarType.DOUBLE:
          if (typeof value != "number") {
            throw new Error(`cannot encode ${field} to JSON: ${(_b = (0, reflect_check_js_1.checkField)(field, value)) === null || _b === void 0 ? void 0 : _b.message}`);
          }
          if (isNaN(value))
            return "NaN";
          if (value === Number.POSITIVE_INFINITY)
            return "Infinity";
          if (value === Number.NEGATIVE_INFINITY)
            return "-Infinity";
          return value;
        // string:
        case descriptors_js_1.ScalarType.STRING:
          if (typeof value != "string") {
            throw new Error(`cannot encode ${field} to JSON: ${(_c = (0, reflect_check_js_1.checkField)(field, value)) === null || _c === void 0 ? void 0 : _c.message}`);
          }
          return value;
        // bool:
        case descriptors_js_1.ScalarType.BOOL:
          if (typeof value != "boolean") {
            throw new Error(`cannot encode ${field} to JSON: ${(_d = (0, reflect_check_js_1.checkField)(field, value)) === null || _d === void 0 ? void 0 : _d.message}`);
          }
          return value;
        // JSON value will be a decimal string. Either numbers or strings are accepted.
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          if (typeof value != "bigint" && typeof value != "string") {
            throw new Error(`cannot encode ${field} to JSON: ${(_e = (0, reflect_check_js_1.checkField)(field, value)) === null || _e === void 0 ? void 0 : _e.message}`);
          }
          return value.toString();
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case descriptors_js_1.ScalarType.BYTES:
          if (value instanceof Uint8Array) {
            return (0, index_js_2.base64Encode)(value);
          }
          throw new Error(`cannot encode ${field} to JSON: ${(_f = (0, reflect_check_js_1.checkField)(field, value)) === null || _f === void 0 ? void 0 : _f.message}`);
      }
    }
    function jsonName(f, opts) {
      return opts.useProtoFieldName ? f.name : f.jsonName;
    }
    function tryWktToJson(msg, opts) {
      if (!msg.desc.typeName.startsWith("google.protobuf.")) {
        return void 0;
      }
      switch (msg.desc.typeName) {
        case "google.protobuf.Any":
          return anyToJson(msg.message, opts);
        case "google.protobuf.Timestamp":
          return timestampToJson(msg.message);
        case "google.protobuf.Duration":
          return durationToJson(msg.message);
        case "google.protobuf.FieldMask":
          return fieldMaskToJson(msg.message);
        case "google.protobuf.Struct":
          return structToJson(msg.message);
        case "google.protobuf.Value":
          return valueToJson(msg.message);
        case "google.protobuf.ListValue":
          return listValueToJson(msg.message);
        default:
          if ((0, wrappers_js_1.isWrapperDesc)(msg.desc)) {
            const valueField = msg.desc.fields[0];
            return scalarToJson(valueField, msg.get(valueField));
          }
          return void 0;
      }
    }
    function anyToJson(val, opts) {
      if (val.typeUrl === "") {
        return {};
      }
      const { registry } = opts;
      let message;
      let desc;
      if (registry) {
        message = (0, index_js_1.anyUnpack)(val, registry);
        if (message) {
          desc = registry.getMessage(message.$typeName);
        }
      }
      if (!desc || !message) {
        throw new Error(`cannot encode message ${val.$typeName} to JSON: "${val.typeUrl}" is not in the type registry`);
      }
      let json = reflectToJson((0, reflect_js_1.reflect)(desc, message), opts);
      if (desc.typeName.startsWith("google.protobuf.") || json === null || Array.isArray(json) || typeof json !== "object") {
        json = { value: json };
      }
      json["@type"] = val.typeUrl;
      return json;
    }
    function durationToJson(val) {
      if (Number(val.seconds) > 315576e6 || Number(val.seconds) < -315576e6) {
        throw new Error(`cannot encode message ${val.$typeName} to JSON: value out of range`);
      }
      let text = val.seconds.toString();
      if (val.nanos !== 0) {
        let nanosStr = Math.abs(val.nanos).toString();
        nanosStr = "0".repeat(9 - nanosStr.length) + nanosStr;
        if (nanosStr.substring(3) === "000000") {
          nanosStr = nanosStr.substring(0, 3);
        } else if (nanosStr.substring(6) === "000") {
          nanosStr = nanosStr.substring(0, 6);
        }
        text += "." + nanosStr;
        if (val.nanos < 0 && Number(val.seconds) == 0) {
          text = "-" + text;
        }
      }
      return text + "s";
    }
    function fieldMaskToJson(val) {
      return val.paths.map((p) => {
        if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {
          throw new Error(`cannot encode message ${val.$typeName} to JSON: lowerCamelCase of path name "` + p + '" is irreversible');
        }
        return (0, names_js_1.protoCamelCase)(p);
      }).join(",");
    }
    function structToJson(val) {
      const json = {};
      for (const [k, v] of Object.entries(val.fields)) {
        json[k] = valueToJson(v);
      }
      return json;
    }
    function valueToJson(val) {
      switch (val.kind.case) {
        case "nullValue":
          return null;
        case "numberValue":
          if (!Number.isFinite(val.kind.value)) {
            throw new Error(`${val.$typeName} cannot be NaN or Infinity`);
          }
          return val.kind.value;
        case "boolValue":
          return val.kind.value;
        case "stringValue":
          return val.kind.value;
        case "structValue":
          return structToJson(val.kind.value);
        case "listValue":
          return listValueToJson(val.kind.value);
        default:
          throw new Error(`${val.$typeName} must have a value`);
      }
    }
    function listValueToJson(val) {
      return val.values.map(valueToJson);
    }
    function timestampToJson(val) {
      const ms = Number(val.seconds) * 1e3;
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error(`cannot encode message ${val.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
      }
      if (val.nanos < 0) {
        throw new Error(`cannot encode message ${val.$typeName} to JSON: nanos must not be negative`);
      }
      let z = "Z";
      if (val.nanos > 0) {
        const nanosStr = (val.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000") {
          z = "." + nanosStr.substring(0, 3) + "Z";
        } else if (nanosStr.substring(6) === "000") {
          z = "." + nanosStr.substring(0, 6) + "Z";
        } else {
          z = "." + nanosStr + "Z";
        }
      }
      return new Date(ms).toISOString().replace(".000Z", z);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/from-json.js
var require_from_json = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/from-json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromJsonString = fromJsonString;
    exports.mergeFromJsonString = mergeFromJsonString;
    exports.fromJson = fromJson;
    exports.mergeFromJson = mergeFromJson;
    exports.enumFromJson = enumFromJson;
    exports.isEnumJson = isEnumJson;
    var descriptors_js_1 = require_descriptors();
    var proto_int64_js_1 = require_proto_int64();
    var create_js_1 = require_create();
    var reflect_js_1 = require_reflect();
    var error_js_1 = require_error();
    var reflect_check_js_1 = require_reflect_check();
    var scalar_js_1 = require_scalar();
    var base64_encoding_js_1 = require_base64_encoding();
    var index_js_1 = require_wkt();
    var extensions_js_1 = require_extensions();
    var jsonReadDefaults = {
      ignoreUnknownFields: false
    };
    function makeReadOptions(options) {
      return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
    }
    function fromJsonString(schema, json, options) {
      return fromJson(schema, parseJsonString(json, schema.typeName), options);
    }
    function mergeFromJsonString(schema, target, json, options) {
      return mergeFromJson(schema, target, parseJsonString(json, schema.typeName), options);
    }
    function fromJson(schema, json, options) {
      const msg = (0, reflect_js_1.reflect)(schema);
      try {
        readMessage(msg, json, makeReadOptions(options));
      } catch (e) {
        if ((0, error_js_1.isFieldError)(e)) {
          throw new Error(`cannot decode ${e.field()} from JSON: ${e.message}`, {
            cause: e
          });
        }
        throw e;
      }
      return msg.message;
    }
    function mergeFromJson(schema, target, json, options) {
      try {
        readMessage((0, reflect_js_1.reflect)(schema, target), json, makeReadOptions(options));
      } catch (e) {
        if ((0, error_js_1.isFieldError)(e)) {
          throw new Error(`cannot decode ${e.field()} from JSON: ${e.message}`, {
            cause: e
          });
        }
        throw e;
      }
      return target;
    }
    function enumFromJson(descEnum, json) {
      const val = readEnum(descEnum, json, false, false);
      if (val === tokenIgnoredUnknownEnum) {
        throw new Error(`cannot decode ${String(descEnum)} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      return val;
    }
    function isEnumJson(descEnum, value) {
      return void 0 !== descEnum.values.find((v) => v.name === value);
    }
    function readMessage(msg, json, opts) {
      var _a;
      if (tryWktFromJson(msg, json, opts)) {
        return;
      }
      if (json == null || Array.isArray(json) || typeof json != "object") {
        throw new Error(`cannot decode ${msg.desc} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      const oneofSeen = /* @__PURE__ */ new Map();
      const jsonNames = /* @__PURE__ */ new Map();
      for (const field of msg.desc.fields) {
        jsonNames.set(field.name, field).set(field.jsonName, field);
      }
      for (const [jsonKey, jsonValue] of Object.entries(json)) {
        const field = jsonNames.get(jsonKey);
        if (field) {
          if (field.oneof) {
            if (jsonValue === null && field.fieldKind == "scalar") {
              continue;
            }
            const seen = oneofSeen.get(field.oneof);
            if (seen !== void 0) {
              throw new error_js_1.FieldError(field.oneof, `oneof set multiple times by ${seen.name} and ${field.name}`);
            }
            oneofSeen.set(field.oneof, field);
          }
          readField(msg, field, jsonValue, opts);
        } else {
          let extension = void 0;
          if (jsonKey.startsWith("[") && jsonKey.endsWith("]") && (extension = (_a = opts.registry) === null || _a === void 0 ? void 0 : _a.getExtension(jsonKey.substring(1, jsonKey.length - 1))) && extension.extendee.typeName === msg.desc.typeName) {
            const [container, field2, get11] = (0, extensions_js_1.createExtensionContainer)(extension);
            readField(container, field2, jsonValue, opts);
            (0, extensions_js_1.setExtension)(msg.message, extension, get11());
          }
          if (!extension && !opts.ignoreUnknownFields) {
            throw new Error(`cannot decode ${msg.desc} from JSON: key "${jsonKey}" is unknown`);
          }
        }
      }
    }
    function readField(msg, field, json, opts) {
      switch (field.fieldKind) {
        case "scalar":
          readScalarField(msg, field, json);
          break;
        case "enum":
          readEnumField(msg, field, json, opts);
          break;
        case "message":
          readMessageField(msg, field, json, opts);
          break;
        case "list":
          readListField(msg.get(field), json, opts);
          break;
        case "map":
          readMapField(msg.get(field), json, opts);
          break;
      }
    }
    function readMapField(map2, json, opts) {
      if (json === null) {
        return;
      }
      const field = map2.field();
      if (typeof json != "object" || Array.isArray(json)) {
        throw new error_js_1.FieldError(field, "expected object, got " + (0, reflect_check_js_1.formatVal)(json));
      }
      for (const [jsonMapKey, jsonMapValue] of Object.entries(json)) {
        if (jsonMapValue === null) {
          throw new error_js_1.FieldError(field, "map value must not be null");
        }
        let value;
        switch (field.mapKind) {
          case "message":
            const msgValue = (0, reflect_js_1.reflect)(field.message);
            readMessage(msgValue, jsonMapValue, opts);
            value = msgValue;
            break;
          case "enum":
            value = readEnum(field.enum, jsonMapValue, opts.ignoreUnknownFields, true);
            if (value === tokenIgnoredUnknownEnum) {
              return;
            }
            break;
          case "scalar":
            value = scalarFromJson(field, jsonMapValue, true);
            break;
        }
        const key = mapKeyFromJson(field.mapKey, jsonMapKey);
        map2.set(key, value);
      }
    }
    function readListField(list, json, opts) {
      if (json === null) {
        return;
      }
      const field = list.field();
      if (!Array.isArray(json)) {
        throw new error_js_1.FieldError(field, "expected Array, got " + (0, reflect_check_js_1.formatVal)(json));
      }
      for (const jsonItem of json) {
        if (jsonItem === null) {
          throw new error_js_1.FieldError(field, "list item must not be null");
        }
        switch (field.listKind) {
          case "message":
            const msgValue = (0, reflect_js_1.reflect)(field.message);
            readMessage(msgValue, jsonItem, opts);
            list.add(msgValue);
            break;
          case "enum":
            const enumValue = readEnum(field.enum, jsonItem, opts.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              list.add(enumValue);
            }
            break;
          case "scalar":
            list.add(scalarFromJson(field, jsonItem, true));
            break;
        }
      }
    }
    function readMessageField(msg, field, json, opts) {
      if (json === null && field.message.typeName != "google.protobuf.Value") {
        msg.clear(field);
        return;
      }
      const msgValue = msg.isSet(field) ? msg.get(field) : (0, reflect_js_1.reflect)(field.message);
      readMessage(msgValue, json, opts);
      msg.set(field, msgValue);
    }
    function readEnumField(msg, field, json, opts) {
      const enumValue = readEnum(field.enum, json, opts.ignoreUnknownFields, false);
      if (enumValue === tokenNull) {
        msg.clear(field);
      } else if (enumValue !== tokenIgnoredUnknownEnum) {
        msg.set(field, enumValue);
      }
    }
    function readScalarField(msg, field, json) {
      const scalarValue = scalarFromJson(field, json, false);
      if (scalarValue === tokenNull) {
        msg.clear(field);
      } else {
        msg.set(field, scalarValue);
      }
    }
    var tokenIgnoredUnknownEnum = Symbol();
    function readEnum(desc, json, ignoreUnknownFields, nullAsZeroValue) {
      if (json === null) {
        if (desc.typeName == "google.protobuf.NullValue") {
          return 0;
        }
        return nullAsZeroValue ? desc.values[0].number : tokenNull;
      }
      switch (typeof json) {
        case "number":
          if (Number.isInteger(json)) {
            return json;
          }
          break;
        case "string":
          const value = desc.values.find((ev) => ev.name === json);
          if (value !== void 0) {
            return value.number;
          }
          if (ignoreUnknownFields) {
            return tokenIgnoredUnknownEnum;
          }
          break;
      }
      throw new Error(`cannot decode ${desc} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    var tokenNull = Symbol();
    function scalarFromJson(field, json, nullAsZeroValue) {
      if (json === null) {
        if (nullAsZeroValue) {
          return (0, scalar_js_1.scalarZeroValue)(field.scalar, false);
        }
        return tokenNull;
      }
      switch (field.scalar) {
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FLOAT:
          if (json === "NaN")
            return NaN;
          if (json === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (typeof json == "number") {
            if (isNaN(json)) {
              throw new error_js_1.FieldError(field, "unexpected NaN number");
            }
            if (!isFinite(json)) {
              throw new error_js_1.FieldError(field, "unexpected infinite number");
            }
            break;
          }
          if (typeof json == "string") {
            if (json === "") {
              break;
            }
            if (json.trim().length !== json.length) {
              break;
            }
            const float = Number(json);
            if (!isFinite(float)) {
              break;
            }
            return float;
          }
          break;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
        case descriptors_js_1.ScalarType.UINT32:
          return int32FromJson(json);
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case descriptors_js_1.ScalarType.BYTES:
          if (typeof json == "string") {
            if (json === "") {
              return new Uint8Array(0);
            }
            try {
              return (0, base64_encoding_js_1.base64Decode)(json);
            } catch (e) {
              const message = e instanceof Error ? e.message : String(e);
              throw new error_js_1.FieldError(field, message);
            }
          }
          break;
      }
      return json;
    }
    function mapKeyFromJson(type, json) {
      switch (type) {
        case descriptors_js_1.ScalarType.BOOL:
          switch (json) {
            case "true":
              return true;
            case "false":
              return false;
          }
          return json;
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
          return int32FromJson(json);
        default:
          return json;
      }
    }
    function int32FromJson(json) {
      if (typeof json == "string") {
        if (json === "") {
          return json;
        }
        if (json.trim().length !== json.length) {
          return json;
        }
        const num = Number(json);
        if (Number.isNaN(num)) {
          return json;
        }
        return num;
      }
      return json;
    }
    function parseJsonString(jsonString, typeName) {
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        throw new Error(
          `cannot decode message ${typeName} from JSON: ${message}`,
          // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
          { cause: e }
        );
      }
    }
    function tryWktFromJson(msg, jsonValue, opts) {
      if (!msg.desc.typeName.startsWith("google.protobuf.")) {
        return false;
      }
      switch (msg.desc.typeName) {
        case "google.protobuf.Any":
          anyFromJson(msg.message, jsonValue, opts);
          return true;
        case "google.protobuf.Timestamp":
          timestampFromJson(msg.message, jsonValue);
          return true;
        case "google.protobuf.Duration":
          durationFromJson(msg.message, jsonValue);
          return true;
        case "google.protobuf.FieldMask":
          fieldMaskFromJson(msg.message, jsonValue);
          return true;
        case "google.protobuf.Struct":
          structFromJson(msg.message, jsonValue);
          return true;
        case "google.protobuf.Value":
          valueFromJson(msg.message, jsonValue);
          return true;
        case "google.protobuf.ListValue":
          listValueFromJson(msg.message, jsonValue);
          return true;
        default:
          if ((0, index_js_1.isWrapperDesc)(msg.desc)) {
            const valueField = msg.desc.fields[0];
            if (jsonValue === null) {
              msg.clear(valueField);
            } else {
              msg.set(valueField, scalarFromJson(valueField, jsonValue, true));
            }
            return true;
          }
          return false;
      }
    }
    function anyFromJson(any, json, opts) {
      var _a;
      if (json === null || Array.isArray(json) || typeof json != "object") {
        throw new Error(`cannot decode message ${any.$typeName} from JSON: expected object but got ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      if (Object.keys(json).length == 0) {
        return;
      }
      const typeUrl = json["@type"];
      if (typeof typeUrl != "string" || typeUrl == "") {
        throw new Error(`cannot decode message ${any.$typeName} from JSON: "@type" is empty`);
      }
      const typeName = typeUrl.includes("/") ? typeUrl.substring(typeUrl.lastIndexOf("/") + 1) : typeUrl;
      if (!typeName.length) {
        throw new Error(`cannot decode message ${any.$typeName} from JSON: "@type" is invalid`);
      }
      const desc = (_a = opts.registry) === null || _a === void 0 ? void 0 : _a.getMessage(typeName);
      if (!desc) {
        throw new Error(`cannot decode message ${any.$typeName} from JSON: ${typeUrl} is not in the type registry`);
      }
      const msg = (0, reflect_js_1.reflect)(desc);
      if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
        const value = json["value"];
        readMessage(msg, value, opts);
      } else {
        const copy = Object.assign({}, json);
        delete copy["@type"];
        readMessage(msg, copy, opts);
      }
      (0, index_js_1.anyPack)(msg.desc, msg.message, any);
    }
    function timestampFromJson(timestamp, json) {
      if (typeof json !== "string") {
        throw new Error(`cannot decode message ${timestamp.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches) {
        throw new Error(`cannot decode message ${timestamp.$typeName} from JSON: invalid RFC 3339 string`);
      }
      const ms = Date.parse(
        //prettier-ignore
        matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z")
      );
      if (Number.isNaN(ms)) {
        throw new Error(`cannot decode message ${timestamp.$typeName} from JSON: invalid RFC 3339 string`);
      }
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error(`cannot decode message ${timestamp.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
      }
      timestamp.seconds = proto_int64_js_1.protoInt64.parse(ms / 1e3);
      timestamp.nanos = 0;
      if (matches[7]) {
        timestamp.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
      }
    }
    function durationFromJson(duration, json) {
      if (typeof json !== "string") {
        throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      const match = json.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
      if (match === null) {
        throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      const longSeconds = Number(match[1]);
      if (longSeconds > 315576e6 || longSeconds < -315576e6) {
        throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      duration.seconds = proto_int64_js_1.protoInt64.parse(longSeconds);
      if (typeof match[2] !== "string") {
        return;
      }
      const nanosStr = match[2] + "0".repeat(9 - match[2].length);
      duration.nanos = parseInt(nanosStr);
      if (longSeconds < 0 || Object.is(longSeconds, -0)) {
        duration.nanos = -duration.nanos;
      }
    }
    function fieldMaskFromJson(fieldMask, json) {
      if (typeof json !== "string") {
        throw new Error(`cannot decode message ${fieldMask.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      if (json === "") {
        return;
      }
      function camelToSnake(str) {
        if (str.includes("_")) {
          throw new Error(`cannot decode message ${fieldMask.$typeName} from JSON: path names must be lowerCamelCase`);
        }
        const sc = str.replace(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
        return sc[0] === "_" ? sc.substring(1) : sc;
      }
      fieldMask.paths = json.split(",").map(camelToSnake);
    }
    function structFromJson(struct, json) {
      if (typeof json != "object" || json == null || Array.isArray(json)) {
        throw new Error(`cannot decode message ${struct.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      for (const [k, v] of Object.entries(json)) {
        const parsedV = (0, create_js_1.create)(index_js_1.ValueSchema);
        valueFromJson(parsedV, v);
        struct.fields[k] = parsedV;
      }
    }
    function valueFromJson(value, json) {
      switch (typeof json) {
        case "number":
          value.kind = { case: "numberValue", value: json };
          break;
        case "string":
          value.kind = { case: "stringValue", value: json };
          break;
        case "boolean":
          value.kind = { case: "boolValue", value: json };
          break;
        case "object":
          if (json === null) {
            value.kind = { case: "nullValue", value: index_js_1.NullValue.NULL_VALUE };
          } else if (Array.isArray(json)) {
            const listValue = (0, create_js_1.create)(index_js_1.ListValueSchema);
            listValueFromJson(listValue, json);
            value.kind = { case: "listValue", value: listValue };
          } else {
            const struct = (0, create_js_1.create)(index_js_1.StructSchema);
            structFromJson(struct, json);
            value.kind = { case: "structValue", value: struct };
          }
          break;
        default:
          throw new Error(`cannot decode message ${value.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      return value;
    }
    function listValueFromJson(listValue, json) {
      if (!Array.isArray(json)) {
        throw new Error(`cannot decode message ${listValue.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
      }
      for (const e of json) {
        const value = (0, create_js_1.create)(index_js_1.ValueSchema);
        valueFromJson(value, e);
        listValue.values.push(value);
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOption = exports.hasOption = exports.clearExtension = exports.setExtension = exports.getExtension = exports.hasExtension = exports.mergeFromBinary = exports.fromBinary = exports.toBinary = void 0;
    __exportStar(require_types3(), exports);
    __exportStar(require_is_message(), exports);
    __exportStar(require_create(), exports);
    __exportStar(require_clone(), exports);
    __exportStar(require_descriptors(), exports);
    __exportStar(require_equals(), exports);
    __exportStar(require_fields(), exports);
    __exportStar(require_registry(), exports);
    var to_binary_js_1 = require_to_binary();
    Object.defineProperty(exports, "toBinary", { enumerable: true, get: function() {
      return to_binary_js_1.toBinary;
    } });
    var from_binary_js_1 = require_from_binary();
    Object.defineProperty(exports, "fromBinary", { enumerable: true, get: function() {
      return from_binary_js_1.fromBinary;
    } });
    Object.defineProperty(exports, "mergeFromBinary", { enumerable: true, get: function() {
      return from_binary_js_1.mergeFromBinary;
    } });
    __exportStar(require_to_json(), exports);
    __exportStar(require_from_json(), exports);
    var extensions_js_1 = require_extensions();
    Object.defineProperty(exports, "hasExtension", { enumerable: true, get: function() {
      return extensions_js_1.hasExtension;
    } });
    Object.defineProperty(exports, "getExtension", { enumerable: true, get: function() {
      return extensions_js_1.getExtension;
    } });
    Object.defineProperty(exports, "setExtension", { enumerable: true, get: function() {
      return extensions_js_1.setExtension;
    } });
    Object.defineProperty(exports, "clearExtension", { enumerable: true, get: function() {
      return extensions_js_1.clearExtension;
    } });
    Object.defineProperty(exports, "hasOption", { enumerable: true, get: function() {
      return extensions_js_1.hasOption;
    } });
    Object.defineProperty(exports, "getOption", { enumerable: true, get: function() {
      return extensions_js_1.getOption;
    } });
    __exportStar(require_proto_int64(), exports);
  }
});

// node_modules/sass-embedded/dist/lib/src/request-tracker.js
var require_request_tracker = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/request-tracker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestTracker = void 0;
    var RequestTracker = class {
      constructor() {
        // The indices of this array correspond to each pending request's ID. Stores
        // the response type expected by each request.
        __publicField(this, "requests", []);
      }
      /** The next available request ID. */
      get nextId() {
        for (let i = 0; i < this.requests.length; i++) {
          if (this.requests[i] === void 0 || this.requests[i] === null) {
            return i;
          }
        }
        return this.requests.length;
      }
      /**
       * Adds an entry for a pending request with ID `id`. The entry stores the
       * expected response type. Throws an error if the Protocol Error is violated.
       */
      add(id, expectedResponseType) {
        if (id < 0) {
          throw Error(`Invalid request ID ${id}.`);
        } else if (this.requests[id]) {
          throw Error(`Request ID ${id} is already in use by an in-flight request.`);
        }
        this.requests[id] = expectedResponseType;
      }
      /**
       * Resolves a pending request with matching ID `id` and expected response type
       * `type`. Throws an error if the Protocol Error is violated.
       */
      resolve(id, type) {
        if (this.requests[id] === void 0 || this.requests[id] === null) {
          throw Error(`Response ID ${id} does not match any pending requests.`);
        } else if (this.requests[id] !== type) {
          throw Error(`Response with ID ${id} does not match pending request's type. Expected ${this.requests[id]} but received ${type}.`);
        }
        this.requests[id] = null;
      }
    };
    exports.RequestTracker = RequestTracker;
  }
});

// node_modules/sass-embedded/dist/lib/src/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/dispatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dispatcher = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var protobuf_1 = require_cjs2();
    var proto = require_embedded_sass_pb();
    var request_tracker_1 = require_request_tracker();
    var utils_1 = require_utils();
    var Dispatcher = class {
      constructor(compilationId, outboundMessages$, writeInboundMessage, outboundRequestHandlers) {
        __publicField(this, "compilationId");
        __publicField(this, "outboundMessages$");
        __publicField(this, "writeInboundMessage");
        __publicField(this, "outboundRequestHandlers");
        // Tracks the IDs of all outbound requests. An inbound response with matching
        // ID and type will remove the ID.
        __publicField(this, "pendingOutboundRequests", new request_tracker_1.RequestTracker());
        // All outbound messages for this compilation. If we detect any errors while
        // dispatching messages, this completes.
        __publicField(this, "messages$", new rxjs_1.Subject());
        // Subject to unsubscribe from all outbound messages to prevent past
        // dispatchers with compilation IDs reused by future dispatchers from
        // receiving messages intended for future dispatchers.
        __publicField(this, "unsubscribe$", new rxjs_1.Subject());
        // If the dispatcher encounters an error, this errors out. It is publicly
        // exposed as a readonly Observable.
        __publicField(this, "errorInternal$", new rxjs_1.Subject());
        /**
         * If the dispatcher encounters an error, this errors out. Upon error, the
         * dispatcher rejects all promises awaiting an outbound response, and silently
         * closes all subscriptions to outbound events.
         */
        __publicField(this, "error$", this.errorInternal$.pipe());
        /**
         * Outbound log events. If an error occurs, the dispatcher closes this
         * silently.
         */
        __publicField(this, "logEvents$", this.messages$.pipe((0, operators_1.filter)((message) => message.message.case === "logEvent"), (0, operators_1.map)((message) => message.message.value)));
        this.compilationId = compilationId;
        this.outboundMessages$ = outboundMessages$;
        this.writeInboundMessage = writeInboundMessage;
        this.outboundRequestHandlers = outboundRequestHandlers;
        if (compilationId < 1) {
          throw Error(`Invalid compilation ID ${compilationId}.`);
        }
        this.outboundMessages$.pipe((0, operators_1.filter)(([compilationId2]) => compilationId2 === this.compilationId), (0, operators_1.map)(([, message]) => message), (0, operators_1.mergeMap)((message) => {
          const result = this.handleOutboundMessage(message);
          return result instanceof Promise ? result.then(() => message) : [message];
        }), (0, operators_1.takeUntil)(this.unsubscribe$)).subscribe({
          next: (message) => this.messages$.next(message),
          error: (error) => this.throwAndClose(error),
          complete: () => {
            this.messages$.complete();
            this.errorInternal$.complete();
          }
        });
      }
      /**
       * Sends a CompileRequest inbound. Passes the corresponding outbound
       * CompileResponse or an error to `callback` and unsubscribes from all
       * outbound events.
       *
       * This uses an old-style callback argument so that it can work either
       * synchronously or asynchronously. If the underlying stdout stream emits
       * events synchronously, `callback` will be called synchronously.
       */
      sendCompileRequest(request, callback) {
        const callback_ = (err, response) => {
          this.unsubscribe();
          return callback(err, response);
        };
        if (this.messages$.isStopped) {
          callback_(new Error("Tried writing to closed dispatcher"), void 0);
          return;
        }
        this.messages$.pipe((0, operators_1.filter)((message) => message.message.case === "compileResponse"), (0, operators_1.map)((message) => message.message.value)).subscribe({ next: (response) => callback_(null, response) });
        this.error$.subscribe({
          error: (error) => callback_(error, void 0)
        });
        try {
          this.writeInboundMessage([
            this.compilationId,
            (0, protobuf_1.create)(proto.InboundMessageSchema, {
              message: { value: request, case: "compileRequest" }
            })
          ]);
        } catch (error) {
          this.throwAndClose(error);
        }
      }
      // Stop the outbound message subscription.
      unsubscribe() {
        this.unsubscribe$.next(void 0);
        this.unsubscribe$.complete();
      }
      // Rejects with `error` all promises awaiting an outbound response, and
      // silently closes all subscriptions awaiting outbound events.
      throwAndClose(error) {
        this.messages$.complete();
        this.errorInternal$.error(error);
        this.unsubscribe();
      }
      // Keeps track of all outbound messages. If the outbound `message` contains a
      // request or response, registers it with pendingOutboundRequests. If it
      // contains a request, runs the appropriate callback to generate an inbound
      // response, and then sends it inbound.
      handleOutboundMessage(message) {
        switch (message.message.case) {
          case "logEvent":
            return void 0;
          case "compileResponse":
            return void 0;
          case "importRequest": {
            const request = message.message.value;
            const id = request.id;
            const type = "importResponse";
            this.pendingOutboundRequests.add(id, type);
            return (0, utils_1.thenOr)(this.outboundRequestHandlers.handleImportRequest(request), (response) => {
              this.sendInboundMessage(id, { case: type, value: response });
            });
          }
          case "fileImportRequest": {
            const request = message.message.value;
            const id = request.id;
            const type = "fileImportResponse";
            this.pendingOutboundRequests.add(id, type);
            return (0, utils_1.thenOr)(this.outboundRequestHandlers.handleFileImportRequest(request), (response) => {
              this.sendInboundMessage(id, { case: type, value: response });
            });
          }
          case "canonicalizeRequest": {
            const request = message.message.value;
            const id = request.id;
            const type = "canonicalizeResponse";
            this.pendingOutboundRequests.add(id, type);
            return (0, utils_1.thenOr)(this.outboundRequestHandlers.handleCanonicalizeRequest(request), (response) => {
              this.sendInboundMessage(id, { case: type, value: response });
            });
          }
          case "functionCallRequest": {
            const request = message.message.value;
            const id = request.id;
            const type = "functionCallResponse";
            this.pendingOutboundRequests.add(id, type);
            return (0, utils_1.thenOr)(this.outboundRequestHandlers.handleFunctionCallRequest(request), (response) => {
              this.sendInboundMessage(id, { case: type, value: response });
            });
          }
          case "error":
            throw (0, utils_1.hostError)(message.message.value.message);
          default:
            throw (0, utils_1.compilerError)(`Unknown message type ${message.message.case}`);
        }
      }
      // Sends a message inbound. Keeps track of all pending inbound requests.
      sendInboundMessage(requestId, message) {
        message.value.id = requestId;
        if (message.case === "importResponse" || message.case === "fileImportResponse" || message.case === "canonicalizeResponse" || message.case === "functionCallResponse") {
          this.pendingOutboundRequests.resolve(requestId, message.case);
        } else {
          throw Error(`Unknown message type ${message.case}`);
        }
        this.writeInboundMessage([
          this.compilationId,
          (0, protobuf_1.create)(proto.InboundMessageSchema, { message })
        ]);
      }
    };
    exports.Dispatcher = Dispatcher;
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/resolve-path.js
var require_resolve_path = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/resolve-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolvePath = resolvePath;
    var fs = require_fs();
    var p = require_path();
    function resolvePath(path, fromImport) {
      const extension = p.extname(path);
      if (extension === ".sass" || extension === ".scss" || extension === ".css") {
        return (fromImport ? exactlyOne(tryPath(`${withoutExtension(path)}.import${extension}`)) : null) ?? exactlyOne(tryPath(path));
      }
      return (fromImport ? exactlyOne(tryPathWithExtensions(`${path}.import`)) : null) ?? exactlyOne(tryPathWithExtensions(path)) ?? tryPathAsDirectory(path, fromImport);
    }
    function tryPathWithExtensions(path) {
      const result = [...tryPath(path + ".sass"), ...tryPath(path + ".scss")];
      return result.length > 0 ? result : tryPath(path + ".css");
    }
    function tryPath(path) {
      const partial = p.join(p.dirname(path), `_${p.basename(path)}`);
      const result = [];
      if (fileExists(partial))
        result.push(partial);
      if (fileExists(path))
        result.push(path);
      return result;
    }
    function tryPathAsDirectory(path, fromImport) {
      if (!dirExists(path))
        return null;
      return (fromImport ? exactlyOne(tryPathWithExtensions(p.join(path, "index.import"))) : null) ?? exactlyOne(tryPathWithExtensions(p.join(path, "index")));
    }
    function exactlyOne(paths) {
      if (paths.length === 0)
        return null;
      if (paths.length === 1)
        return paths[0];
      throw new Error("It's not clear which file to import. Found:\n" + paths.map((path) => "  " + path).join("\n"));
    }
    function fileExists(path) {
      if (!fs.existsSync(path))
        return false;
      try {
        return fs.statSync(path).isFile();
      } catch (error) {
        if (error.code === "ENOENT")
          return false;
        throw error;
      }
    }
    function dirExists(path) {
      if (!fs.existsSync(path))
        return false;
      try {
        return fs.statSync(path).isDirectory();
      } catch (error) {
        if (error.code === "ENOENT")
          return false;
        throw error;
      }
    }
    function withoutExtension(path) {
      const extension = p.extname(path);
      return path.substring(0, path.length - extension.length);
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/importer.js
var require_importer = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/importer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyImporterWrapper = exports.metaNamespace = exports.legacyImporterFileProtocol = exports.endOfLoadProtocol = void 0;
    var assert_1 = require_assert();
    var fs = require_fs();
    var p = require_path();
    var util = require_util();
    var resolve_path_1 = require_resolve_path();
    var utils_1 = require_utils();
    var utils_2 = require_utils3();
    exports.endOfLoadProtocol = "sass-embedded-legacy-load-done:";
    exports.legacyImporterFileProtocol = "legacy-importer-file:";
    exports.metaNamespace = `---${Math.random().toString(36).substring(2)}`;
    var endOfLoadCount = 0;
    var LegacyImporterWrapper = class {
      constructor(self, callbacks, loadPaths, initialPrev, sync) {
        __publicField(this, "self");
        __publicField(this, "callbacks");
        __publicField(this, "loadPaths");
        __publicField(this, "sync");
        // A stack of previous URLs passed to `this.callbacks`.
        __publicField(this, "prev", []);
        // The `contents` field returned by the last successful invocation of
        // `this.callbacks`, if it returned one.
        __publicField(this, "lastContents");
        this.self = self;
        this.callbacks = callbacks;
        this.loadPaths = loadPaths;
        this.sync = sync;
        const path = initialPrev !== "stdin";
        this.prev.push({ url: path ? p.resolve(initialPrev) : "stdin", path });
      }
      canonicalize(url, options) {
        if (url.startsWith(exports.endOfLoadProtocol))
          return new URL(url);
        if (options.containingUrl !== null) {
          try {
            const absoluteUrl = new URL(url, options.containingUrl).toString();
            const resolved = this.canonicalize(absoluteUrl, {
              fromImport: options.fromImport,
              containingUrl: null
            });
            if (resolved !== null)
              return resolved;
          } catch (error) {
            if (error instanceof TypeError && (0, utils_1.isErrnoException)(error) && error.code === "ERR_INVALID_URL") {
            } else {
              throw error;
            }
          }
        }
        if (url.startsWith(utils_2.legacyImporterProtocolPrefix) || url.startsWith(utils_2.legacyImporterProtocol)) {
          const urlWithoutPrefix = url.substring(utils_2.legacyImporterProtocolPrefix.length);
          if (urlWithoutPrefix.startsWith("file:")) {
            let resolved = null;
            try {
              const path = (0, utils_1.fileUrlToPathCrossPlatform)(urlWithoutPrefix);
              resolved = (0, resolve_path_1.resolvePath)(path, options.fromImport);
            } catch (error) {
              if (error instanceof TypeError && (0, utils_1.isErrnoException)(error) && (error.code === "ERR_INVALID_URL" || error.code === "ERR_INVALID_FILE_URL_PATH")) {
              } else {
                throw error;
              }
            }
            if (resolved !== null) {
              this.prev.push({ url: resolved, path: true });
              return (0, utils_2.pathToLegacyFileUrl)(resolved);
            }
          }
          return null;
        }
        const prev = this.prev[this.prev.length - 1];
        return (0, utils_1.thenOr)((0, utils_1.thenOr)(this.invokeCallbacks(url, prev.url, options), (result) => {
          if (result instanceof Error)
            throw result;
          if (result === null)
            return null;
          if (typeof result !== "object") {
            throw `Expected importer to return an object, got ${util.inspect(result)}.`;
          }
          if ("contents" in result || !("file" in result)) {
            this.lastContents = result.contents ?? "";
            if ("file" in result) {
              return new URL(utils_2.legacyImporterProtocol + encodeURI(result.file));
            } else if (/^[A-Za-z+.-]+:/.test(url)) {
              return new URL(`${utils_2.legacyImporterProtocolPrefix}${url}`);
            } else {
              return new URL(utils_2.legacyImporterProtocol + encodeURI(url));
            }
          } else {
            if (p.isAbsolute(result.file)) {
              const resolved = (0, resolve_path_1.resolvePath)(result.file, options.fromImport);
              return resolved ? (0, utils_2.pathToLegacyFileUrl)(resolved) : null;
            }
            const prefixes = [...this.loadPaths, "."];
            if (prev.path)
              prefixes.unshift(p.dirname(prev.url));
            for (const prefix of prefixes) {
              const resolved = (0, resolve_path_1.resolvePath)(p.join(prefix, result.file), options.fromImport);
              if (resolved !== null)
                return (0, utils_2.pathToLegacyFileUrl)(resolved);
            }
            return null;
          }
        }), (result) => {
          if (result !== null) {
            const path = result.protocol === exports.legacyImporterFileProtocol;
            this.prev.push({
              url: path ? (0, utils_2.legacyFileUrlToPath)(result) : url,
              path
            });
            return result;
          } else {
            for (const loadPath of this.loadPaths) {
              const resolved = (0, resolve_path_1.resolvePath)(p.join(loadPath, url), options.fromImport);
              if (resolved !== null)
                return (0, utils_2.pathToLegacyFileUrl)(resolved);
            }
            return null;
          }
        });
      }
      load(canonicalUrl) {
        if (canonicalUrl.protocol === exports.endOfLoadProtocol) {
          this.prev.pop();
          return {
            contents: "",
            syntax: "scss",
            sourceMapUrl: new URL(exports.endOfLoadProtocol)
          };
        }
        if (canonicalUrl.protocol === exports.legacyImporterFileProtocol) {
          const syntax = canonicalUrl.pathname.endsWith(".sass") ? "indented" : canonicalUrl.pathname.endsWith(".css") ? "css" : "scss";
          let contents = this.lastContents ?? fs.readFileSync((0, utils_2.legacyFileUrlToPath)(canonicalUrl), "utf-8");
          this.lastContents = void 0;
          if (syntax === "css") {
            this.prev.pop();
          } else {
            contents = this.wrapContents(contents, syntax);
          }
          return { contents, syntax, sourceMapUrl: canonicalUrl };
        }
        const lastContents = this.lastContents;
        assert_1.strict.notEqual(lastContents, void 0);
        this.lastContents = void 0;
        return {
          contents: this.wrapContents(lastContents, "scss"),
          syntax: "scss",
          sourceMapUrl: canonicalUrl
        };
      }
      // Invokes each callback in `this.callbacks` until one returns a non-null
      // `LegacyImporterResult`, then returns that result. Returns `null` if all
      // callbacks return `null`.
      invokeCallbacks(url, prev, { fromImport }) {
        (0, assert_1.strict)(this.callbacks.length > 0);
        const self = { ...this.self, fromImport };
        self.options = { ...self.options, context: self };
        const invokeNthCallback = (n) => (0, utils_1.thenOr)(this.invokeCallback(this.callbacks[n], self, url, prev), (result) => {
          if (result === null) {
            if (n === this.callbacks.length - 1)
              return null;
            return invokeNthCallback(n + 1);
          }
          if ("contents" in result && result.contents && typeof result.contents !== "string") {
            throw new Error(`Invalid argument (contents): must be a string but was: ${result.contents.constructor.name}`);
          }
          return result;
        });
        return invokeNthCallback(0);
      }
      // Invokes `callback` and converts its return value into a `PromiseOr`.
      invokeCallback(callback, self, url, prev) {
        if (this.sync) {
          return callback.call(self, url, prev);
        }
        return new Promise((resolve) => {
          const syncResult = callback.call(self, url, prev, resolve);
          if (syncResult !== void 0)
            resolve(syncResult);
        });
      }
      // Modifies {@link contents} to ensure that we know when a load has completed
      // so we can pass the correct `prev` argument to callbacks.
      wrapContents(contents, syntax) {
        const url = `"${exports.endOfLoadProtocol}${endOfLoadCount++}"`;
        if (syntax === "scss") {
          return `@use "sass:meta" as ${exports.metaNamespace};` + contents + `
;@include ${exports.metaNamespace}.load-css(${url});`;
        } else {
          return `@use "sass:meta" as ${exports.metaNamespace}
` + contents + `
@include ${exports.metaNamespace}.load-css(${url})`;
        }
      }
    };
    exports.LegacyImporterWrapper = LegacyImporterWrapper;
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/utils.js
var require_utils3 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.legacyImporterProtocolPrefix = exports.legacyImporterProtocol = void 0;
    exports.removeLegacyImporter = removeLegacyImporter;
    exports.removeLegacyImporterFromSpan = removeLegacyImporterFromSpan;
    exports.pathToLegacyFileUrl = pathToLegacyFileUrl;
    exports.legacyFileUrlToPath = legacyFileUrlToPath;
    var assert_1 = require_assert();
    var url_1 = require_url();
    var utils_1 = require_utils();
    var importer_1 = require_importer();
    exports.legacyImporterProtocol = "legacy-importer:";
    exports.legacyImporterProtocolPrefix = "legacy-importer-";
    var removeLegacyImporterRegExp = new RegExp(`${exports.legacyImporterProtocol}|${exports.legacyImporterProtocolPrefix}`, "g");
    function removeLegacyImporter(string) {
      return string.replace(removeLegacyImporterRegExp, "");
    }
    function removeLegacyImporterFromSpan(span) {
      if (!span.url)
        return span;
      return {
        ...span,
        url: new URL(removeLegacyImporter(span.url.toString()), (0, url_1.pathToFileURL)(process.cwd()))
      };
    }
    function pathToLegacyFileUrl(path) {
      return new URL(`${exports.legacyImporterProtocolPrefix}${(0, url_1.pathToFileURL)(path)}`);
    }
    function legacyFileUrlToPath(url) {
      assert_1.strict.equal(url.protocol, importer_1.legacyImporterFileProtocol);
      const originalUrl = url.toString().substring(exports.legacyImporterProtocolPrefix.length);
      return (0, utils_1.fileUrlToPathCrossPlatform)(originalUrl);
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/logger.js
var require_logger = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = void 0;
    exports.Logger = {
      silent: { warn() {
      }, debug() {
      } }
    };
  }
});

// node_modules/sass-embedded/dist/lib/src/compiler/utils.js
var require_utils4 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/compiler/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDispatcher = createDispatcher;
    exports.newCompilePathRequest = newCompilePathRequest;
    exports.newCompileStringRequest = newCompileStringRequest;
    exports.handleLogEvent = handleLogEvent;
    exports.handleCompileResponse = handleCompileResponse;
    var p = require_path();
    var supportsColor = require_browser();
    var protobuf_1 = require_cjs2();
    var deprecations_1 = require_deprecations2();
    var deprotofy_span_1 = require_deprotofy_span();
    var dispatcher_1 = require_dispatcher();
    var exception_1 = require_exception();
    var utils_1 = require_utils3();
    var logger_1 = require_logger();
    var utils = require_utils();
    var proto = require_embedded_sass_pb();
    function createDispatcher(compilationId, messageTransformer, handlers) {
      return new dispatcher_1.Dispatcher(compilationId, messageTransformer.outboundMessages$, (message) => messageTransformer.writeInboundMessage(message), handlers);
    }
    function newCompileRequest(importers, options) {
      const request = (0, protobuf_1.create)(proto.InboundMessage_CompileRequestSchema, {
        importers: importers.importers,
        globalFunctions: Object.keys((options == null ? void 0 : options.functions) ?? {}),
        sourceMap: !!(options == null ? void 0 : options.sourceMap),
        sourceMapIncludeSources: !!(options == null ? void 0 : options.sourceMapIncludeSources),
        alertColor: (options == null ? void 0 : options.alertColor) ?? !!supportsColor.stdout,
        alertAscii: !!(options == null ? void 0 : options.alertAscii),
        quietDeps: !!(options == null ? void 0 : options.quietDeps),
        verbose: !!(options == null ? void 0 : options.verbose),
        charset: !!((options == null ? void 0 : options.charset) ?? true),
        silent: (options == null ? void 0 : options.logger) === logger_1.Logger.silent,
        fatalDeprecation: (0, deprecations_1.getDeprecationIds)((options == null ? void 0 : options.fatalDeprecations) ?? []),
        silenceDeprecation: (0, deprecations_1.getDeprecationIds)((options == null ? void 0 : options.silenceDeprecations) ?? []),
        futureDeprecation: (0, deprecations_1.getDeprecationIds)((options == null ? void 0 : options.futureDeprecations) ?? [])
      });
      switch ((options == null ? void 0 : options.style) ?? "expanded") {
        case "expanded":
          request.style = proto.OutputStyle.EXPANDED;
          break;
        case "compressed":
          request.style = proto.OutputStyle.COMPRESSED;
          break;
        default:
          throw new Error(`Unknown options.style: "${options == null ? void 0 : options.style}"`);
      }
      return request;
    }
    function newCompilePathRequest(path, importers, options) {
      const absPath = p.resolve(path);
      const request = newCompileRequest(importers, options);
      request.input = { case: "path", value: absPath };
      return request;
    }
    function newCompileStringRequest(source, importers, options) {
      var _a;
      const input = (0, protobuf_1.create)(proto.InboundMessage_CompileRequest_StringInputSchema, {
        source,
        syntax: utils.protofySyntax((options == null ? void 0 : options.syntax) ?? "scss")
      });
      const url = (_a = options == null ? void 0 : options.url) == null ? void 0 : _a.toString();
      if (url && url !== utils_1.legacyImporterProtocol) {
        input.url = url;
      }
      if (options && "importer" in options && options.importer) {
        input.importer = importers.register(options.importer);
      } else if (url === utils_1.legacyImporterProtocol) {
        input.importer = (0, protobuf_1.create)(proto.InboundMessage_CompileRequest_ImporterSchema, {
          importer: { case: "path", value: p.resolve(".") }
        });
      } else {
      }
      const request = newCompileRequest(importers, options);
      request.input = { case: "string", value: input };
      return request;
    }
    function validDeprecationId(id) {
      return !!id && id in deprecations_1.deprecations;
    }
    function handleLogEvent(options, event) {
      var _a, _b;
      let span = event.span ? (0, deprotofy_span_1.deprotofySourceSpan)(event.span) : null;
      if (span && (options == null ? void 0 : options.legacy))
        span = (0, utils_1.removeLegacyImporterFromSpan)(span);
      let message = event.message;
      if (options == null ? void 0 : options.legacy)
        message = (0, utils_1.removeLegacyImporter)(message);
      let formatted = event.formatted;
      if (options == null ? void 0 : options.legacy)
        formatted = (0, utils_1.removeLegacyImporter)(formatted);
      const deprecationType = validDeprecationId(event.deprecationType) ? deprecations_1.deprecations[event.deprecationType] : null;
      if (event.type === proto.LogEventType.DEBUG) {
        if ((_a = options == null ? void 0 : options.logger) == null ? void 0 : _a.debug) {
          options.logger.debug(message, {
            span
          });
        } else {
          console.error(formatted);
        }
      } else {
        if ((_b = options == null ? void 0 : options.logger) == null ? void 0 : _b.warn) {
          const params = deprecationType ? { deprecation: true, deprecationType } : { deprecation: false };
          if (span)
            params.span = span;
          const stack = event.stackTrace;
          if (stack) {
            params.stack = (options == null ? void 0 : options.legacy) ? (0, utils_1.removeLegacyImporter)(stack) : stack;
          }
          options.logger.warn(message, params);
        } else {
          console.error(formatted);
        }
      }
    }
    function handleCompileResponse(response) {
      if (response.result.case === "success") {
        const success = response.result.value;
        const result = {
          css: success.css,
          loadedUrls: response.loadedUrls.map((url) => new URL(url))
        };
        const sourceMap = success.sourceMap;
        if (sourceMap)
          result.sourceMap = JSON.parse(sourceMap);
        return result;
      } else if (response.result.case === "failure") {
        throw new exception_1.Exception(response.result.value);
      } else {
        throw utils.compilerError("Compiler sent empty CompileResponse.");
      }
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/elf.js
var require_elf = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/elf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElfInterpreter = getElfInterpreter;
    var fs = require_fs();
    function readFileDescriptor(fd, position, length) {
      const buffer = Buffer.alloc(length);
      let offset = 0;
      while (offset < length) {
        const bytesRead = fs.readSync(fd, buffer, {
          offset,
          position: position + offset
        });
        if (bytesRead === 0) {
          throw new Error(`failed to read fd ${fd}`);
        }
        offset += bytesRead;
      }
      return buffer;
    }
    function getElfInterpreter(path) {
      const fd = fs.openSync(path, "r");
      try {
        const elfIdentification = new DataView(readFileDescriptor(fd, 0, 64).buffer);
        if (elfIdentification.getUint8(0) !== 127 || elfIdentification.getUint8(1) !== 69 || elfIdentification.getUint8(2) !== 76 || elfIdentification.getUint8(3) !== 70) {
          throw new Error(`${path} is not an ELF file.`);
        }
        const elfIdentificationClass = elfIdentification.getUint8(4);
        if (elfIdentificationClass !== 1 && elfIdentificationClass !== 2) {
          throw new Error(`${path} has an invalid ELF class.`);
        }
        const elfClass32 = elfIdentificationClass === 1;
        const elfIdentificationData = elfIdentification.getUint8(5);
        if (elfIdentificationData !== 1 && elfIdentificationData !== 2) {
          throw new Error(`${path} has an invalid endianness.`);
        }
        const littleEndian = elfIdentificationData === 1;
        const programHeadersOffset = elfClass32 ? elfIdentification.getUint32(28, littleEndian) : Number(elfIdentification.getBigUint64(32, littleEndian));
        const programHeadersEntrySize = elfClass32 ? elfIdentification.getUint16(42, littleEndian) : elfIdentification.getUint16(54, littleEndian);
        const programHeadersEntryCount = elfClass32 ? elfIdentification.getUint16(44, littleEndian) : elfIdentification.getUint16(56, littleEndian);
        const programHeaders = new DataView(readFileDescriptor(fd, programHeadersOffset, programHeadersEntrySize * programHeadersEntryCount).buffer);
        for (let i = 0; i < programHeadersEntryCount; i++) {
          const byteOffset = i * programHeadersEntrySize;
          const segmentType = programHeaders.getUint32(byteOffset, littleEndian);
          if (segmentType !== 3)
            continue;
          const segmentOffset = elfClass32 ? programHeaders.getUint32(byteOffset + 4, littleEndian) : Number(programHeaders.getBigUint64(byteOffset + 8, littleEndian));
          const segmentFileSize = elfClass32 ? programHeaders.getUint32(byteOffset + 16, littleEndian) : Number(programHeaders.getBigUint64(byteOffset + 32, littleEndian));
          const buffer = readFileDescriptor(fd, segmentOffset, segmentFileSize);
          if (buffer[segmentFileSize - 1] !== 0) {
            throw new Error(`${path} is corrupted.`);
          }
          return buffer.toString("utf8", 0, segmentFileSize - 1);
        }
        throw new Error(`${path} does not contain an interpreter entry.`);
      } finally {
        fs.closeSync(fd);
      }
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/compiler-path.js
var require_compiler_path = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/compiler-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compilerCommand = void 0;
    var fs = require_fs();
    var p = require_path();
    var elf_1 = require_elf();
    var utils_1 = require_utils();
    function isLinuxMusl(path) {
      try {
        const interpreter = (0, elf_1.getElfInterpreter)(path);
        return p.basename(interpreter).startsWith("ld-musl-");
      } catch (error) {
        console.warn(`Warning: Failed to detect linux-musl, fallback to linux-gnu: ${error.message}`);
        return false;
      }
    }
    exports.compilerCommand = (() => {
      const platform = process.platform === "linux" && isLinuxMusl(process.execPath) ? "linux-musl" : process.platform;
      const arch = process.arch;
      for (const path of ["vendor", "../../../lib/src/vendor"]) {
        const executable = p.resolve(__dirname, path, `dart-sass/sass${platform === "win32" ? ".bat" : ""}`);
        if (fs.existsSync(executable))
          return [executable];
      }
      try {
        return [
          __require.resolve(`sass-embedded-${platform}-${arch}/dart-sass/src/dart` + (platform === "win32" ? ".exe" : "")),
          __require.resolve(`sass-embedded-${platform}-${arch}/dart-sass/src/sass.snapshot`)
        ];
      } catch (ignored) {
      }
      try {
        return [
          __require.resolve(`sass-embedded-${platform}-${arch}/dart-sass/sass` + (platform === "win32" ? ".bat" : ""))
        ];
      } catch (e) {
        if (!((0, utils_1.isErrnoException)(e) && e.code === "MODULE_NOT_FOUND")) {
          throw e;
        }
      }
      throw new Error(`Embedded Dart Sass couldn't find the embedded compiler executable. Please make sure the optional dependency sass-embedded-${platform}-${arch} is installed in node_modules.`);
    })();
  }
});

// node_modules/sass-embedded/dist/lib/src/protofier.js
var require_protofier = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/protofier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Protofier = void 0;
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    var protobuf_1 = require_cjs2();
    var proto = require_embedded_sass_pb();
    var utils = require_utils();
    var argument_list_1 = require_argument_list();
    var color_1 = require_color2();
    var function_1 = require_function();
    var list_1 = require_list();
    var map_1 = require_map();
    var number_1 = require_number();
    var string_1 = require_string();
    var null_1 = require_null();
    var boolean_1 = require_boolean();
    var calculations_1 = require_calculations();
    var mixin_1 = require_mixin();
    var Protofier = class {
      constructor(functions) {
        __publicField(this, "functions");
        /** All the argument lists returned by `deprotofy()`. */
        __publicField(this, "argumentLists", []);
        this.functions = functions;
      }
      /**
       * Returns IDs of all argument lists passed to `deprotofy()` whose keywords
       * have been accessed.
       */
      get accessedArgumentLists() {
        return this.argumentLists.filter((list) => list.keywordsAccessed).map((list) => list.id);
      }
      /** Converts `value` to its protocol buffer representation. */
      protofy(value) {
        const result = (0, protobuf_1.create)(proto.ValueSchema, {});
        if (value instanceof string_1.SassString) {
          const string = (0, protobuf_1.create)(proto.Value_StringSchema, {
            text: value.text,
            quoted: value.hasQuotes
          });
          result.value = { case: "string", value: string };
        } else if (value instanceof number_1.SassNumber) {
          result.value = { case: "number", value: this.protofyNumber(value) };
        } else if (value instanceof color_1.SassColor) {
          const channels = value.channelsOrNull;
          const color = (0, protobuf_1.create)(proto.Value_ColorSchema, {
            channel1: channels.get(0),
            channel2: channels.get(1),
            channel3: channels.get(2),
            alpha: value.isChannelMissing("alpha") ? void 0 : value.alpha,
            space: value.space
          });
          result.value = { case: "color", value: color };
        } else if (value instanceof list_1.SassList) {
          const list = (0, protobuf_1.create)(proto.Value_ListSchema, {
            separator: this.protofySeparator(value.separator),
            hasBrackets: value.hasBrackets,
            contents: value.asList.map((element) => this.protofy(element)).toArray()
          });
          result.value = { case: "list", value: list };
        } else if (value instanceof argument_list_1.SassArgumentList) {
          const list = (0, protobuf_1.create)(proto.Value_ArgumentListSchema, {
            id: value.id,
            separator: this.protofySeparator(value.separator),
            contents: value.asList.map((element) => this.protofy(element)).toArray()
          });
          for (const [key, mapValue] of value.keywordsInternal) {
            list.keywords[key] = this.protofy(mapValue);
          }
          result.value = { case: "argumentList", value: list };
        } else if (value instanceof map_1.SassMap) {
          const map2 = (0, protobuf_1.create)(proto.Value_MapSchema, {
            entries: value.contents.toArray().map(([key, value2]) => ({
              key: this.protofy(key),
              value: this.protofy(value2)
            }))
          });
          result.value = { case: "map", value: map2 };
        } else if (value instanceof function_1.SassFunction) {
          if (value.id !== void 0) {
            const fn = (0, protobuf_1.create)(proto.Value_CompilerFunctionSchema, value);
            result.value = { case: "compilerFunction", value: fn };
          } else {
            const fn = (0, protobuf_1.create)(proto.Value_HostFunctionSchema, {
              id: this.functions.register(value.callback),
              signature: value.signature
            });
            result.value = { case: "hostFunction", value: fn };
          }
        } else if (value instanceof mixin_1.SassMixin) {
          const mixin2 = (0, protobuf_1.create)(proto.Value_CompilerMixinSchema, value);
          result.value = { case: "compilerMixin", value: mixin2 };
        } else if (value instanceof calculations_1.SassCalculation) {
          result.value = {
            case: "calculation",
            value: this.protofyCalculation(value)
          };
        } else if (value === boolean_1.sassTrue) {
          result.value = { case: "singleton", value: proto.SingletonValue.TRUE };
        } else if (value === boolean_1.sassFalse) {
          result.value = { case: "singleton", value: proto.SingletonValue.FALSE };
        } else if (value === null_1.sassNull) {
          result.value = { case: "singleton", value: proto.SingletonValue.NULL };
        } else {
          throw utils.compilerError(`Unknown Value ${value}`);
        }
        return result;
      }
      /** Converts `number` to its protocol buffer representation. */
      protofyNumber(number) {
        return (0, protobuf_1.create)(proto.Value_NumberSchema, {
          value: number.value,
          numerators: number.numeratorUnits.toArray(),
          denominators: number.denominatorUnits.toArray()
        });
      }
      /** Converts `separator` to its protocol buffer representation. */
      protofySeparator(separator) {
        switch (separator) {
          case ",":
            return proto.ListSeparator.COMMA;
          case " ":
            return proto.ListSeparator.SPACE;
          case "/":
            return proto.ListSeparator.SLASH;
          case null:
            return proto.ListSeparator.UNDECIDED;
          default:
            throw utils.compilerError(`Unknown ListSeparator ${separator}`);
        }
      }
      /** Converts `calculation` to its protocol buffer representation. */
      protofyCalculation(calculation) {
        return (0, protobuf_1.create)(proto.Value_CalculationSchema, {
          name: calculation.name,
          arguments: calculation.arguments.map(this.protofyCalculationValue.bind(this)).toArray()
        });
      }
      /** Converts a CalculationValue that appears within a `SassCalculation` to
       * its protocol buffer representation. */
      protofyCalculationValue(value) {
        const result = (0, protobuf_1.create)(proto.Value_Calculation_CalculationValueSchema, {});
        if (value instanceof calculations_1.SassCalculation) {
          result.value = {
            case: "calculation",
            value: this.protofyCalculation(value)
          };
        } else if (value instanceof calculations_1.CalculationOperation) {
          result.value = {
            case: "operation",
            value: (0, protobuf_1.create)(proto.Value_Calculation_CalculationOperationSchema, {
              operator: this.protofyCalculationOperator(value.operator),
              left: this.protofyCalculationValue(value.left),
              right: this.protofyCalculationValue(value.right)
            })
          };
        } else if (value instanceof calculations_1.CalculationInterpolation) {
          result.value = { case: "interpolation", value: value.value };
        } else if (value instanceof string_1.SassString) {
          result.value = { case: "string", value: value.text };
        } else if (value instanceof number_1.SassNumber) {
          result.value = { case: "number", value: this.protofyNumber(value) };
        } else {
          throw utils.compilerError(`Unknown CalculationValue ${value}`);
        }
        return result;
      }
      /** Converts `operator` to its protocol buffer representation. */
      protofyCalculationOperator(operator) {
        switch (operator) {
          case "+":
            return proto.CalculationOperator.PLUS;
          case "-":
            return proto.CalculationOperator.MINUS;
          case "*":
            return proto.CalculationOperator.TIMES;
          case "/":
            return proto.CalculationOperator.DIVIDE;
          default:
            throw utils.compilerError(`Unknown CalculationOperator ${operator}`);
        }
      }
      /** Converts `value` to its JS representation. */
      deprotofy(value) {
        switch (value.value.case) {
          case "string": {
            const string = value.value.value;
            return string.text.length === 0 ? string_1.SassString.empty({ quotes: string.quoted }) : new string_1.SassString(string.text, { quotes: string.quoted });
          }
          case "number": {
            return this.deprotofyNumber(value.value.value);
          }
          case "color": {
            const color = value.value.value;
            const channel1 = color.channel1 ?? null;
            const channel2 = color.channel2 ?? null;
            const channel3 = color.channel3 ?? null;
            const alpha = color.alpha ?? null;
            const space = color.space;
            switch (color.space.toLowerCase()) {
              case "rgb":
              case "srgb":
              case "srgb-linear":
              case "display-p3":
              case "a98-rgb":
              case "prophoto-rgb":
              case "rec2020":
                return new color_1.SassColor({
                  red: channel1,
                  green: channel2,
                  blue: channel3,
                  alpha,
                  space
                });
              case "hsl":
                return new color_1.SassColor({
                  hue: channel1,
                  saturation: channel2,
                  lightness: channel3,
                  alpha,
                  space
                });
              case "hwb":
                return new color_1.SassColor({
                  hue: channel1,
                  whiteness: channel2,
                  blackness: channel3,
                  alpha,
                  space
                });
              case "lab":
              case "oklab":
                return new color_1.SassColor({
                  lightness: channel1,
                  a: channel2,
                  b: channel3,
                  alpha,
                  space
                });
              case "lch":
              case "oklch":
                return new color_1.SassColor({
                  lightness: channel1,
                  chroma: channel2,
                  hue: channel3,
                  alpha,
                  space
                });
              case "xyz":
              case "xyz-d65":
              case "xyz-d50":
                return new color_1.SassColor({
                  x: channel1,
                  y: channel2,
                  z: channel3,
                  alpha,
                  space
                });
              default:
                throw utils.compilerError(`Unknown color space "${color.space}".`);
            }
          }
          case "list": {
            const list = value.value.value;
            const separator = this.deprotofySeparator(list.separator);
            if (separator === null && list.contents.length > 1) {
              throw utils.compilerError(`Value.List ${list} can't have an undecided separator because it has ${list.contents.length} elements`);
            }
            return new list_1.SassList(list.contents.map((element) => this.deprotofy(element)), { separator, brackets: list.hasBrackets });
          }
          case "argumentList": {
            const list = value.value.value;
            const separator = this.deprotofySeparator(list.separator);
            if (separator === null && list.contents.length > 1) {
              throw utils.compilerError(`Value.List ${list} can't have an undecided separator because it has ${list.contents.length} elements`);
            }
            const result = new argument_list_1.SassArgumentList(list.contents.map((element) => this.deprotofy(element)), (0, immutable_1.OrderedMap)(Object.entries(list.keywords).map(([key, value2]) => [
              key,
              this.deprotofy(value2)
            ])), separator, list.id);
            this.argumentLists.push(result);
            return result;
          }
          case "map":
            return new map_1.SassMap((0, immutable_1.OrderedMap)(value.value.value.entries.map((entry) => {
              const key = entry.key;
              if (!key)
                throw utils.mandatoryError("Value.Map.Entry.key");
              const value2 = entry.value;
              if (!value2)
                throw utils.mandatoryError("Value.Map.Entry.value");
              return [this.deprotofy(key), this.deprotofy(value2)];
            })));
          case "compilerFunction":
            return new function_1.SassFunction(value.value.value.id);
          case "hostFunction":
            throw utils.compilerError("The compiler may not send Value.host_function.");
          case "compilerMixin":
            return new mixin_1.SassMixin(value.value.value.id);
          case "calculation":
            return this.deprotofyCalculation(value.value.value);
          case "singleton":
            switch (value.value.value) {
              case proto.SingletonValue.TRUE:
                return boolean_1.sassTrue;
              case proto.SingletonValue.FALSE:
                return boolean_1.sassFalse;
              case proto.SingletonValue.NULL:
                return null_1.sassNull;
            }
          // eslint-disable-next-line no-fallthrough
          default:
            throw utils.mandatoryError("Value.value");
        }
      }
      /** Converts `number` to its JS representation. */
      deprotofyNumber(number) {
        return new number_1.SassNumber(number.value, {
          numeratorUnits: number.numerators,
          denominatorUnits: number.denominators
        });
      }
      /** Converts `separator` to its JS representation. */
      deprotofySeparator(separator) {
        switch (separator) {
          case proto.ListSeparator.COMMA:
            return ",";
          case proto.ListSeparator.SPACE:
            return " ";
          case proto.ListSeparator.SLASH:
            return "/";
          case proto.ListSeparator.UNDECIDED:
            return null;
          default:
            throw utils.compilerError(`Unknown separator ${separator}`);
        }
      }
      /** Converts `calculation` to its Sass representation. */
      deprotofyCalculation(calculation) {
        switch (calculation.name) {
          case "calc":
            if (calculation.arguments.length !== 1) {
              throw utils.compilerError("Value.Calculation.arguments must have exactly one argument for calc().");
            }
            return calculations_1.SassCalculation.calc(this.deprotofyCalculationValue(calculation.arguments[0]));
          case "clamp":
            if (calculation.arguments.length === 0 || calculation.arguments.length > 3) {
              throw utils.compilerError("Value.Calculation.arguments must have 1 to 3 arguments for clamp().");
            }
            return calculations_1.SassCalculation.clamp(this.deprotofyCalculationValue(calculation.arguments[0]), calculation.arguments.length > 1 ? this.deprotofyCalculationValue(calculation.arguments[1]) : void 0, calculation.arguments.length > 2 ? this.deprotofyCalculationValue(calculation.arguments[2]) : void 0);
          case "min":
            if (calculation.arguments.length === 0) {
              throw utils.compilerError("Value.Calculation.arguments must have at least 1 argument for min().");
            }
            return calculations_1.SassCalculation.min(calculation.arguments.map(this.deprotofyCalculationValue));
          case "max":
            if (calculation.arguments.length === 0) {
              throw utils.compilerError("Value.Calculation.arguments must have at least 1 argument for max().");
            }
            return calculations_1.SassCalculation.max(calculation.arguments.map(this.deprotofyCalculationValue));
          default:
            throw utils.compilerError(`Value.Calculation.name "${calculation.name}" is not a recognized calculation type.`);
        }
      }
      /** Converts `value` to its Sass representation. */
      deprotofyCalculationValue(value) {
        switch (value.value.case) {
          case "number":
            return this.deprotofyNumber(value.value.value);
          case "calculation":
            return this.deprotofyCalculation(value.value.value);
          case "string":
            return new string_1.SassString(value.value.value, { quotes: false });
          case "operation":
            return new calculations_1.CalculationOperation(this.deprotofyCalculationOperator(value.value.value.operator), this.deprotofyCalculationValue(value.value.value.left), this.deprotofyCalculationValue(value.value.value.right));
          case "interpolation":
            return new calculations_1.CalculationInterpolation(value.value.value);
          default:
            throw utils.mandatoryError("Calculation.CalculationValue.value");
        }
      }
      /** Converts `operator` to its Sass representation. */
      deprotofyCalculationOperator(operator) {
        switch (operator) {
          case proto.CalculationOperator.PLUS:
            return "+";
          case proto.CalculationOperator.MINUS:
            return "-";
          case proto.CalculationOperator.TIMES:
            return "*";
          case proto.CalculationOperator.DIVIDE:
            return "/";
          default:
            throw utils.compilerError(`Unknown CalculationOperator ${operator}`);
        }
      }
    };
    exports.Protofier = Protofier;
  }
});

// node_modules/sass-embedded/dist/lib/src/function-registry.js
var require_function_registry = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/function-registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionRegistry = void 0;
    var util_1 = require_util();
    var protobuf_1 = require_cjs2();
    var utils = require_utils();
    var proto = require_embedded_sass_pb();
    var utils_1 = require_utils();
    var protofier_1 = require_protofier();
    var value_1 = require_value();
    var FunctionRegistry = class {
      constructor(functionsBySignature) {
        __publicField(this, "functionsByName", /* @__PURE__ */ new Map());
        __publicField(this, "functionsById", /* @__PURE__ */ new Map());
        __publicField(this, "idsByFunction", /* @__PURE__ */ new Map());
        /** The next ID to use for a function. */
        __publicField(this, "id", 0);
        for (const [signature, fn] of Object.entries(functionsBySignature ?? {})) {
          const openParen = signature.indexOf("(");
          if (openParen === -1) {
            throw new Error(`options.functions: "${signature}" is missing "("`);
          }
          this.functionsByName.set(signature.substring(0, openParen), fn);
        }
      }
      /** Registers `fn` as a function that can be called using the returned ID. */
      register(fn) {
        return utils.putIfAbsent(this.idsByFunction, fn, () => {
          const id = this.id;
          this.id += 1;
          this.functionsById.set(id, fn);
          return id;
        });
      }
      /**
       * Returns the function to which `request` refers and returns its response.
       */
      call(request) {
        const protofier = new protofier_1.Protofier(this);
        const fn = this.get(request);
        return (0, utils_1.catchOr)(() => {
          return (0, utils_1.thenOr)(fn(request.arguments.map((value) => protofier.deprotofy(value))), (result) => {
            if (!(result instanceof value_1.Value)) {
              const name = request.identifier.case === "name" ? `"${request.identifier.value}"` : "anonymous function";
              throw `options.functions: ${name} returned non-Value: ` + (0, util_1.inspect)(result);
            }
            return (0, protobuf_1.create)(proto.InboundMessage_FunctionCallResponseSchema, {
              result: { case: "success", value: protofier.protofy(result) },
              accessedArgumentLists: protofier.accessedArgumentLists
            });
          });
        }, (error) => (0, protobuf_1.create)(proto.InboundMessage_FunctionCallResponseSchema, {
          result: { case: "error", value: `${error}` }
        }));
      }
      /** Returns the function to which `request` refers. */
      get(request) {
        if (request.identifier.case === "name") {
          const fn = this.functionsByName.get(request.identifier.value);
          if (fn)
            return fn;
          throw (0, utils_1.compilerError)(`Invalid OutboundMessage_FunctionCallRequest: there is no function named "${request.identifier.value}"`);
        } else if (request.identifier.case === "functionId") {
          const fn = this.functionsById.get(request.identifier.value);
          if (fn)
            return fn;
          throw (0, utils_1.compilerError)(`Invalid OutboundMessage_FunctionCallRequest: there is no function with ID "${request.identifier.value}"`);
        } else {
          throw (0, utils_1.compilerError)("Invalid OutboundMessage_FunctionCallRequest: function identifier is unset");
        }
      }
    };
    exports.FunctionRegistry = FunctionRegistry;
  }
});

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/sass-embedded/dist/lib/src/canonicalize-context.js
var require_canonicalize_context = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/canonicalize-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CanonicalizeContext = void 0;
    var CanonicalizeContext = class {
      constructor(containingUrl, fromImport) {
        __publicField(this, "fromImport");
        __publicField(this, "_containingUrl");
        __publicField(this, "_containingUrlAccessed", false);
        this._containingUrl = containingUrl;
        this.fromImport = fromImport;
      }
      get containingUrl() {
        this._containingUrlAccessed = true;
        return this._containingUrl;
      }
      /**
       * Whether the `containingUrl` getter has been accessed.
       *
       * This is marked as public so that the importer registry can access it, but
       * it's not part of the package's public API and should not be accessed by
       * user code. It may be renamed or removed without warning in the future.
       */
      get containingUrlAccessed() {
        return this._containingUrlAccessed;
      }
    };
    exports.CanonicalizeContext = CanonicalizeContext;
  }
});

// node_modules/sass-embedded/dist/lib/src/importer-registry.js
var require_importer_registry = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/importer-registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImporterRegistry = exports.NodePackageImporter = void 0;
    var module_1 = require_module();
    var p = require_path();
    var url_1 = require_url();
    var util_1 = require_util();
    var protobuf_1 = require_cjs2();
    var canonicalize_context_1 = require_canonicalize_context();
    var utils = require_utils();
    var proto = require_embedded_sass_pb();
    var utils_1 = require_utils();
    var entryPointDirectoryKey = Symbol();
    var _a;
    _a = entryPointDirectoryKey;
    var NodePackageImporter3 = class {
      constructor(entryPointDirectory) {
        __publicField(this, _a);
        var _a2;
        entryPointDirectory = entryPointDirectory ? p.resolve(entryPointDirectory) : ((_a2 = __require.main) == null ? void 0 : _a2.filename) ? p.dirname(__require.main.filename) : (
          // TODO: Find a way to use `import.meta.main` once
          // https://github.com/nodejs/node/issues/49440 is done.
          process.argv[1] ? (0, module_1.createRequire)(process.argv[1]).resolve(process.argv[1]) : void 0
        );
        if (!entryPointDirectory) {
          throw new Error("The Node package importer cannot determine an entry point because `require.main.filename` is not defined. Please provide an `entryPointDirectory` to the `NodePackageImporter`.");
        }
        this[entryPointDirectoryKey] = entryPointDirectory;
      }
    };
    exports.NodePackageImporter = NodePackageImporter3;
    var ImporterRegistry = class {
      constructor(options) {
        /** Protocol buffer representations of the registered importers. */
        __publicField(this, "importers");
        /** A map from importer IDs to their corresponding importers. */
        __publicField(this, "importersById", /* @__PURE__ */ new Map());
        /** A map from file importer IDs to their corresponding importers. */
        __publicField(this, "fileImportersById", /* @__PURE__ */ new Map());
        /** The next ID to use for an importer. */
        __publicField(this, "id", 0);
        this.importers = ((options == null ? void 0 : options.importers) ?? []).map((importer) => this.register(importer)).concat(((options == null ? void 0 : options.loadPaths) ?? []).map((path) => (0, protobuf_1.create)(proto.InboundMessage_CompileRequest_ImporterSchema, {
          importer: { case: "path", value: p.resolve(path) }
        })));
      }
      /** Converts an importer to a proto without adding it to `this.importers`. */
      register(importer) {
        const message = (0, protobuf_1.create)(proto.InboundMessage_CompileRequest_ImporterSchema, {});
        if (importer instanceof NodePackageImporter3) {
          const importerMessage = (0, protobuf_1.create)(proto.NodePackageImporterSchema, {
            entryPointDirectory: importer[entryPointDirectoryKey]
          });
          message.importer = {
            case: "nodePackageImporter",
            value: importerMessage
          };
        } else if ("canonicalize" in importer) {
          if ("findFileUrl" in importer) {
            throw new Error("Importer may not contain both canonicalize() and findFileUrl(): " + (0, util_1.inspect)(importer));
          }
          message.importer = { case: "importerId", value: this.id };
          message.nonCanonicalScheme = typeof importer.nonCanonicalScheme === "string" ? [importer.nonCanonicalScheme] : importer.nonCanonicalScheme ?? [];
          this.importersById.set(this.id, importer);
        } else {
          message.importer = { case: "fileImporterId", value: this.id };
          this.fileImportersById.set(this.id, importer);
        }
        this.id += 1;
        return message;
      }
      /** Handles a canonicalization request. */
      canonicalize(request) {
        const importer = this.importersById.get(request.importerId);
        if (!importer) {
          throw utils.compilerError("Unknown CanonicalizeRequest.importer_id");
        }
        const canonicalizeContext = new canonicalize_context_1.CanonicalizeContext(request.containingUrl ? new url_1.URL(request.containingUrl) : null, request.fromImport);
        return (0, utils_1.catchOr)(() => {
          return (0, utils_1.thenOr)(importer.canonicalize(request.url, canonicalizeContext), (url) => (0, protobuf_1.create)(proto.InboundMessage_CanonicalizeResponseSchema, {
            result: url === null ? { case: void 0 } : { case: "url", value: url.toString() },
            containingUrlUnused: !canonicalizeContext.containingUrlAccessed
          }));
        }, (error) => (0, protobuf_1.create)(proto.InboundMessage_CanonicalizeResponseSchema, {
          result: { case: "error", value: `${error}` }
        }));
      }
      /** Handles an import request. */
      import(request) {
        const importer = this.importersById.get(request.importerId);
        if (!importer) {
          throw utils.compilerError("Unknown ImportRequest.importer_id");
        }
        return (0, utils_1.catchOr)(() => {
          return (0, utils_1.thenOr)(importer.load(new url_1.URL(request.url)), (result) => {
            var _a2;
            if (!result)
              return (0, protobuf_1.create)(proto.InboundMessage_ImportResponseSchema, {});
            if (typeof result.contents !== "string") {
              throw Error(`Invalid argument (contents): must be a string but was: ${result.contents.constructor.name}`);
            }
            if (result.sourceMapUrl && !result.sourceMapUrl.protocol) {
              throw Error("Invalid argument (sourceMapUrl): must be absolute but was: " + result.sourceMapUrl);
            }
            return (0, protobuf_1.create)(proto.InboundMessage_ImportResponseSchema, {
              result: {
                case: "success",
                value: {
                  contents: result.contents,
                  syntax: utils.protofySyntax(result.syntax),
                  sourceMapUrl: ((_a2 = result.sourceMapUrl) == null ? void 0 : _a2.toString()) ?? ""
                }
              }
            });
          });
        }, (error) => (0, protobuf_1.create)(proto.InboundMessage_ImportResponseSchema, {
          result: { case: "error", value: `${error}` }
        }));
      }
      /** Handles a file import request. */
      fileImport(request) {
        const importer = this.fileImportersById.get(request.importerId);
        if (!importer) {
          throw utils.compilerError("Unknown FileImportRequest.importer_id");
        }
        const canonicalizeContext = new canonicalize_context_1.CanonicalizeContext(request.containingUrl ? new url_1.URL(request.containingUrl) : null, request.fromImport);
        return (0, utils_1.catchOr)(() => {
          return (0, utils_1.thenOr)(importer.findFileUrl(request.url, canonicalizeContext), (url) => {
            if (!url) {
              return (0, protobuf_1.create)(proto.InboundMessage_FileImportResponseSchema, {
                containingUrlUnused: !canonicalizeContext.containingUrlAccessed
              });
            }
            if (url.protocol !== "file:") {
              throw `FileImporter ${(0, util_1.inspect)(importer)} returned non-file: URL ` + +`"${url}" for URL "${request.url}".`;
            }
            return (0, protobuf_1.create)(proto.InboundMessage_FileImportResponseSchema, {
              result: { case: "fileUrl", value: url.toString() },
              containingUrlUnused: !canonicalizeContext.containingUrlAccessed
            });
          });
        }, (error) => (0, protobuf_1.create)(proto.InboundMessage_FileImportResponseSchema, {
          result: { case: "error", value: `${error}` }
        }));
      }
    };
    exports.ImporterRegistry = ImporterRegistry;
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports, module) {
    module.exports = encode;
    var MSB = 128;
    var REST = 127;
    var MSBALL = ~REST;
    var INT = Math.pow(2, 31);
    function encode(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports, module) {
    module.exports = read;
    var MSB = 128;
    var REST = 127;
    function read(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB);
      read.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports, module) {
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/sass-embedded/dist/lib/src/message-transformer.js
var require_message_transformer = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/message-transformer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageTransformer = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var protobuf_1 = require_cjs2();
    var varint = require_varint2();
    var utils_1 = require_utils();
    var embedded_sass_pb_1 = require_embedded_sass_pb();
    var MessageTransformer = class {
      constructor(outboundProtobufs$, writeInboundProtobuf) {
        __publicField(this, "outboundProtobufs$");
        __publicField(this, "writeInboundProtobuf");
        // The decoded messages are written to this Subject. It is publicly exposed
        // as a readonly Observable.
        __publicField(this, "outboundMessagesInternal$", new rxjs_1.Subject());
        /**
         * The OutboundMessages, decoded from protocol buffers. If this fails to
         * decode a message, it will emit an error.
         */
        __publicField(this, "outboundMessages$", this.outboundMessagesInternal$.pipe());
        this.outboundProtobufs$ = outboundProtobufs$;
        this.writeInboundProtobuf = writeInboundProtobuf;
        this.outboundProtobufs$.pipe((0, operators_1.map)(decode)).subscribe(this.outboundMessagesInternal$);
      }
      /**
       * Converts the inbound `compilationId` and `message` to a protocol buffer.
       */
      writeInboundMessage([compilationId, message]) {
        const compilationIdLength = varint.encodingLength(compilationId);
        const encodedMessage = (0, protobuf_1.toBinary)(embedded_sass_pb_1.InboundMessageSchema, message);
        const buffer = new Uint8Array(compilationIdLength + encodedMessage.length);
        varint.encode(compilationId, buffer);
        buffer.set(encodedMessage, compilationIdLength);
        try {
          this.writeInboundProtobuf(buffer);
        } catch (error) {
          this.outboundMessagesInternal$.error(error);
        }
      }
    };
    exports.MessageTransformer = MessageTransformer;
    function decode(buffer) {
      let compilationId;
      try {
        compilationId = varint.decode(buffer);
      } catch (error) {
        throw (0, utils_1.compilerError)(`Invalid compilation ID varint: ${error}`);
      }
      try {
        return [
          compilationId,
          (0, protobuf_1.fromBinary)(embedded_sass_pb_1.OutboundMessageSchema, new Uint8Array(buffer.buffer, varint.decode.bytes))
        ];
      } catch (error) {
        throw (0, utils_1.compilerError)(`Invalid protobuf: ${error}`);
      }
    }
  }
});

// node_modules/buffer-builder/buffer-builder.js
var require_buffer_builder = __commonJS({
  "node_modules/buffer-builder/buffer-builder.js"(exports, module) {
    module.exports = BufferBuilder;
    function BufferBuilder(initialCapacity) {
      var buffer = Buffer.isBuffer(initialCapacity) ? initialCapacity : new Buffer(initialCapacity || 512);
      this.buffers = [buffer];
      this.writeIndex = 0;
      this.length = 0;
    }
    BufferBuilder.prototype.appendBuffer = function(source) {
      if (source.length === 0) return this;
      var tail = this.buffers[this.buffers.length - 1];
      var spaceInCurrent = tail.length - this.writeIndex;
      if (source.length <= spaceInCurrent) {
        source.copy(tail, this.writeIndex);
        this.writeIndex += source.length;
      } else {
        if (spaceInCurrent) {
          source.copy(tail, this.writeIndex);
        }
        var newBuf = new Buffer(Math.max(tail.length * 2, source.length));
        this.buffers.push(newBuf);
        this.writeIndex = source.copy(newBuf, 0, spaceInCurrent);
      }
      this.length += source.length;
      return this;
    };
    function makeAppender(encoder, size) {
      return function(x) {
        var buf = this.buffers[this.buffers.length - 1];
        if (this.writeIndex + size <= buf.length) {
          encoder.call(buf, x, this.writeIndex, true);
          this.writeIndex += size;
          this.length += size;
        } else {
          var scratchBuffer = new Buffer(size);
          encoder.call(scratchBuffer, x, 0, true);
          this.appendBuffer(scratchBuffer);
        }
        return this;
      };
    }
    BufferBuilder.prototype.appendUInt8 = makeAppender(Buffer.prototype.writeUInt8, 1);
    BufferBuilder.prototype.appendUInt16LE = makeAppender(Buffer.prototype.writeUInt16LE, 2);
    BufferBuilder.prototype.appendUInt16BE = makeAppender(Buffer.prototype.writeUInt16BE, 2);
    BufferBuilder.prototype.appendUInt32LE = makeAppender(Buffer.prototype.writeUInt32LE, 4);
    BufferBuilder.prototype.appendUInt32BE = makeAppender(Buffer.prototype.writeUInt32BE, 4);
    BufferBuilder.prototype.appendInt8 = makeAppender(Buffer.prototype.writeInt8, 1);
    BufferBuilder.prototype.appendInt16LE = makeAppender(Buffer.prototype.writeInt16LE, 2);
    BufferBuilder.prototype.appendInt16BE = makeAppender(Buffer.prototype.writeInt16BE, 2);
    BufferBuilder.prototype.appendInt32LE = makeAppender(Buffer.prototype.writeInt32LE, 4);
    BufferBuilder.prototype.appendInt32BE = makeAppender(Buffer.prototype.writeInt32BE, 4);
    BufferBuilder.prototype.appendFloatLE = makeAppender(Buffer.prototype.writeFloatLE, 4);
    BufferBuilder.prototype.appendFloatBE = makeAppender(Buffer.prototype.writeFloatBE, 4);
    BufferBuilder.prototype.appendDoubleLE = makeAppender(Buffer.prototype.writeDoubleLE, 8);
    BufferBuilder.prototype.appendDoubleBE = makeAppender(Buffer.prototype.writeDoubleBE, 8);
    BufferBuilder.prototype.appendString = function(str, encoding) {
      return this.appendBuffer(new Buffer(str, encoding));
    };
    BufferBuilder.prototype.appendStringZero = function(str, encoding) {
      return this.appendString(str + "\0", encoding);
    };
    BufferBuilder.prototype.appendFill = function(value, count2) {
      if (!count2) return;
      var tail = this.buffers[this.buffers.length - 1];
      var spaceInCurrent = tail.length - this.writeIndex;
      if (count2 <= spaceInCurrent) {
        tail.fill(value, this.writeIndex, this.writeIndex + count2);
        this.writeIndex += count2;
      } else {
        if (spaceInCurrent) {
          tail.fill(value, this.writeIndex);
        }
        var newBuf = new Buffer(Math.max(tail.length * 2, count2));
        var couldNotFit = count2 - spaceInCurrent;
        newBuf.fill(value, 0, couldNotFit);
        this.buffers.push(newBuf);
        this.writeIndex = couldNotFit;
      }
      this.length += count2;
      return this;
    };
    BufferBuilder.prototype.get = function() {
      var concatted = new Buffer(this.length);
      this.copy(concatted);
      return concatted;
    };
    BufferBuilder.prototype.copy = function(targetBuffer, targetStart, sourceStart, sourceEnd) {
      targetStart || (targetStart = 0);
      sourceStart || (sourceStart = 0);
      sourceEnd !== void 0 || (sourceEnd = this.length);
      if (targetStart < 0 || targetStart > 0 && targetStart >= targetBuffer.length) {
        throw new Error("targetStart is out of bounds");
      }
      if (sourceEnd < sourceStart) {
        throw new Error("sourceEnd < sourceStart");
      }
      if (sourceStart < 0 || sourceStart > 0 && sourceStart >= this.length) {
        throw new Error("sourceStart is out of bounds");
      }
      if (sourceEnd > this.length) {
        throw new Error("sourceEnd out of bounds");
      }
      sourceEnd = Math.min(sourceEnd, sourceStart + (targetBuffer.length - targetStart));
      var targetWriteIdx = targetStart;
      var readBuffer = 0;
      var copyLength = sourceEnd - sourceStart;
      var skipped = 0;
      while (skipped < sourceStart) {
        var buffer = this.buffers[readBuffer];
        if (buffer.length + skipped < targetStart) {
          skipped += buffer.length;
        } else {
          var copyStart = sourceStart - skipped;
          var inThisBuffer = Math.min(copyLength, buffer.length - copyStart);
          buffer.copy(targetBuffer, targetWriteIdx, copyStart, copyStart + inThisBuffer);
          targetWriteIdx += inThisBuffer;
          copyLength -= inThisBuffer;
          readBuffer++;
          break;
        }
        readBuffer++;
      }
      while (copyLength > 0) {
        var buffer = this.buffers[readBuffer];
        var toCopy = Math.min(buffer.length, copyLength);
        buffer.copy(targetBuffer, targetWriteIdx, 0, toCopy);
        copyLength -= toCopy;
        targetWriteIdx += toCopy;
        readBuffer++;
      }
      return sourceEnd - sourceStart;
    };
  }
});

// node_modules/sass-embedded/dist/lib/src/packet-transformer.js
var require_packet_transformer = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/packet-transformer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PacketTransformer = void 0;
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var BufferBuilder = require_buffer_builder();
    var PacketTransformer = class {
      constructor(outboundBuffers$, writeInboundBuffer) {
        __publicField(this, "outboundBuffers$");
        __publicField(this, "writeInboundBuffer");
        // The packet that is actively being decoded as buffers come in.
        __publicField(this, "packet", new Packet());
        // The decoded protobufs are written to this Subject. It is publicly exposed
        // as a readonly Observable.
        __publicField(this, "outboundProtobufsInternal$", new rxjs_1.Subject());
        /**
         * The fully-decoded, outbound protobufs. If any errors are encountered
         * during encoding/decoding, this Observable will error out.
         */
        __publicField(this, "outboundProtobufs$", this.outboundProtobufsInternal$.pipe());
        this.outboundBuffers$ = outboundBuffers$;
        this.writeInboundBuffer = writeInboundBuffer;
        this.outboundBuffers$.pipe((0, operators_1.mergeMap)((buffer) => this.decode(buffer))).subscribe(this.outboundProtobufsInternal$);
      }
      /**
       * Encodes a packet by pre-fixing `protobuf` with a header that describes its
       * length.
       */
      writeInboundProtobuf(protobuf) {
        try {
          let length = protobuf.length;
          if (length === 0) {
            this.writeInboundBuffer(Buffer.alloc(1));
            return;
          }
          const header = new BufferBuilder(8);
          while (length > 0) {
            header.appendUInt8((length > 127 ? 128 : 0) | length & 127);
            length >>= 7;
          }
          const packet = Buffer.alloc(header.length + protobuf.length);
          header.copy(packet);
          packet.set(protobuf, header.length);
          this.writeInboundBuffer(packet);
        } catch (error) {
          this.outboundProtobufsInternal$.error(error);
        }
      }
      // Decodes a buffer, filling up the packet that is actively being decoded.
      // Returns a list of decoded payloads.
      decode(buffer) {
        const payloads = [];
        let decodedBytes = 0;
        while (decodedBytes < buffer.length) {
          decodedBytes += this.packet.write(buffer.slice(decodedBytes));
          if (this.packet.isComplete && this.packet.payload) {
            payloads.push(this.packet.payload);
            this.packet = new Packet();
          }
        }
        return payloads;
      }
    };
    exports.PacketTransformer = PacketTransformer;
    var Packet = class {
      constructor() {
        // The number of bits we've consumed so far to fill out `payloadLength`.
        __publicField(this, "payloadLengthBits", 0);
        // The length of the next message, in bytes.
        //
        // This is built up from a [varint]. Once it's fully consumed, `payload` is
        // initialized and this is reset to 0.
        //
        // [varint]: https://developers.google.com/protocol-buffers/docs/encoding#varints
        __publicField(this, "payloadLength", 0);
        /**
         * The packet's payload. Constructed by calls to write().
         * @see write
         */
        __publicField(this, "payload");
        // The offset in [payload] that should be written to next time data arrives.
        __publicField(this, "payloadOffset", 0);
      }
      /** Whether the packet construction is complete. */
      get isComplete() {
        return !!(this.payload && this.payloadOffset >= this.payloadLength);
      }
      /**
       * Takes arbitrary binary input and slots it into the header and payload
       * appropriately. Returns the number of bytes that were written into the
       * packet. This method can be called repeatedly, incrementally building
       * up the packet until it is complete.
       */
      write(source) {
        if (this.isComplete) {
          throw Error("Cannot write to a completed Packet.");
        }
        let i = 0;
        if (!this.payload) {
          for (; ; ) {
            const byte = source[i];
            this.payloadLength += (byte & 127) << this.payloadLengthBits;
            this.payloadLengthBits += 7;
            i++;
            if (byte <= 127) {
              this.payload = Buffer.alloc(this.payloadLength);
              break;
            } else if (i === source.length) {
              return i;
            } else {
            }
          }
        }
        const bytesToWrite = Math.min(this.payload.length - this.payloadOffset, source.length - i);
        this.payload.set(source.subarray(i, i + bytesToWrite), this.payloadOffset);
        this.payloadOffset += bytesToWrite;
        return i + bytesToWrite;
      }
    };
  }
});

// node_modules/sass-embedded/dist/lib/src/compiler/async.js
var require_async2 = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/compiler/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncCompiler = void 0;
    exports.initAsyncCompiler = initAsyncCompiler3;
    var child_process_1 = require_child_process();
    var rxjs_1 = require_cjs();
    var operators_1 = require_operators();
    var path = require_path();
    var utils_1 = require_utils4();
    var compiler_path_1 = require_compiler_path();
    var deprecations_1 = require_deprecations2();
    var function_registry_1 = require_function_registry();
    var importer_registry_1 = require_importer_registry();
    var message_transformer_1 = require_message_transformer();
    var packet_transformer_1 = require_packet_transformer();
    var utils = require_utils();
    var initFlag = Symbol();
    var AsyncCompiler3 = class {
      /** Initialize resources shared across compilations. */
      constructor(flag) {
        /** The underlying process that's being wrapped. */
        __publicField(this, "process", (0, child_process_1.spawn)(compiler_path_1.compilerCommand[0], [...compiler_path_1.compilerCommand.slice(1), "--embedded"], {
          // Use the command's cwd so the compiler survives the removal of the
          // current working directory.
          // https://github.com/sass/embedded-host-node/pull/261#discussion_r1438712923
          cwd: path.dirname(compiler_path_1.compilerCommand[0]),
          // Node blocks launching .bat and .cmd without a shell due to CVE-2024-27980
          shell: [".bat", ".cmd"].includes(path.extname(compiler_path_1.compilerCommand[0]).toLowerCase()),
          windowsHide: true
        }));
        /** The next compilation ID. */
        __publicField(this, "compilationId", 1);
        /** A list of active compilations. */
        __publicField(this, "compilations", /* @__PURE__ */ new Set());
        /** Whether the underlying compiler has already exited. */
        __publicField(this, "disposed", false);
        /** Reusable message transformer for all compilations.  */
        __publicField(this, "messageTransformer");
        /** The child process's exit event. */
        __publicField(this, "exit$", new Promise((resolve) => {
          this.process.on("exit", (code) => resolve(code));
        }));
        /** The buffers emitted by the child process's stdout. */
        __publicField(this, "stdout$", new rxjs_1.Observable((observer) => {
          this.process.stdout.on("data", (buffer) => observer.next(buffer));
        }).pipe((0, operators_1.takeUntil)(this.exit$)));
        /** The buffers emitted by the child process's stderr. */
        __publicField(this, "stderr$", new rxjs_1.Observable((observer) => {
          this.process.stderr.on("data", (buffer) => observer.next(buffer));
        }).pipe((0, operators_1.takeUntil)(this.exit$)));
        if (flag !== initFlag) {
          throw utils.compilerError("AsyncCompiler can not be directly constructed. Please use `sass.initAsyncCompiler()` instead.");
        }
        this.stderr$.subscribe((data) => process.stderr.write(data));
        const packetTransformer = new packet_transformer_1.PacketTransformer(this.stdout$, (buffer) => {
          this.writeStdin(buffer);
        });
        this.messageTransformer = new message_transformer_1.MessageTransformer(packetTransformer.outboundProtobufs$, (packet) => packetTransformer.writeInboundProtobuf(packet));
      }
      /** Writes `buffer` to the child process's stdin. */
      writeStdin(buffer) {
        this.process.stdin.write(buffer);
      }
      /** Guards against using a disposed compiler. */
      throwIfDisposed() {
        if (this.disposed) {
          throw utils.compilerError("Async compiler has already been disposed.");
        }
      }
      /**
       * Sends a compile request to the child process and returns a Promise that
       * resolves with the CompileResult. Rejects the promise if there were any
       * protocol or compilation errors.
       */
      async compileRequestAsync(request, importers, options) {
        const optionsKey = Symbol();
        deprecations_1.activeDeprecationOptions.set(optionsKey, options ?? {});
        try {
          const functions = new function_registry_1.FunctionRegistry(options == null ? void 0 : options.functions);
          const dispatcher = (0, utils_1.createDispatcher)(this.compilationId++, this.messageTransformer, {
            handleImportRequest: (request2) => importers.import(request2),
            handleFileImportRequest: (request2) => importers.fileImport(request2),
            handleCanonicalizeRequest: (request2) => importers.canonicalize(request2),
            handleFunctionCallRequest: (request2) => functions.call(request2)
          });
          dispatcher.logEvents$.subscribe((event) => (0, utils_1.handleLogEvent)(options, event));
          const compilation = new Promise((resolve, reject) => dispatcher.sendCompileRequest(request, (err, response) => {
            this.compilations.delete(compilation);
            if (this.compilations.size === 0)
              this.compilationId = 1;
            if (err) {
              reject(err);
            } else {
              resolve(response);
            }
          }));
          this.compilations.add(compilation);
          return (0, utils_1.handleCompileResponse)(await compilation);
        } finally {
          deprecations_1.activeDeprecationOptions.delete(optionsKey);
        }
      }
      compileAsync(path2, options) {
        this.throwIfDisposed();
        const importers = new importer_registry_1.ImporterRegistry(options);
        return this.compileRequestAsync((0, utils_1.newCompilePathRequest)(path2, importers, options), importers, options);
      }
      compileStringAsync(source, options) {
        this.throwIfDisposed();
        const importers = new importer_registry_1.ImporterRegistry(options);
        return this.compileRequestAsync((0, utils_1.newCompileStringRequest)(source, importers, options), importers, options);
      }
      async dispose() {
        this.disposed = true;
        await Promise.all(this.compilations);
        this.process.stdin.end();
        await this.exit$;
      }
    };
    exports.AsyncCompiler = AsyncCompiler3;
    async function initAsyncCompiler3() {
      return new AsyncCompiler3(initFlag);
    }
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:worker_threads
var require_worker_threads = __commonJS({
  "browser-external:worker_threads"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "worker_threads" has been externalized for browser compatibility. Cannot access "worker_threads.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/sync-message-port/dist/lib/index.js
var require_lib = __commonJS({
  "node_modules/sync-message-port/dist/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SyncMessagePort = exports.TimeoutException = void 0;
    var assert_1 = require_assert();
    var events_1 = require_events();
    var worker_threads_1 = require_worker_threads();
    var BufferState;
    (function(BufferState2) {
      BufferState2[BufferState2["AwaitingMessage"] = 0] = "AwaitingMessage";
      BufferState2[BufferState2["MessageSent"] = 1] = "MessageSent";
      BufferState2[BufferState2["Closed"] = 2] = "Closed";
    })(BufferState || (BufferState = {}));
    var TimeoutException = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TimeoutException = TimeoutException;
    var SyncMessagePort = class extends events_1.EventEmitter {
      /**
       * Creates a new message port. The `port` must be created by
       * `SyncMessagePort.createChannel()` and must connect to a port passed to
       * another `SyncMessagePort` in another worker.
       */
      constructor(port) {
        var _a;
        super();
        __publicField(this, "port");
        /**
         * An Int32 view of the shared buffer.
         *
         * Each port sets this to `BufferState.AwaitingMessage` before checking for
         * new messages in `receiveMessage()`, and each port sets it to
         * `BufferState.MessageSent` after sending a new message. It's set to
         * `BufferState.Closed` when the channel is closed.
         */
        __publicField(this, "buffer");
        this.port = port;
        const buffer = (_a = (0, worker_threads_1.receiveMessageOnPort)(this.port)) == null ? void 0 : _a.message;
        if (!buffer) {
          throw new Error("new SyncMessagePort() must be passed a port from SyncMessagePort.createChannel().");
        }
        this.buffer = new Int32Array(buffer);
        this.on("newListener", (event, listener) => {
          this.port.on(event, listener);
        });
        this.on("removeListener", (event, listener) => this.port.removeListener(event, listener));
      }
      /** Creates a channel whose ports can be passed to `new SyncMessagePort()`. */
      static createChannel() {
        const channel = new worker_threads_1.MessageChannel();
        const buffer = new SharedArrayBuffer(4);
        channel.port1.postMessage(buffer);
        channel.port2.postMessage(buffer);
        return channel;
      }
      /** See `MessagePort.postMesage()`. */
      postMessage(value, transferList) {
        this.port.postMessage(value, transferList);
        if (Atomics.compareExchange(this.buffer, 0, BufferState.AwaitingMessage, BufferState.MessageSent) === BufferState.AwaitingMessage) {
          Atomics.notify(this.buffer, 0);
        }
      }
      /**
       * Returns the message sent by the other port, if one is available. This *does
       * not* block, and will return `undefined` immediately if no message is
       * available. In order to distinguish between a message with value `undefined`
       * and no message, a message is return in an object with a `message` field.
       *
       * This may not be called while this has a listener for the `'message'` event.
       * It does *not* throw an error if the port is closed when this is called;
       * instead, it just returns `undefined`.
       */
      receiveMessageIfAvailable() {
        if (this.listenerCount("message")) {
          throw new Error("SyncMessageChannel.receiveMessageIfAvailable() may not be called while there are message listeners.");
        }
        return (0, worker_threads_1.receiveMessageOnPort)(this.port);
      }
      /**
       * Blocks and returns the next message sent by the other port.
       *
       * This may not be called while this has a listener for the `'message'` event.
       * Throws an error if the channel is closed, including if it closes while this
       * is waiting for a message, unless {@link ReceiveMessageOptions.closedValue}
       * is passed.
       */
      receiveMessage(options) {
        if (this.listenerCount("message")) {
          throw new Error("SyncMessageChannel.receiveMessage() may not be called while there are message listeners.");
        }
        const previousState = Atomics.compareExchange(this.buffer, 0, BufferState.MessageSent, BufferState.AwaitingMessage);
        if (previousState === BufferState.Closed) {
          if (options && "closedValue" in options)
            return options.closedValue;
          throw new Error("The SyncMessagePort's channel is closed.");
        }
        let message = (0, worker_threads_1.receiveMessageOnPort)(this.port);
        if (message)
          return message.message;
        const result = Atomics.wait(this.buffer, 0, BufferState.AwaitingMessage, options == null ? void 0 : options.timeout);
        message = (0, worker_threads_1.receiveMessageOnPort)(this.port);
        if (message)
          return message.message;
        if (result === "timed-out") {
          if ("timeoutValue" in options)
            return options.timeoutValue;
          throw new TimeoutException("SyncMessagePort.receiveMessage() timed out.");
        }
        const oldState = Atomics.and(this.buffer, 0, BufferState.Closed);
        assert_1.strict.equal(oldState & BufferState.Closed, BufferState.Closed);
        if (options && "closedValue" in options)
          return options.closedValue;
        throw new Error("The SyncMessagePort's channel is closed.");
      }
      /** See `MessagePort.close()`. */
      close() {
        Atomics.or(this.buffer, 0, BufferState.Closed);
        Atomics.notify(this.buffer, 0);
        this.port.close();
      }
    };
    exports.SyncMessagePort = SyncMessagePort;
  }
});

// node_modules/sync-child-process/dist/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/sync-child-process/dist/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SyncChildProcess = void 0;
    var fs = require_fs();
    var p = require_path();
    var stream = require_stream();
    var worker_threads_1 = require_worker_threads();
    var worker_threads = require_worker_threads();
    var sync_message_port_1 = require_lib();
    function isMarkedAsUntransferable(object) {
      return "isMarkedAsUntransferable" in worker_threads ? (
        // TODO - DefinitelyTyped/DefinitelyTyped#71033: Remove this cast
        worker_threads.isMarkedAsUntransferable(object)
      ) : false;
    }
    var SyncChildProcess = class {
      constructor(command, argsOrOptions, options) {
        /** The port that communicates with the worker thread. */
        __publicField(this, "port");
        /** The worker in which the child process runs. */
        __publicField(this, "worker");
        /** The standard input stream to write to the process. */
        __publicField(this, "stdin");
        let args;
        if (Array.isArray(argsOrOptions)) {
          args = argsOrOptions;
        } else {
          args = [];
          options = argsOrOptions;
        }
        const { port1, port2 } = sync_message_port_1.SyncMessagePort.createChannel();
        this.port = new sync_message_port_1.SyncMessagePort(port1);
        this.worker = spawnWorker(p.join(p.dirname(__filename), "worker"), {
          workerData: { port: port2, command, args, options },
          transferList: [port2]
        });
        this.worker.on("error", console.error);
        this.stdin = new stream.Writable({
          write: (chunk, encoding, callback) => {
            this.port.postMessage({
              type: "stdin",
              data: chunk
            }, isMarkedAsUntransferable(chunk.buffer) ? void 0 : [chunk.buffer]);
            callback();
          },
          final: () => this.port.postMessage({ type: "stdinClosed" })
        });
      }
      /**
       * Blocks until the child process is ready to emit another event, then returns
       * that event. This will return an [IteratorReturnResult] with an [ExitEvent]
       * once when the process exits. If it's called again after that, it will
       * return `{done: true}` without a value.
       *
       * If there's an error running the child process, this will throw that error.
       */
      next() {
        if (this.stdin.destroyed)
          return { done: true, value: void 0 };
        const message = this.port.receiveMessage();
        switch (message.type) {
          case "stdout":
            return {
              value: { type: "stdout", data: Buffer.from(message.data.buffer) }
            };
          case "stderr":
            return {
              value: { type: "stderr", data: Buffer.from(message.data.buffer) }
            };
          case "error":
            this.close();
            throw message.error;
          case "exit":
            this.close();
            return { done: true, value: message };
        }
      }
      // TODO(nex3): Add a non-blocking `yieldIfReady()` function that returns
      // `null` if the worker hasn't queued up an event.
      // TODO(nex3): Add a `yieldAsync()` function that returns a `Promise<Event>`.
      /**
       * Sends a signal (`SIGTERM` by default) to the child process.
       *
       * This has no effect if the process has already exited.
       */
      kill(signal) {
        this.port.postMessage({ type: "kill", signal });
      }
      /** Closes down the worker thread and the stdin stream. */
      close() {
        this.port.close();
        void this.worker.terminate();
        this.stdin.destroy();
      }
    };
    exports.SyncChildProcess = SyncChildProcess;
    function spawnWorker(fileWithoutExtension, options) {
      const jsFile = fileWithoutExtension + ".js";
      if (fs.existsSync(jsFile))
        return new worker_threads_1.Worker(jsFile, options);
      const tsFile = fileWithoutExtension + ".ts";
      if (fs.existsSync(tsFile)) {
        return new worker_threads_1.Worker(`
        require('ts-node').register();
        require(${JSON.stringify(tsFile)});
      `, { ...options, eval: true });
      }
      throw new Error(`Neither "${jsFile}" nor ".ts" exists.`);
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/compiler/sync.js
var require_sync = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/compiler/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Compiler = void 0;
    exports.initCompiler = initCompiler3;
    var rxjs_1 = require_cjs();
    var sync_child_process_1 = require_lib2();
    var path = require_path();
    var utils_1 = require_utils4();
    var compiler_path_1 = require_compiler_path();
    var deprecations_1 = require_deprecations2();
    var function_registry_1 = require_function_registry();
    var importer_registry_1 = require_importer_registry();
    var message_transformer_1 = require_message_transformer();
    var packet_transformer_1 = require_packet_transformer();
    var utils = require_utils();
    var initFlag = Symbol();
    var Compiler3 = class {
      /** Initialize resources shared across compilations. */
      constructor(flag) {
        /** The underlying process that's being wrapped. */
        __publicField(this, "process", new sync_child_process_1.SyncChildProcess(compiler_path_1.compilerCommand[0], [...compiler_path_1.compilerCommand.slice(1), "--embedded"], {
          // Use the command's cwd so the compiler survives the removal of the
          // current working directory.
          // https://github.com/sass/embedded-host-node/pull/261#discussion_r1438712923
          cwd: path.dirname(compiler_path_1.compilerCommand[0]),
          // Node blocks launching .bat and .cmd without a shell due to CVE-2024-27980
          shell: [".bat", ".cmd"].includes(path.extname(compiler_path_1.compilerCommand[0]).toLowerCase()),
          windowsHide: true
        }));
        /** The next compilation ID. */
        __publicField(this, "compilationId", 1);
        /** A list of active dispatchers. */
        __publicField(this, "dispatchers", /* @__PURE__ */ new Set());
        /** The buffers emitted by the child process's stdout. */
        __publicField(this, "stdout$", new rxjs_1.Subject());
        /** The buffers emitted by the child process's stderr. */
        __publicField(this, "stderr$", new rxjs_1.Subject());
        /** Whether the underlying compiler has already exited. */
        __publicField(this, "disposed", false);
        /** Reusable message transformer for all compilations.  */
        __publicField(this, "messageTransformer");
        if (flag !== initFlag) {
          throw utils.compilerError("Compiler can not be directly constructed. Please use `sass.initAsyncCompiler()` instead.");
        }
        this.stderr$.subscribe((data) => process.stderr.write(data));
        const packetTransformer = new packet_transformer_1.PacketTransformer(this.stdout$, (buffer) => {
          this.writeStdin(buffer);
        });
        this.messageTransformer = new message_transformer_1.MessageTransformer(packetTransformer.outboundProtobufs$, (packet) => packetTransformer.writeInboundProtobuf(packet));
      }
      /** Writes `buffer` to the child process's stdin. */
      writeStdin(buffer) {
        this.process.stdin.write(buffer);
      }
      /** Yields the next event from the underlying process. */
      yield() {
        const result = this.process.next();
        if (result.done) {
          this.disposed = true;
          return false;
        }
        const event = result.value;
        switch (event.type) {
          case "stdout":
            this.stdout$.next(event.data);
            return true;
          case "stderr":
            this.stderr$.next(event.data);
            return true;
        }
      }
      /** Blocks until the underlying process exits. */
      yieldUntilExit() {
        while (!this.disposed) {
          this.yield();
        }
      }
      /**
       * Sends a compile request to the child process and returns the CompileResult.
       * Throws if there were any protocol or compilation errors.
       */
      compileRequestSync(request, importers, options) {
        const optionsKey = Symbol();
        deprecations_1.activeDeprecationOptions.set(optionsKey, options ?? {});
        try {
          const functions = new function_registry_1.FunctionRegistry(options == null ? void 0 : options.functions);
          const dispatcher = (0, utils_1.createDispatcher)(this.compilationId++, this.messageTransformer, {
            handleImportRequest: (request2) => importers.import(request2),
            handleFileImportRequest: (request2) => importers.fileImport(request2),
            handleCanonicalizeRequest: (request2) => importers.canonicalize(request2),
            handleFunctionCallRequest: (request2) => functions.call(request2)
          });
          this.dispatchers.add(dispatcher);
          dispatcher.logEvents$.subscribe((event) => (0, utils_1.handleLogEvent)(options, event));
          let error;
          let response;
          dispatcher.sendCompileRequest(request, (error_, response_) => {
            this.dispatchers.delete(dispatcher);
            if (this.dispatchers.size === 0)
              this.compilationId = 1;
            if (error_) {
              error = error_;
            } else {
              response = response_;
            }
          });
          for (; ; ) {
            if (!this.yield()) {
              throw utils.compilerError("Embedded compiler exited unexpectedly.");
            }
            if (error)
              throw error;
            if (response)
              return (0, utils_1.handleCompileResponse)(response);
          }
        } finally {
          deprecations_1.activeDeprecationOptions.delete(optionsKey);
        }
      }
      /** Guards against using a disposed compiler. */
      throwIfDisposed() {
        if (this.disposed) {
          throw utils.compilerError("Sync compiler has already been disposed.");
        }
      }
      compile(path2, options) {
        this.throwIfDisposed();
        const importers = new importer_registry_1.ImporterRegistry(options);
        return this.compileRequestSync((0, utils_1.newCompilePathRequest)(path2, importers, options), importers, options);
      }
      compileString(source, options) {
        this.throwIfDisposed();
        const importers = new importer_registry_1.ImporterRegistry(options);
        return this.compileRequestSync((0, utils_1.newCompileStringRequest)(source, importers, options), importers, options);
      }
      dispose() {
        this.process.stdin.end();
        this.yieldUntilExit();
      }
    };
    exports.Compiler = Compiler3;
    function initCompiler3() {
      return new Compiler3(initFlag);
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/compile.js
var require_compile = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/compile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodePackageImporter = void 0;
    exports.compile = compile3;
    exports.compileString = compileString3;
    exports.compileAsync = compileAsync3;
    exports.compileStringAsync = compileStringAsync3;
    var async_1 = require_async2();
    var sync_1 = require_sync();
    var importer_registry_1 = require_importer_registry();
    Object.defineProperty(exports, "NodePackageImporter", { enumerable: true, get: function() {
      return importer_registry_1.NodePackageImporter;
    } });
    function compile3(path, options) {
      const compiler = (0, sync_1.initCompiler)();
      try {
        return compiler.compile(path, options);
      } finally {
        compiler.dispose();
      }
    }
    function compileString3(source, options) {
      const compiler = (0, sync_1.initCompiler)();
      try {
        return compiler.compileString(source, options);
      } finally {
        compiler.dispose();
      }
    }
    async function compileAsync3(path, options) {
      const compiler = await (0, async_1.initAsyncCompiler)();
      try {
        return await compiler.compileAsync(path, options);
      } finally {
        await compiler.dispose();
      }
    }
    async function compileStringAsync3(source, options) {
      const compiler = await (0, async_1.initAsyncCompiler)();
      try {
        return await compiler.compileStringAsync(source, options);
      } finally {
        await compiler.dispose();
      }
    }
  }
});

// node_modules/sass-embedded/dist/lib/src/legacy/index.js
var require_legacy = __commonJS({
  "node_modules/sass-embedded/dist/lib/src/legacy/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = render3;
    exports.renderSync = renderSync3;
    var fs = require_fs();
    var p = require_path();
    var url_1 = require_url();
    var importer_registry_1 = require_importer_registry();
    var exception_1 = require_exception();
    var compile_1 = require_compile();
    var deprecations_1 = require_deprecations2();
    var utils_1 = require_utils();
    var wrap_1 = require_wrap();
    var importer_1 = require_importer();
    var utils_2 = require_utils3();
    function render3(options, callback) {
      try {
        options = adjustOptions(options);
        const start = Date.now();
        (0, deprecations_1.warnForHostSideDeprecation)("The legacy JS API is deprecated and will be removed in Dart Sass 2.0.0.\n\nMore info: https://sass-lang.com/d/legacy-js-api", deprecations_1.deprecations["legacy-js-api"], options);
        const compileSass = isStringOptions(options) ? (0, compile_1.compileStringAsync)(options.data, convertStringOptions(options, false)) : (0, compile_1.compileAsync)(options.file, convertOptions(options, false));
        compileSass.then((result) => callback(void 0, newLegacyResult(options, start, result)), (error) => callback(newLegacyException(error)));
      } catch (error) {
        if (error instanceof Error)
          callback(newLegacyException(error));
        throw error;
      }
    }
    function renderSync3(options) {
      const start = Date.now();
      try {
        options = adjustOptions(options);
        (0, deprecations_1.warnForHostSideDeprecation)("The legacy JS API is deprecated and will be removed in Dart Sass 2.0.0.\n\nMore info: https://sass-lang.com/d/legacy-js-api", deprecations_1.deprecations["legacy-js-api"], options);
        const result = isStringOptions(options) ? (0, compile_1.compileString)(options.data, convertStringOptions(options, true)) : (0, compile_1.compile)(options.file, convertOptions(options, true));
        return newLegacyResult(options, start, result);
      } catch (error) {
        throw newLegacyException(error);
      }
    }
    function adjustOptions(options) {
      if (!("file" in options && options.file) && !("data" in options)) {
        throw new Error("Either options.data or options.file must be set.");
      }
      options.includePaths = [process.cwd(), ...options.includePaths ?? []];
      if (!isStringOptions(options) && // The `indentedSyntax` option takes precedence over the file extension in the
      // legacy API, but the new API doesn't have a `syntax` option for a file path.
      // Instead, we eagerly load the entrypoint into memory and treat it like a
      // string source.
      (options.indentedSyntax !== void 0 || options.importer)) {
        return {
          ...options,
          data: fs.readFileSync(options.file, "utf8"),
          indentedSyntax: !!options.indentedSyntax
        };
      } else {
        return options;
      }
    }
    function isStringOptions(options) {
      return "data" in options;
    }
    function convertOptions(options, sync) {
      if ("outputStyle" in options && options.outputStyle !== "compressed" && options.outputStyle !== "expanded") {
        throw new Error(`Unknown output style: "${options.outputStyle}"`);
      }
      const self = pluginThis(options);
      const functions = {};
      for (let [signature, callback] of Object.entries(options.functions ?? {})) {
        if (!signature.includes("("))
          signature += "()";
        functions[signature.trimLeft()] = (0, wrap_1.wrapFunction)(self, callback, sync);
      }
      const importers = options.importer && (!(options.importer instanceof Array) || options.importer.length > 0) ? [
        new importer_1.LegacyImporterWrapper(self, options.importer instanceof Array ? options.importer : [options.importer], options.includePaths ?? [], options.file ?? "stdin", sync)
      ] : void 0;
      return {
        functions,
        importers: options.pkgImporter instanceof importer_registry_1.NodePackageImporter ? [options.pkgImporter, ...importers ?? []] : importers,
        sourceMap: wasSourceMapRequested(options),
        sourceMapIncludeSources: options.sourceMapContents,
        loadPaths: importers ? void 0 : options.includePaths,
        style: options.outputStyle,
        quietDeps: options.quietDeps,
        verbose: options.verbose,
        charset: options.charset,
        logger: options.logger,
        fatalDeprecations: options.fatalDeprecations,
        futureDeprecations: options.futureDeprecations,
        silenceDeprecations: options.silenceDeprecations,
        legacy: true
      };
    }
    function convertStringOptions(options, sync) {
      var _a;
      const modernOptions = convertOptions(options, sync);
      const importer = ((_a = modernOptions.importers) == null ? void 0 : _a.some((importer2) => importer2 instanceof importer_1.LegacyImporterWrapper)) ? {
        canonicalize() {
          return null;
        },
        load() {
          return null;
        }
      } : void 0;
      return {
        ...modernOptions,
        url: options.file ? options.importer ? (0, utils_2.pathToLegacyFileUrl)(options.file) : (0, url_1.pathToFileURL)(options.file) : new url_1.URL(utils_2.legacyImporterProtocol),
        importer,
        syntax: options.indentedSyntax ? "indented" : "scss"
      };
    }
    function wasSourceMapRequested(options) {
      return typeof options.sourceMap === "string" || options.sourceMap === true && !!options.outFile;
    }
    function pluginThis(options) {
      const pluginThis2 = {
        options: {
          context: void 0,
          file: options.file,
          data: options.data,
          includePaths: (options.includePaths ?? []).join(p.delimiter),
          precision: 10,
          style: 1,
          indentType: 0,
          indentWidth: 2,
          linefeed: "\n",
          result: {
            stats: {
              start: Date.now(),
              entry: options.file ?? "data"
            }
          }
        }
      };
      pluginThis2.options.context = pluginThis2;
      return pluginThis2;
    }
    function newLegacyResult(options, start, result) {
      const end = Date.now();
      let css = result.css;
      let sourceMapBytes;
      if (result.sourceMap) {
        const sourceMap = result.sourceMap;
        sourceMap.sourceRoot = options.sourceMapRoot ?? "";
        const sourceMapPath = typeof options.sourceMap === "string" ? options.sourceMap : options.outFile + ".map";
        const sourceMapDir = p.dirname(sourceMapPath);
        if (options.outFile) {
          sourceMap.file = (0, utils_1.pathToUrlString)(p.relative(sourceMapDir, options.outFile));
        } else if (options.file) {
          sourceMap.file = (0, utils_1.pathToUrlString)((0, utils_1.withoutExtension)(options.file) + ".css");
        } else {
          sourceMap.file = "stdin.css";
        }
        sourceMap.sources = sourceMap.sources.filter((source) => !source.startsWith(importer_1.endOfLoadProtocol)).map((source) => {
          source = (0, utils_2.removeLegacyImporter)(source);
          if (source.startsWith("file://")) {
            return (0, utils_1.pathToUrlString)(p.relative(sourceMapDir, (0, utils_1.fileUrlToPathCrossPlatform)(source)));
          } else if (source.startsWith("data:")) {
            return "stdin";
          } else {
            return source;
          }
        });
        sourceMapBytes = Buffer.from(JSON.stringify(sourceMap));
        if (!options.omitSourceMapUrl) {
          let url;
          if (options.sourceMapEmbed) {
            url = `data:application/json;base64,${sourceMapBytes.toString("base64")}`;
          } else if (options.outFile) {
            url = (0, utils_1.pathToUrlString)(p.relative(p.dirname(options.outFile), sourceMapPath));
          } else {
            url = (0, utils_1.pathToUrlString)(sourceMapPath);
          }
          css += `

/*# sourceMappingURL=${url} */`;
        }
      }
      return {
        css: Buffer.from(css),
        map: sourceMapBytes,
        stats: {
          entry: options.file ?? "data",
          start,
          end,
          duration: end - start,
          includedFiles: result.loadedUrls.filter((url) => url.protocol !== importer_1.endOfLoadProtocol).map((url) => {
            if (url.protocol === utils_2.legacyImporterProtocol) {
              return decodeURI(url.pathname);
            }
            const urlString = (0, utils_2.removeLegacyImporter)(url.toString());
            return urlString.startsWith("file:") ? (0, utils_1.fileUrlToPathCrossPlatform)(urlString) : urlString;
          })
        }
      };
    }
    function newLegacyException(error) {
      var _a, _b;
      if (!(error instanceof exception_1.Exception)) {
        return Object.assign(error, {
          formatted: error.toString(),
          status: 3
        });
      }
      const span = error.span ? (0, utils_2.removeLegacyImporterFromSpan)(error.span) : null;
      let file;
      if (!(span == null ? void 0 : span.url)) {
        file = "stdin";
      } else if (span.url.protocol === "file:") {
        file = (0, utils_1.fileUrlToPathCrossPlatform)(span.url);
      } else {
        file = span.url.toString();
      }
      const errorString = (0, utils_2.removeLegacyImporter)(error.toString());
      return Object.assign(new Error(), {
        status: 1,
        message: errorString.replace(/^Error: /, ""),
        formatted: errorString,
        toString: () => errorString,
        stack: error.stack ? (0, utils_2.removeLegacyImporter)(error.stack) : void 0,
        line: (0, utils_1.isNullOrUndefined)((_a = error.span) == null ? void 0 : _a.start.line) ? void 0 : error.span.start.line + 1,
        column: (0, utils_1.isNullOrUndefined)((_b = error.span) == null ? void 0 : _b.start.column) ? void 0 : error.span.start.column + 1,
        file
      });
    }
  }
});

// node_modules/sass-embedded/dist/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/sass-embedded/dist/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NULL = exports.FALSE = exports.TRUE = exports.Logger = exports.info = exports.renderSync = exports.render = exports.Version = exports.deprecations = exports.Compiler = exports.initCompiler = exports.AsyncCompiler = exports.initAsyncCompiler = exports.NodePackageImporter = exports.compileStringAsync = exports.compileAsync = exports.compileString = exports.compile = exports.Exception = exports.types = exports.SassCalculation = exports.CalculationInterpolation = exports.CalculationOperation = exports.sassNull = exports.Value = exports.SassString = exports.SassNumber = exports.SassMixin = exports.SassMap = exports.SassFunction = exports.SassColor = exports.sassTrue = exports.sassFalse = exports.SassArgumentList = exports.SassList = void 0;
    var pkg = require_package();
    var boolean_1 = require_boolean();
    var null_1 = require_null();
    var list_1 = require_list();
    Object.defineProperty(exports, "SassList", { enumerable: true, get: function() {
      return list_1.SassList;
    } });
    var argument_list_1 = require_argument_list();
    Object.defineProperty(exports, "SassArgumentList", { enumerable: true, get: function() {
      return argument_list_1.SassArgumentList;
    } });
    var boolean_2 = require_boolean();
    Object.defineProperty(exports, "sassFalse", { enumerable: true, get: function() {
      return boolean_2.sassFalse;
    } });
    Object.defineProperty(exports, "sassTrue", { enumerable: true, get: function() {
      return boolean_2.sassTrue;
    } });
    var color_1 = require_color2();
    Object.defineProperty(exports, "SassColor", { enumerable: true, get: function() {
      return color_1.SassColor;
    } });
    var function_1 = require_function();
    Object.defineProperty(exports, "SassFunction", { enumerable: true, get: function() {
      return function_1.SassFunction;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports, "SassMap", { enumerable: true, get: function() {
      return map_1.SassMap;
    } });
    var mixin_1 = require_mixin();
    Object.defineProperty(exports, "SassMixin", { enumerable: true, get: function() {
      return mixin_1.SassMixin;
    } });
    var number_1 = require_number();
    Object.defineProperty(exports, "SassNumber", { enumerable: true, get: function() {
      return number_1.SassNumber;
    } });
    var string_1 = require_string();
    Object.defineProperty(exports, "SassString", { enumerable: true, get: function() {
      return string_1.SassString;
    } });
    var value_1 = require_value();
    Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
      return value_1.Value;
    } });
    var null_2 = require_null();
    Object.defineProperty(exports, "sassNull", { enumerable: true, get: function() {
      return null_2.sassNull;
    } });
    var calculations_1 = require_calculations();
    Object.defineProperty(exports, "CalculationOperation", { enumerable: true, get: function() {
      return calculations_1.CalculationOperation;
    } });
    Object.defineProperty(exports, "CalculationInterpolation", { enumerable: true, get: function() {
      return calculations_1.CalculationInterpolation;
    } });
    Object.defineProperty(exports, "SassCalculation", { enumerable: true, get: function() {
      return calculations_1.SassCalculation;
    } });
    exports.types = require_value2();
    var exception_1 = require_exception();
    Object.defineProperty(exports, "Exception", { enumerable: true, get: function() {
      return exception_1.Exception;
    } });
    var compile_1 = require_compile();
    Object.defineProperty(exports, "compile", { enumerable: true, get: function() {
      return compile_1.compile;
    } });
    Object.defineProperty(exports, "compileString", { enumerable: true, get: function() {
      return compile_1.compileString;
    } });
    Object.defineProperty(exports, "compileAsync", { enumerable: true, get: function() {
      return compile_1.compileAsync;
    } });
    Object.defineProperty(exports, "compileStringAsync", { enumerable: true, get: function() {
      return compile_1.compileStringAsync;
    } });
    Object.defineProperty(exports, "NodePackageImporter", { enumerable: true, get: function() {
      return compile_1.NodePackageImporter;
    } });
    var async_1 = require_async2();
    Object.defineProperty(exports, "initAsyncCompiler", { enumerable: true, get: function() {
      return async_1.initAsyncCompiler;
    } });
    Object.defineProperty(exports, "AsyncCompiler", { enumerable: true, get: function() {
      return async_1.AsyncCompiler;
    } });
    var sync_1 = require_sync();
    Object.defineProperty(exports, "initCompiler", { enumerable: true, get: function() {
      return sync_1.initCompiler;
    } });
    Object.defineProperty(exports, "Compiler", { enumerable: true, get: function() {
      return sync_1.Compiler;
    } });
    var deprecations_1 = require_deprecations2();
    Object.defineProperty(exports, "deprecations", { enumerable: true, get: function() {
      return deprecations_1.deprecations;
    } });
    var version_1 = require_version();
    Object.defineProperty(exports, "Version", { enumerable: true, get: function() {
      return version_1.Version;
    } });
    var legacy_1 = require_legacy();
    Object.defineProperty(exports, "render", { enumerable: true, get: function() {
      return legacy_1.render;
    } });
    Object.defineProperty(exports, "renderSync", { enumerable: true, get: function() {
      return legacy_1.renderSync;
    } });
    exports.info = `sass-embedded	${pkg.version}`;
    var logger_1 = require_logger();
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    exports.TRUE = boolean_1.sassTrue;
    exports.FALSE = boolean_1.sassFalse;
    exports.NULL = null_1.sassNull;
  }
});

// node_modules/sass-embedded/dist/lib/index.mjs
var sass = __toESM(require_lib3(), 1);
var compile2 = sass.compile;
var compileAsync2 = sass.compileAsync;
var compileString2 = sass.compileString;
var compileStringAsync2 = sass.compileStringAsync;
var NodePackageImporter2 = sass.NodePackageImporter;
var AsyncCompiler2 = sass.AsyncCompiler;
var Compiler2 = sass.Compiler;
var initAsyncCompiler2 = sass.initAsyncCompiler;
var initCompiler2 = sass.initCompiler;
var deprecations2 = sass.deprecations;
var Version2 = sass.Version;
var Logger2 = sass.Logger;
var CalculationInterpolation2 = sass.CalculationInterpolation;
var CalculationOperation2 = sass.CalculationOperation;
var CalculationOperator2 = sass.CalculationOperator;
var SassArgumentList2 = sass.SassArgumentList;
var SassBoolean2 = sass.SassBoolean;
var SassCalculation2 = sass.SassCalculation;
var SassColor2 = sass.SassColor;
var SassFunction2 = sass.SassFunction;
var SassMixin2 = sass.SassMixin;
var SassList2 = sass.SassList;
var SassMap2 = sass.SassMap;
var SassNumber2 = sass.SassNumber;
var SassString2 = sass.SassString;
var Value2 = sass.Value;
var CustomFunction2 = sass.CustomFunction;
var ListSeparator2 = sass.ListSeparator;
var sassFalse2 = sass.sassFalse;
var sassNull2 = sass.sassNull;
var sassTrue2 = sass.sassTrue;
var Exception2 = sass.Exception;
var PromiseOr2 = sass.PromiseOr;
var info2 = sass.info;
var render2 = sass.render;
var renderSync2 = sass.renderSync;
var TRUE2 = sass.TRUE;
var FALSE2 = sass.FALSE;
var NULL2 = sass.NULL;
var types2 = sass.types;
var printedDefaultExportDeprecation = false;
function defaultExportDeprecation() {
  if (printedDefaultExportDeprecation) return;
  printedDefaultExportDeprecation = true;
  console.error(
    "`import sass from 'sass'` is deprecated.\nPlease use `import * as sass from 'sass'` instead."
  );
}
var lib_default = {
  get compile() {
    defaultExportDeprecation();
    return sass.compile;
  },
  get compileAsync() {
    defaultExportDeprecation();
    return sass.compileAsync;
  },
  get compileString() {
    defaultExportDeprecation();
    return sass.compileString;
  },
  get compileStringAsync() {
    defaultExportDeprecation();
    return sass.compileStringAsync;
  },
  get NodePackageImporter() {
    defaultExportDeprecation();
    return sass.NodePackageImporter;
  },
  get initAsyncCompiler() {
    defaultExportDeprecation();
    return sass.initAsyncCompiler;
  },
  get initCompiler() {
    defaultExportDeprecation();
    return sass.initCompiler;
  },
  get AsyncCompiler() {
    defaultExportDeprecation();
    return sass.AsyncCompiler;
  },
  get Compiler() {
    defaultExportDeprecation();
    return sass.Compiler;
  },
  get deprecations() {
    defaultExportDeprecation();
    return sass.deprecations;
  },
  get Version() {
    defaultExportDeprecation();
    return sass.Version;
  },
  get Logger() {
    defaultExportDeprecation();
    return sass.Logger;
  },
  get CalculationOperation() {
    defaultExportDeprecation();
    return sass.CalculationOperation;
  },
  get CalculationOperator() {
    defaultExportDeprecation();
    return sass.CalculationOperator;
  },
  get CalculationInterpolation() {
    defaultExportDeprecation();
    return sass.CalculationInterpolation;
  },
  get SassArgumentList() {
    defaultExportDeprecation();
    return sass.SassArgumentList;
  },
  get SassBoolean() {
    defaultExportDeprecation();
    return sass.SassBoolean;
  },
  get SassCalculation() {
    defaultExportDeprecation();
    return sass.SassCalculation;
  },
  get SassColor() {
    defaultExportDeprecation();
    return sass.SassColor;
  },
  get SassFunction() {
    defaultExportDeprecation();
    return sass.SassFunction;
  },
  get SassMixin() {
    defaultExportDeprecation();
    return sass.SassMixin;
  },
  get SassList() {
    defaultExportDeprecation();
    return sass.SassList;
  },
  get SassMap() {
    defaultExportDeprecation();
    return sass.SassMap;
  },
  get SassNumber() {
    defaultExportDeprecation();
    return sass.SassNumber;
  },
  get SassString() {
    defaultExportDeprecation();
    return sass.SassString;
  },
  get Value() {
    defaultExportDeprecation();
    return sass.Value;
  },
  get CustomFunction() {
    defaultExportDeprecation();
    return sass.CustomFunction;
  },
  get ListSeparator() {
    defaultExportDeprecation();
    return sass.ListSeparator;
  },
  get sassFalse() {
    defaultExportDeprecation();
    return sass.sassFalse;
  },
  get sassNull() {
    defaultExportDeprecation();
    return sass.sassNull;
  },
  get sassTrue() {
    defaultExportDeprecation();
    return sass.sassTrue;
  },
  get Exception() {
    defaultExportDeprecation();
    return sass.Exception;
  },
  get PromiseOr() {
    defaultExportDeprecation();
    return sass.PromiseOr;
  },
  get info() {
    defaultExportDeprecation();
    return sass.info;
  },
  get render() {
    defaultExportDeprecation();
    return sass.render;
  },
  get renderSync() {
    defaultExportDeprecation();
    return sass.renderSync;
  },
  get TRUE() {
    defaultExportDeprecation();
    return sass.TRUE;
  },
  get FALSE() {
    defaultExportDeprecation();
    return sass.FALSE;
  },
  get NULL() {
    defaultExportDeprecation();
    return sass.NULL;
  },
  get types() {
    defaultExportDeprecation();
    return sass.types;
  }
};
export {
  AsyncCompiler2 as AsyncCompiler,
  CalculationInterpolation2 as CalculationInterpolation,
  CalculationOperation2 as CalculationOperation,
  CalculationOperator2 as CalculationOperator,
  Compiler2 as Compiler,
  CustomFunction2 as CustomFunction,
  Exception2 as Exception,
  FALSE2 as FALSE,
  ListSeparator2 as ListSeparator,
  Logger2 as Logger,
  NULL2 as NULL,
  NodePackageImporter2 as NodePackageImporter,
  PromiseOr2 as PromiseOr,
  SassArgumentList2 as SassArgumentList,
  SassBoolean2 as SassBoolean,
  SassCalculation2 as SassCalculation,
  SassColor2 as SassColor,
  SassFunction2 as SassFunction,
  SassList2 as SassList,
  SassMap2 as SassMap,
  SassMixin2 as SassMixin,
  SassNumber2 as SassNumber,
  SassString2 as SassString,
  TRUE2 as TRUE,
  Value2 as Value,
  Version2 as Version,
  compile2 as compile,
  compileAsync2 as compileAsync,
  compileString2 as compileString,
  compileStringAsync2 as compileStringAsync,
  lib_default as default,
  deprecations2 as deprecations,
  info2 as info,
  initAsyncCompiler2 as initAsyncCompiler,
  initCompiler2 as initCompiler,
  render2 as render,
  renderSync2 as renderSync,
  sassFalse2 as sassFalse,
  sassNull2 as sassNull,
  sassTrue2 as sassTrue,
  types2 as types
};
/*! Bundled license information:

immutable/dist/immutable.es.js:
  (**
   * @license
   * MIT License
   * 
   * Copyright (c) 2014-present, Lee Byron and other contributors.
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)
*/
//# sourceMappingURL=sass-embedded.js.map
